(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
    typeof define === 'function' && define.amd ? define(factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.MySDK = factory());
})(this, (function () { 'use strict';

    function _mergeNamespaces(n, m) {
        m.forEach(function (e) {
            e && typeof e !== 'string' && !Array.isArray(e) && Object.keys(e).forEach(function (k) {
                if (k !== 'default' && !(k in n)) {
                    var d = Object.getOwnPropertyDescriptor(e, k);
                    Object.defineProperty(n, k, d.get ? d : {
                        enumerable: true,
                        get: function () { return e[k]; }
                    });
                }
            });
        });
        return Object.freeze(n);
    }

    /******************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise, SuppressedError, Symbol, Iterator */


    var __assign = function() {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };

    typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {
        var e = new Error(message);
        return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };

    function getDefaultExportFromCjs (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    var react = {exports: {}};

    var react_production_min = {};

    /**
     * @license React
     * react.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredReact_production_min;

    function requireReact_production_min () {
    	if (hasRequiredReact_production_min) return react_production_min;
    	hasRequiredReact_production_min = 1;
    var l=Symbol.for("react.element"),n=Symbol.for("react.portal"),p=Symbol.for("react.fragment"),q=Symbol.for("react.strict_mode"),r=Symbol.for("react.profiler"),t=Symbol.for("react.provider"),u=Symbol.for("react.context"),v=Symbol.for("react.forward_ref"),w=Symbol.for("react.suspense"),x=Symbol.for("react.memo"),y=Symbol.for("react.lazy"),z=Symbol.iterator;function A(a){if(null===a||"object"!==typeof a)return null;a=z&&a[z]||a["@@iterator"];return "function"===typeof a?a:null}
    	var B={isMounted:function(){return  false},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},C=Object.assign,D={};function E(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B;}E.prototype.isReactComponent={};
    	E.prototype.setState=function(a,b){if("object"!==typeof a&&"function"!==typeof a&&null!=a)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,a,b,"setState");};E.prototype.forceUpdate=function(a){this.updater.enqueueForceUpdate(this,a,"forceUpdate");};function F(){}F.prototype=E.prototype;function G(a,b,e){this.props=a;this.context=b;this.refs=D;this.updater=e||B;}var H=G.prototype=new F;
    	H.constructor=G;C(H,E.prototype);H.isPureReactComponent=true;var I=Array.isArray,J=Object.prototype.hasOwnProperty,K={current:null},L={key:true,ref:true,__self:true,__source:true};
    	function M(a,b,e){var d,c={},k=null,h=null;if(null!=b)for(d in void 0!==b.ref&&(h=b.ref),void 0!==b.key&&(k=""+b.key),b)J.call(b,d)&&!L.hasOwnProperty(d)&&(c[d]=b[d]);var g=arguments.length-2;if(1===g)c.children=e;else if(1<g){for(var f=Array(g),m=0;m<g;m++)f[m]=arguments[m+2];c.children=f;}if(a&&a.defaultProps)for(d in g=a.defaultProps,g) void 0===c[d]&&(c[d]=g[d]);return {$$typeof:l,type:a,key:k,ref:h,props:c,_owner:K.current}}
    	function N(a,b){return {$$typeof:l,type:a.type,key:b,ref:a.ref,props:a.props,_owner:a._owner}}function O(a){return "object"===typeof a&&null!==a&&a.$$typeof===l}function escape(a){var b={"=":"=0",":":"=2"};return "$"+a.replace(/[=:]/g,function(a){return b[a]})}var P=/\/+/g;function Q(a,b){return "object"===typeof a&&null!==a&&null!=a.key?escape(""+a.key):b.toString(36)}
    	function R(a,b,e,d,c){var k=typeof a;if("undefined"===k||"boolean"===k)a=null;var h=false;if(null===a)h=true;else switch(k){case "string":case "number":h=true;break;case "object":switch(a.$$typeof){case l:case n:h=true;}}if(h)return h=a,c=c(h),a=""===d?"."+Q(h,0):d,I(c)?(e="",null!=a&&(e=a.replace(P,"$&/")+"/"),R(c,b,e,"",function(a){return a})):null!=c&&(O(c)&&(c=N(c,e+(!c.key||h&&h.key===c.key?"":(""+c.key).replace(P,"$&/")+"/")+a)),b.push(c)),1;h=0;d=""===d?".":d+":";if(I(a))for(var g=0;g<a.length;g++){k=
    	a[g];var f=d+Q(k,g);h+=R(k,b,e,f,c);}else if(f=A(a),"function"===typeof f)for(a=f.call(a),g=0;!(k=a.next()).done;)k=k.value,f=d+Q(k,g++),h+=R(k,b,e,f,c);else if("object"===k)throw b=String(a),Error("Objects are not valid as a React child (found: "+("[object Object]"===b?"object with keys {"+Object.keys(a).join(", ")+"}":b)+"). If you meant to render a collection of children, use an array instead.");return h}
    	function S(a,b,e){if(null==a)return a;var d=[],c=0;R(a,d,"","",function(a){return b.call(e,a,c++)});return d}function T(a){if(-1===a._status){var b=a._result;b=b();b.then(function(b){if(0===a._status||-1===a._status)a._status=1,a._result=b;},function(b){if(0===a._status||-1===a._status)a._status=2,a._result=b;});-1===a._status&&(a._status=0,a._result=b);}if(1===a._status)return a._result.default;throw a._result;}
    	var U={current:null},V={transition:null},W={ReactCurrentDispatcher:U,ReactCurrentBatchConfig:V,ReactCurrentOwner:K};function X(){throw Error("act(...) is not supported in production builds of React.");}
    	react_production_min.Children={map:S,forEach:function(a,b,e){S(a,function(){b.apply(this,arguments);},e);},count:function(a){var b=0;S(a,function(){b++;});return b},toArray:function(a){return S(a,function(a){return a})||[]},only:function(a){if(!O(a))throw Error("React.Children.only expected to receive a single React element child.");return a}};react_production_min.Component=E;react_production_min.Fragment=p;react_production_min.Profiler=r;react_production_min.PureComponent=G;react_production_min.StrictMode=q;react_production_min.Suspense=w;
    	react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=W;react_production_min.act=X;
    	react_production_min.cloneElement=function(a,b,e){if(null===a||void 0===a)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+a+".");var d=C({},a.props),c=a.key,k=a.ref,h=a._owner;if(null!=b){ void 0!==b.ref&&(k=b.ref,h=K.current);void 0!==b.key&&(c=""+b.key);if(a.type&&a.type.defaultProps)var g=a.type.defaultProps;for(f in b)J.call(b,f)&&!L.hasOwnProperty(f)&&(d[f]=void 0===b[f]&&void 0!==g?g[f]:b[f]);}var f=arguments.length-2;if(1===f)d.children=e;else if(1<f){g=Array(f);
    	for(var m=0;m<f;m++)g[m]=arguments[m+2];d.children=g;}return {$$typeof:l,type:a.type,key:c,ref:k,props:d,_owner:h}};react_production_min.createContext=function(a){a={$$typeof:u,_currentValue:a,_currentValue2:a,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null};a.Provider={$$typeof:t,_context:a};return a.Consumer=a};react_production_min.createElement=M;react_production_min.createFactory=function(a){var b=M.bind(null,a);b.type=a;return b};react_production_min.createRef=function(){return {current:null}};
    	react_production_min.forwardRef=function(a){return {$$typeof:v,render:a}};react_production_min.isValidElement=O;react_production_min.lazy=function(a){return {$$typeof:y,_payload:{_status:-1,_result:a},_init:T}};react_production_min.memo=function(a,b){return {$$typeof:x,type:a,compare:void 0===b?null:b}};react_production_min.startTransition=function(a){var b=V.transition;V.transition={};try{a();}finally{V.transition=b;}};react_production_min.unstable_act=X;react_production_min.useCallback=function(a,b){return U.current.useCallback(a,b)};react_production_min.useContext=function(a){return U.current.useContext(a)};
    	react_production_min.useDebugValue=function(){};react_production_min.useDeferredValue=function(a){return U.current.useDeferredValue(a)};react_production_min.useEffect=function(a,b){return U.current.useEffect(a,b)};react_production_min.useId=function(){return U.current.useId()};react_production_min.useImperativeHandle=function(a,b,e){return U.current.useImperativeHandle(a,b,e)};react_production_min.useInsertionEffect=function(a,b){return U.current.useInsertionEffect(a,b)};react_production_min.useLayoutEffect=function(a,b){return U.current.useLayoutEffect(a,b)};
    	react_production_min.useMemo=function(a,b){return U.current.useMemo(a,b)};react_production_min.useReducer=function(a,b,e){return U.current.useReducer(a,b,e)};react_production_min.useRef=function(a){return U.current.useRef(a)};react_production_min.useState=function(a){return U.current.useState(a)};react_production_min.useSyncExternalStore=function(a,b,e){return U.current.useSyncExternalStore(a,b,e)};react_production_min.useTransition=function(){return U.current.useTransition()};react_production_min.version="18.3.1";
    	return react_production_min;
    }

    var hasRequiredReact;

    function requireReact () {
    	if (hasRequiredReact) return react.exports;
    	hasRequiredReact = 1;

    	{
    	  react.exports = requireReact_production_min();
    	}
    	return react.exports;
    }

    var reactExports = requireReact();
    var React = /*@__PURE__*/getDefaultExportFromCjs(reactExports);

    var React$1 = /*#__PURE__*/_mergeNamespaces({
        __proto__: null,
        default: React
    }, [reactExports]);

    var client = {};

    var reactDom = {exports: {}};

    var reactDom_production_min = {};

    var scheduler = {exports: {}};

    var scheduler_production_min = {};

    /**
     * @license React
     * scheduler.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredScheduler_production_min;

    function requireScheduler_production_min () {
    	if (hasRequiredScheduler_production_min) return scheduler_production_min;
    	hasRequiredScheduler_production_min = 1;
    	(function (exports$1) {
    function f(a,b){var c=a.length;a.push(b);a:for(;0<c;){var d=c-1>>>1,e=a[d];if(0<g(e,b))a[d]=b,a[c]=e,c=d;else break a}}function h(a){return 0===a.length?null:a[0]}function k(a){if(0===a.length)return null;var b=a[0],c=a.pop();if(c!==b){a[0]=c;a:for(var d=0,e=a.length,w=e>>>1;d<w;){var m=2*(d+1)-1,C=a[m],n=m+1,x=a[n];if(0>g(C,c))n<e&&0>g(x,C)?(a[d]=x,a[n]=c,d=n):(a[d]=C,a[m]=c,d=m);else if(n<e&&0>g(x,c))a[d]=x,a[n]=c,d=n;else break a}}return b}
    		function g(a,b){var c=a.sortIndex-b.sortIndex;return 0!==c?c:a.id-b.id}if("object"===typeof performance&&"function"===typeof performance.now){var l=performance;exports$1.unstable_now=function(){return l.now()};}else {var p=Date,q=p.now();exports$1.unstable_now=function(){return p.now()-q};}var r=[],t=[],u=1,v=null,y=3,z=false,A=false,B=false,D="function"===typeof setTimeout?setTimeout:null,E="function"===typeof clearTimeout?clearTimeout:null,F="undefined"!==typeof setImmediate?setImmediate:null;
    		"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function G(a){for(var b=h(t);null!==b;){if(null===b.callback)k(t);else if(b.startTime<=a)k(t),b.sortIndex=b.expirationTime,f(r,b);else break;b=h(t);}}function H(a){B=false;G(a);if(!A)if(null!==h(r))A=true,I(J);else {var b=h(t);null!==b&&K(H,b.startTime-a);}}
    		function J(a,b){A=false;B&&(B=false,E(L),L=-1);z=true;var c=y;try{G(b);for(v=h(r);null!==v&&(!(v.expirationTime>b)||a&&!M());){var d=v.callback;if("function"===typeof d){v.callback=null;y=v.priorityLevel;var e=d(v.expirationTime<=b);b=exports$1.unstable_now();"function"===typeof e?v.callback=e:v===h(r)&&k(r);G(b);}else k(r);v=h(r);}if(null!==v)var w=!0;else {var m=h(t);null!==m&&K(H,m.startTime-b);w=!1;}return w}finally{v=null,y=c,z=false;}}var N=false,O=null,L=-1,P=5,Q=-1;
    		function M(){return exports$1.unstable_now()-Q<P?false:true}function R(){if(null!==O){var a=exports$1.unstable_now();Q=a;var b=true;try{b=O(!0,a);}finally{b?S():(N=false,O=null);}}else N=false;}var S;if("function"===typeof F)S=function(){F(R);};else if("undefined"!==typeof MessageChannel){var T=new MessageChannel,U=T.port2;T.port1.onmessage=R;S=function(){U.postMessage(null);};}else S=function(){D(R,0);};function I(a){O=a;N||(N=true,S());}function K(a,b){L=D(function(){a(exports$1.unstable_now());},b);}
    		exports$1.unstable_IdlePriority=5;exports$1.unstable_ImmediatePriority=1;exports$1.unstable_LowPriority=4;exports$1.unstable_NormalPriority=3;exports$1.unstable_Profiling=null;exports$1.unstable_UserBlockingPriority=2;exports$1.unstable_cancelCallback=function(a){a.callback=null;};exports$1.unstable_continueExecution=function(){A||z||(A=true,I(J));};
    		exports$1.unstable_forceFrameRate=function(a){0>a||125<a?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):P=0<a?Math.floor(1E3/a):5;};exports$1.unstable_getCurrentPriorityLevel=function(){return y};exports$1.unstable_getFirstCallbackNode=function(){return h(r)};exports$1.unstable_next=function(a){switch(y){case 1:case 2:case 3:var b=3;break;default:b=y;}var c=y;y=b;try{return a()}finally{y=c;}};exports$1.unstable_pauseExecution=function(){};
    		exports$1.unstable_requestPaint=function(){};exports$1.unstable_runWithPriority=function(a,b){switch(a){case 1:case 2:case 3:case 4:case 5:break;default:a=3;}var c=y;y=a;try{return b()}finally{y=c;}};
    		exports$1.unstable_scheduleCallback=function(a,b,c){var d=exports$1.unstable_now();"object"===typeof c&&null!==c?(c=c.delay,c="number"===typeof c&&0<c?d+c:d):c=d;switch(a){case 1:var e=-1;break;case 2:e=250;break;case 5:e=1073741823;break;case 4:e=1E4;break;default:e=5E3;}e=c+e;a={id:u++,callback:b,priorityLevel:a,startTime:c,expirationTime:e,sortIndex:-1};c>d?(a.sortIndex=c,f(t,a),null===h(r)&&a===h(t)&&(B?(E(L),L=-1):B=true,K(H,c-d))):(a.sortIndex=e,f(r,a),A||z||(A=true,I(J)));return a};
    		exports$1.unstable_shouldYield=M;exports$1.unstable_wrapCallback=function(a){var b=y;return function(){var c=y;y=b;try{return a.apply(this,arguments)}finally{y=c;}}}; 
    	} (scheduler_production_min));
    	return scheduler_production_min;
    }

    var hasRequiredScheduler;

    function requireScheduler () {
    	if (hasRequiredScheduler) return scheduler.exports;
    	hasRequiredScheduler = 1;

    	{
    	  scheduler.exports = requireScheduler_production_min();
    	}
    	return scheduler.exports;
    }

    /**
     * @license React
     * react-dom.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredReactDom_production_min;

    function requireReactDom_production_min () {
    	if (hasRequiredReactDom_production_min) return reactDom_production_min;
    	hasRequiredReactDom_production_min = 1;
    var aa=requireReact(),ca=requireScheduler();function p(a){for(var b="https://reactjs.org/docs/error-decoder.html?invariant="+a,c=1;c<arguments.length;c++)b+="&args[]="+encodeURIComponent(arguments[c]);return "Minified React error #"+a+"; visit "+b+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var da=new Set,ea={};function fa(a,b){ha(a,b);ha(a+"Capture",b);}
    	function ha(a,b){ea[a]=b;for(a=0;a<b.length;a++)da.add(b[a]);}
    	var ia=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),ja=Object.prototype.hasOwnProperty,ka=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,la=
    	{},ma={};function oa(a){if(ja.call(ma,a))return  true;if(ja.call(la,a))return  false;if(ka.test(a))return ma[a]=true;la[a]=true;return  false}function pa(a,b,c,d){if(null!==c&&0===c.type)return  false;switch(typeof b){case "function":case "symbol":return  true;case "boolean":if(d)return  false;if(null!==c)return !c.acceptsBooleans;a=a.toLowerCase().slice(0,5);return "data-"!==a&&"aria-"!==a;default:return  false}}
    	function qa(a,b,c,d){if(null===b||"undefined"===typeof b||pa(a,b,c,d))return  true;if(d)return  false;if(null!==c)switch(c.type){case 3:return !b;case 4:return  false===b;case 5:return isNaN(b);case 6:return isNaN(b)||1>b}return  false}function v(a,b,c,d,e,f,g){this.acceptsBooleans=2===b||3===b||4===b;this.attributeName=d;this.attributeNamespace=e;this.mustUseProperty=c;this.propertyName=a;this.type=b;this.sanitizeURL=f;this.removeEmptyString=g;}var z={};
    	"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a){z[a]=new v(a,0,false,a,null,false,false);});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(a){var b=a[0];z[b]=new v(b,1,false,a[1],null,false,false);});["contentEditable","draggable","spellCheck","value"].forEach(function(a){z[a]=new v(a,2,false,a.toLowerCase(),null,false,false);});
    	["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(a){z[a]=new v(a,2,false,a,null,false,false);});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a){z[a]=new v(a,3,false,a.toLowerCase(),null,false,false);});
    	["checked","multiple","muted","selected"].forEach(function(a){z[a]=new v(a,3,true,a,null,false,false);});["capture","download"].forEach(function(a){z[a]=new v(a,4,false,a,null,false,false);});["cols","rows","size","span"].forEach(function(a){z[a]=new v(a,6,false,a,null,false,false);});["rowSpan","start"].forEach(function(a){z[a]=new v(a,5,false,a.toLowerCase(),null,false,false);});var ra=/[\-:]([a-z])/g;function sa(a){return a[1].toUpperCase()}
    	"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a){var b=a.replace(ra,
    	sa);z[b]=new v(b,1,false,a,null,false,false);});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,false,a,"http://www.w3.org/1999/xlink",false,false);});["xml:base","xml:lang","xml:space"].forEach(function(a){var b=a.replace(ra,sa);z[b]=new v(b,1,false,a,"http://www.w3.org/XML/1998/namespace",false,false);});["tabIndex","crossOrigin"].forEach(function(a){z[a]=new v(a,1,false,a.toLowerCase(),null,false,false);});
    	z.xlinkHref=new v("xlinkHref",1,false,"xlink:href","http://www.w3.org/1999/xlink",true,false);["src","href","action","formAction"].forEach(function(a){z[a]=new v(a,1,false,a.toLowerCase(),null,true,true);});
    	function ta(a,b,c,d){var e=z.hasOwnProperty(b)?z[b]:null;if(null!==e?0!==e.type:d||!(2<b.length)||"o"!==b[0]&&"O"!==b[0]||"n"!==b[1]&&"N"!==b[1])qa(b,c,e,d)&&(c=null),d||null===e?oa(b)&&(null===c?a.removeAttribute(b):a.setAttribute(b,""+c)):e.mustUseProperty?a[e.propertyName]=null===c?3===e.type?false:"":c:(b=e.attributeName,d=e.attributeNamespace,null===c?a.removeAttribute(b):(e=e.type,c=3===e||4===e&&true===c?"":""+c,d?a.setAttributeNS(d,b,c):a.setAttribute(b,c)));}
    	var ua=aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,va=Symbol.for("react.element"),wa=Symbol.for("react.portal"),ya=Symbol.for("react.fragment"),za=Symbol.for("react.strict_mode"),Aa=Symbol.for("react.profiler"),Ba=Symbol.for("react.provider"),Ca=Symbol.for("react.context"),Da=Symbol.for("react.forward_ref"),Ea=Symbol.for("react.suspense"),Fa=Symbol.for("react.suspense_list"),Ga=Symbol.for("react.memo"),Ha=Symbol.for("react.lazy");	var Ia=Symbol.for("react.offscreen");var Ja=Symbol.iterator;function Ka(a){if(null===a||"object"!==typeof a)return null;a=Ja&&a[Ja]||a["@@iterator"];return "function"===typeof a?a:null}var A=Object.assign,La;function Ma(a){if(void 0===La)try{throw Error();}catch(c){var b=c.stack.trim().match(/\n( *(at )?)/);La=b&&b[1]||"";}return "\n"+La+a}var Na=false;
    	function Oa(a,b){if(!a||Na)return "";Na=true;var c=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(b)if(b=function(){throw Error();},Object.defineProperty(b.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(b,[]);}catch(l){var d=l;}Reflect.construct(a,[],b);}else {try{b.call();}catch(l){d=l;}a.call(b.prototype);}else {try{throw Error();}catch(l){d=l;}a();}}catch(l){if(l&&d&&"string"===typeof l.stack){for(var e=l.stack.split("\n"),
    	f=d.stack.split("\n"),g=e.length-1,h=f.length-1;1<=g&&0<=h&&e[g]!==f[h];)h--;for(;1<=g&&0<=h;g--,h--)if(e[g]!==f[h]){if(1!==g||1!==h){do if(g--,h--,0>h||e[g]!==f[h]){var k="\n"+e[g].replace(" at new "," at ");a.displayName&&k.includes("<anonymous>")&&(k=k.replace("<anonymous>",a.displayName));return k}while(1<=g&&0<=h)}break}}}finally{Na=false,Error.prepareStackTrace=c;}return (a=a?a.displayName||a.name:"")?Ma(a):""}
    	function Pa(a){switch(a.tag){case 5:return Ma(a.type);case 16:return Ma("Lazy");case 13:return Ma("Suspense");case 19:return Ma("SuspenseList");case 0:case 2:case 15:return a=Oa(a.type,false),a;case 11:return a=Oa(a.type.render,false),a;case 1:return a=Oa(a.type,true),a;default:return ""}}
    	function Qa(a){if(null==a)return null;if("function"===typeof a)return a.displayName||a.name||null;if("string"===typeof a)return a;switch(a){case ya:return "Fragment";case wa:return "Portal";case Aa:return "Profiler";case za:return "StrictMode";case Ea:return "Suspense";case Fa:return "SuspenseList"}if("object"===typeof a)switch(a.$$typeof){case Ca:return (a.displayName||"Context")+".Consumer";case Ba:return (a._context.displayName||"Context")+".Provider";case Da:var b=a.render;a=a.displayName;a||(a=b.displayName||
    	b.name||"",a=""!==a?"ForwardRef("+a+")":"ForwardRef");return a;case Ga:return b=a.displayName||null,null!==b?b:Qa(a.type)||"Memo";case Ha:b=a._payload;a=a._init;try{return Qa(a(b))}catch(c){}}return null}
    	function Ra(a){var b=a.type;switch(a.tag){case 24:return "Cache";case 9:return (b.displayName||"Context")+".Consumer";case 10:return (b._context.displayName||"Context")+".Provider";case 18:return "DehydratedFragment";case 11:return a=b.render,a=a.displayName||a.name||"",b.displayName||(""!==a?"ForwardRef("+a+")":"ForwardRef");case 7:return "Fragment";case 5:return b;case 4:return "Portal";case 3:return "Root";case 6:return "Text";case 16:return Qa(b);case 8:return b===za?"StrictMode":"Mode";case 22:return "Offscreen";
    	case 12:return "Profiler";case 21:return "Scope";case 13:return "Suspense";case 19:return "SuspenseList";case 25:return "TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof b)return b.displayName||b.name||null;if("string"===typeof b)return b}return null}function Sa(a){switch(typeof a){case "boolean":case "number":case "string":case "undefined":return a;case "object":return a;default:return ""}}
    	function Ta(a){var b=a.type;return (a=a.nodeName)&&"input"===a.toLowerCase()&&("checkbox"===b||"radio"===b)}
    	function Ua(a){var b=Ta(a)?"checked":"value",c=Object.getOwnPropertyDescriptor(a.constructor.prototype,b),d=""+a[b];if(!a.hasOwnProperty(b)&&"undefined"!==typeof c&&"function"===typeof c.get&&"function"===typeof c.set){var e=c.get,f=c.set;Object.defineProperty(a,b,{configurable:true,get:function(){return e.call(this)},set:function(a){d=""+a;f.call(this,a);}});Object.defineProperty(a,b,{enumerable:c.enumerable});return {getValue:function(){return d},setValue:function(a){d=""+a;},stopTracking:function(){a._valueTracker=
    	null;delete a[b];}}}}function Va(a){a._valueTracker||(a._valueTracker=Ua(a));}function Wa(a){if(!a)return  false;var b=a._valueTracker;if(!b)return  true;var c=b.getValue();var d="";a&&(d=Ta(a)?a.checked?"true":"false":a.value);a=d;return a!==c?(b.setValue(a),true):false}function Xa(a){a=a||("undefined"!==typeof document?document:void 0);if("undefined"===typeof a)return null;try{return a.activeElement||a.body}catch(b){return a.body}}
    	function Ya(a,b){var c=b.checked;return A({},b,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=c?c:a._wrapperState.initialChecked})}function Za(a,b){var c=null==b.defaultValue?"":b.defaultValue,d=null!=b.checked?b.checked:b.defaultChecked;c=Sa(null!=b.value?b.value:c);a._wrapperState={initialChecked:d,initialValue:c,controlled:"checkbox"===b.type||"radio"===b.type?null!=b.checked:null!=b.value};}function ab(a,b){b=b.checked;null!=b&&ta(a,"checked",b,false);}
    	function bb(a,b){ab(a,b);var c=Sa(b.value),d=b.type;if(null!=c)if("number"===d){if(0===c&&""===a.value||a.value!=c)a.value=""+c;}else a.value!==""+c&&(a.value=""+c);else if("submit"===d||"reset"===d){a.removeAttribute("value");return}b.hasOwnProperty("value")?cb(a,b.type,c):b.hasOwnProperty("defaultValue")&&cb(a,b.type,Sa(b.defaultValue));null==b.checked&&null!=b.defaultChecked&&(a.defaultChecked=!!b.defaultChecked);}
    	function db(a,b,c){if(b.hasOwnProperty("value")||b.hasOwnProperty("defaultValue")){var d=b.type;if(!("submit"!==d&&"reset"!==d||void 0!==b.value&&null!==b.value))return;b=""+a._wrapperState.initialValue;c||b===a.value||(a.value=b);a.defaultValue=b;}c=a.name;""!==c&&(a.name="");a.defaultChecked=!!a._wrapperState.initialChecked;""!==c&&(a.name=c);}
    	function cb(a,b,c){if("number"!==b||Xa(a.ownerDocument)!==a)null==c?a.defaultValue=""+a._wrapperState.initialValue:a.defaultValue!==""+c&&(a.defaultValue=""+c);}var eb=Array.isArray;
    	function fb(a,b,c,d){a=a.options;if(b){b={};for(var e=0;e<c.length;e++)b["$"+c[e]]=true;for(c=0;c<a.length;c++)e=b.hasOwnProperty("$"+a[c].value),a[c].selected!==e&&(a[c].selected=e),e&&d&&(a[c].defaultSelected=true);}else {c=""+Sa(c);b=null;for(e=0;e<a.length;e++){if(a[e].value===c){a[e].selected=true;d&&(a[e].defaultSelected=true);return}null!==b||a[e].disabled||(b=a[e]);}null!==b&&(b.selected=true);}}
    	function gb(a,b){if(null!=b.dangerouslySetInnerHTML)throw Error(p(91));return A({},b,{value:void 0,defaultValue:void 0,children:""+a._wrapperState.initialValue})}function hb(a,b){var c=b.value;if(null==c){c=b.children;b=b.defaultValue;if(null!=c){if(null!=b)throw Error(p(92));if(eb(c)){if(1<c.length)throw Error(p(93));c=c[0];}b=c;}null==b&&(b="");c=b;}a._wrapperState={initialValue:Sa(c)};}
    	function ib(a,b){var c=Sa(b.value),d=Sa(b.defaultValue);null!=c&&(c=""+c,c!==a.value&&(a.value=c),null==b.defaultValue&&a.defaultValue!==c&&(a.defaultValue=c));null!=d&&(a.defaultValue=""+d);}function jb(a){var b=a.textContent;b===a._wrapperState.initialValue&&""!==b&&null!==b&&(a.value=b);}function kb(a){switch(a){case "svg":return "http://www.w3.org/2000/svg";case "math":return "http://www.w3.org/1998/Math/MathML";default:return "http://www.w3.org/1999/xhtml"}}
    	function lb(a,b){return null==a||"http://www.w3.org/1999/xhtml"===a?kb(b):"http://www.w3.org/2000/svg"===a&&"foreignObject"===b?"http://www.w3.org/1999/xhtml":a}
    	var mb,nb=function(a){return "undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(b,c,d,e){MSApp.execUnsafeLocalFunction(function(){return a(b,c,d,e)});}:a}(function(a,b){if("http://www.w3.org/2000/svg"!==a.namespaceURI||"innerHTML"in a)a.innerHTML=b;else {mb=mb||document.createElement("div");mb.innerHTML="<svg>"+b.valueOf().toString()+"</svg>";for(b=mb.firstChild;a.firstChild;)a.removeChild(a.firstChild);for(;b.firstChild;)a.appendChild(b.firstChild);}});
    	function ob(a,b){if(b){var c=a.firstChild;if(c&&c===a.lastChild&&3===c.nodeType){c.nodeValue=b;return}}a.textContent=b;}
    	var pb={animationIterationCount:true,aspectRatio:true,borderImageOutset:true,borderImageSlice:true,borderImageWidth:true,boxFlex:true,boxFlexGroup:true,boxOrdinalGroup:true,columnCount:true,columns:true,flex:true,flexGrow:true,flexPositive:true,flexShrink:true,flexNegative:true,flexOrder:true,gridArea:true,gridRow:true,gridRowEnd:true,gridRowSpan:true,gridRowStart:true,gridColumn:true,gridColumnEnd:true,gridColumnSpan:true,gridColumnStart:true,fontWeight:true,lineClamp:true,lineHeight:true,opacity:true,order:true,orphans:true,tabSize:true,widows:true,zIndex:true,
    	zoom:true,fillOpacity:true,floodOpacity:true,stopOpacity:true,strokeDasharray:true,strokeDashoffset:true,strokeMiterlimit:true,strokeOpacity:true,strokeWidth:true},qb=["Webkit","ms","Moz","O"];Object.keys(pb).forEach(function(a){qb.forEach(function(b){b=b+a.charAt(0).toUpperCase()+a.substring(1);pb[b]=pb[a];});});function rb(a,b,c){return null==b||"boolean"===typeof b||""===b?"":c||"number"!==typeof b||0===b||pb.hasOwnProperty(a)&&pb[a]?(""+b).trim():b+"px"}
    	function sb(a,b){a=a.style;for(var c in b)if(b.hasOwnProperty(c)){var d=0===c.indexOf("--"),e=rb(c,b[c],d);"float"===c&&(c="cssFloat");d?a.setProperty(c,e):a[c]=e;}}var tb=A({menuitem:true},{area:true,base:true,br:true,col:true,embed:true,hr:true,img:true,input:true,keygen:true,link:true,meta:true,param:true,source:true,track:true,wbr:true});
    	function ub(a,b){if(b){if(tb[a]&&(null!=b.children||null!=b.dangerouslySetInnerHTML))throw Error(p(137,a));if(null!=b.dangerouslySetInnerHTML){if(null!=b.children)throw Error(p(60));if("object"!==typeof b.dangerouslySetInnerHTML||!("__html"in b.dangerouslySetInnerHTML))throw Error(p(61));}if(null!=b.style&&"object"!==typeof b.style)throw Error(p(62));}}
    	function vb(a,b){if(-1===a.indexOf("-"))return "string"===typeof b.is;switch(a){case "annotation-xml":case "color-profile":case "font-face":case "font-face-src":case "font-face-uri":case "font-face-format":case "font-face-name":case "missing-glyph":return  false;default:return  true}}var wb=null;function xb(a){a=a.target||a.srcElement||window;a.correspondingUseElement&&(a=a.correspondingUseElement);return 3===a.nodeType?a.parentNode:a}var yb=null,zb=null,Ab=null;
    	function Bb(a){if(a=Cb(a)){if("function"!==typeof yb)throw Error(p(280));var b=a.stateNode;b&&(b=Db(b),yb(a.stateNode,a.type,b));}}function Eb(a){zb?Ab?Ab.push(a):Ab=[a]:zb=a;}function Fb(){if(zb){var a=zb,b=Ab;Ab=zb=null;Bb(a);if(b)for(a=0;a<b.length;a++)Bb(b[a]);}}function Gb(a,b){return a(b)}function Hb(){}var Ib=false;function Jb(a,b,c){if(Ib)return a(b,c);Ib=true;try{return Gb(a,b,c)}finally{if(Ib=false,null!==zb||null!==Ab)Hb(),Fb();}}
    	function Kb(a,b){var c=a.stateNode;if(null===c)return null;var d=Db(c);if(null===d)return null;c=d[b];a:switch(b){case "onClick":case "onClickCapture":case "onDoubleClick":case "onDoubleClickCapture":case "onMouseDown":case "onMouseDownCapture":case "onMouseMove":case "onMouseMoveCapture":case "onMouseUp":case "onMouseUpCapture":case "onMouseEnter":(d=!d.disabled)||(a=a.type,d=!("button"===a||"input"===a||"select"===a||"textarea"===a));a=!d;break a;default:a=false;}if(a)return null;if(c&&"function"!==
    	typeof c)throw Error(p(231,b,typeof c));return c}var Lb=false;if(ia)try{var Mb={};Object.defineProperty(Mb,"passive",{get:function(){Lb=!0;}});window.addEventListener("test",Mb,Mb);window.removeEventListener("test",Mb,Mb);}catch(a){Lb=false;}function Nb(a,b,c,d,e,f,g,h,k){var l=Array.prototype.slice.call(arguments,3);try{b.apply(c,l);}catch(m){this.onError(m);}}var Ob=false,Pb=null,Qb=false,Rb=null,Sb={onError:function(a){Ob=true;Pb=a;}};function Tb(a,b,c,d,e,f,g,h,k){Ob=false;Pb=null;Nb.apply(Sb,arguments);}
    	function Ub(a,b,c,d,e,f,g,h,k){Tb.apply(this,arguments);if(Ob){if(Ob){var l=Pb;Ob=false;Pb=null;}else throw Error(p(198));Qb||(Qb=true,Rb=l);}}function Vb(a){var b=a,c=a;if(a.alternate)for(;b.return;)b=b.return;else {a=b;do b=a,0!==(b.flags&4098)&&(c=b.return),a=b.return;while(a)}return 3===b.tag?c:null}function Wb(a){if(13===a.tag){var b=a.memoizedState;null===b&&(a=a.alternate,null!==a&&(b=a.memoizedState));if(null!==b)return b.dehydrated}return null}function Xb(a){if(Vb(a)!==a)throw Error(p(188));}
    	function Yb(a){var b=a.alternate;if(!b){b=Vb(a);if(null===b)throw Error(p(188));return b!==a?null:a}for(var c=a,d=b;;){var e=c.return;if(null===e)break;var f=e.alternate;if(null===f){d=e.return;if(null!==d){c=d;continue}break}if(e.child===f.child){for(f=e.child;f;){if(f===c)return Xb(e),a;if(f===d)return Xb(e),b;f=f.sibling;}throw Error(p(188));}if(c.return!==d.return)c=e,d=f;else {for(var g=false,h=e.child;h;){if(h===c){g=true;c=e;d=f;break}if(h===d){g=true;d=e;c=f;break}h=h.sibling;}if(!g){for(h=f.child;h;){if(h===
    	c){g=true;c=f;d=e;break}if(h===d){g=true;d=f;c=e;break}h=h.sibling;}if(!g)throw Error(p(189));}}if(c.alternate!==d)throw Error(p(190));}if(3!==c.tag)throw Error(p(188));return c.stateNode.current===c?a:b}function Zb(a){a=Yb(a);return null!==a?$b(a):null}function $b(a){if(5===a.tag||6===a.tag)return a;for(a=a.child;null!==a;){var b=$b(a);if(null!==b)return b;a=a.sibling;}return null}
    	var ac=ca.unstable_scheduleCallback,bc=ca.unstable_cancelCallback,cc=ca.unstable_shouldYield,dc=ca.unstable_requestPaint,B=ca.unstable_now,ec=ca.unstable_getCurrentPriorityLevel,fc=ca.unstable_ImmediatePriority,gc=ca.unstable_UserBlockingPriority,hc=ca.unstable_NormalPriority,ic=ca.unstable_LowPriority,jc=ca.unstable_IdlePriority,kc=null,lc=null;function mc(a){if(lc&&"function"===typeof lc.onCommitFiberRoot)try{lc.onCommitFiberRoot(kc,a,void 0,128===(a.current.flags&128));}catch(b){}}
    	var oc=Math.clz32?Math.clz32:nc,pc=Math.log,qc=Math.LN2;function nc(a){a>>>=0;return 0===a?32:31-(pc(a)/qc|0)|0}var rc=64,sc=4194304;
    	function tc(a){switch(a&-a){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return a&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return a&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;
    	default:return a}}function uc(a,b){var c=a.pendingLanes;if(0===c)return 0;var d=0,e=a.suspendedLanes,f=a.pingedLanes,g=c&268435455;if(0!==g){var h=g&~e;0!==h?d=tc(h):(f&=g,0!==f&&(d=tc(f)));}else g=c&~e,0!==g?d=tc(g):0!==f&&(d=tc(f));if(0===d)return 0;if(0!==b&&b!==d&&0===(b&e)&&(e=d&-d,f=b&-b,e>=f||16===e&&0!==(f&4194240)))return b;0!==(d&4)&&(d|=c&16);b=a.entangledLanes;if(0!==b)for(a=a.entanglements,b&=d;0<b;)c=31-oc(b),e=1<<c,d|=a[c],b&=~e;return d}
    	function vc(a,b){switch(a){case 1:case 2:case 4:return b+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return b+5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return  -1;case 134217728:case 268435456:case 536870912:case 1073741824:return  -1;default:return  -1}}
    	function wc(a,b){for(var c=a.suspendedLanes,d=a.pingedLanes,e=a.expirationTimes,f=a.pendingLanes;0<f;){var g=31-oc(f),h=1<<g,k=e[g];if(-1===k){if(0===(h&c)||0!==(h&d))e[g]=vc(h,b);}else k<=b&&(a.expiredLanes|=h);f&=~h;}}function xc(a){a=a.pendingLanes&-1073741825;return 0!==a?a:a&1073741824?1073741824:0}function yc(){var a=rc;rc<<=1;0===(rc&4194240)&&(rc=64);return a}function zc(a){for(var b=[],c=0;31>c;c++)b.push(a);return b}
    	function Ac(a,b,c){a.pendingLanes|=b;536870912!==b&&(a.suspendedLanes=0,a.pingedLanes=0);a=a.eventTimes;b=31-oc(b);a[b]=c;}function Bc(a,b){var c=a.pendingLanes&~b;a.pendingLanes=b;a.suspendedLanes=0;a.pingedLanes=0;a.expiredLanes&=b;a.mutableReadLanes&=b;a.entangledLanes&=b;b=a.entanglements;var d=a.eventTimes;for(a=a.expirationTimes;0<c;){var e=31-oc(c),f=1<<e;b[e]=0;d[e]=-1;a[e]=-1;c&=~f;}}
    	function Cc(a,b){var c=a.entangledLanes|=b;for(a=a.entanglements;c;){var d=31-oc(c),e=1<<d;e&b|a[d]&b&&(a[d]|=b);c&=~e;}}var C=0;function Dc(a){a&=-a;return 1<a?4<a?0!==(a&268435455)?16:536870912:4:1}var Ec,Fc,Gc,Hc,Ic,Jc=false,Kc=[],Lc=null,Mc=null,Nc=null,Oc=new Map,Pc=new Map,Qc=[],Rc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
    	function Sc(a,b){switch(a){case "focusin":case "focusout":Lc=null;break;case "dragenter":case "dragleave":Mc=null;break;case "mouseover":case "mouseout":Nc=null;break;case "pointerover":case "pointerout":Oc.delete(b.pointerId);break;case "gotpointercapture":case "lostpointercapture":Pc.delete(b.pointerId);}}
    	function Tc(a,b,c,d,e,f){if(null===a||a.nativeEvent!==f)return a={blockedOn:b,domEventName:c,eventSystemFlags:d,nativeEvent:f,targetContainers:[e]},null!==b&&(b=Cb(b),null!==b&&Fc(b)),a;a.eventSystemFlags|=d;b=a.targetContainers;null!==e&&-1===b.indexOf(e)&&b.push(e);return a}
    	function Uc(a,b,c,d,e){switch(b){case "focusin":return Lc=Tc(Lc,a,b,c,d,e),true;case "dragenter":return Mc=Tc(Mc,a,b,c,d,e),true;case "mouseover":return Nc=Tc(Nc,a,b,c,d,e),true;case "pointerover":var f=e.pointerId;Oc.set(f,Tc(Oc.get(f)||null,a,b,c,d,e));return  true;case "gotpointercapture":return f=e.pointerId,Pc.set(f,Tc(Pc.get(f)||null,a,b,c,d,e)),true}return  false}
    	function Vc(a){var b=Wc(a.target);if(null!==b){var c=Vb(b);if(null!==c)if(b=c.tag,13===b){if(b=Wb(c),null!==b){a.blockedOn=b;Ic(a.priority,function(){Gc(c);});return}}else if(3===b&&c.stateNode.current.memoizedState.isDehydrated){a.blockedOn=3===c.tag?c.stateNode.containerInfo:null;return}}a.blockedOn=null;}
    	function Xc(a){if(null!==a.blockedOn)return  false;for(var b=a.targetContainers;0<b.length;){var c=Yc(a.domEventName,a.eventSystemFlags,b[0],a.nativeEvent);if(null===c){c=a.nativeEvent;var d=new c.constructor(c.type,c);wb=d;c.target.dispatchEvent(d);wb=null;}else return b=Cb(c),null!==b&&Fc(b),a.blockedOn=c,false;b.shift();}return  true}function Zc(a,b,c){Xc(a)&&c.delete(b);}function $c(){Jc=false;null!==Lc&&Xc(Lc)&&(Lc=null);null!==Mc&&Xc(Mc)&&(Mc=null);null!==Nc&&Xc(Nc)&&(Nc=null);Oc.forEach(Zc);Pc.forEach(Zc);}
    	function ad(a,b){a.blockedOn===b&&(a.blockedOn=null,Jc||(Jc=true,ca.unstable_scheduleCallback(ca.unstable_NormalPriority,$c)));}
    	function bd(a){function b(b){return ad(b,a)}if(0<Kc.length){ad(Kc[0],a);for(var c=1;c<Kc.length;c++){var d=Kc[c];d.blockedOn===a&&(d.blockedOn=null);}}null!==Lc&&ad(Lc,a);null!==Mc&&ad(Mc,a);null!==Nc&&ad(Nc,a);Oc.forEach(b);Pc.forEach(b);for(c=0;c<Qc.length;c++)d=Qc[c],d.blockedOn===a&&(d.blockedOn=null);for(;0<Qc.length&&(c=Qc[0],null===c.blockedOn);)Vc(c),null===c.blockedOn&&Qc.shift();}var cd=ua.ReactCurrentBatchConfig,dd=true;
    	function ed(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=1,fd(a,b,c,d);}finally{C=e,cd.transition=f;}}function gd(a,b,c,d){var e=C,f=cd.transition;cd.transition=null;try{C=4,fd(a,b,c,d);}finally{C=e,cd.transition=f;}}
    	function fd(a,b,c,d){if(dd){var e=Yc(a,b,c,d);if(null===e)hd(a,b,d,id,c),Sc(a,d);else if(Uc(e,a,b,c,d))d.stopPropagation();else if(Sc(a,d),b&4&&-1<Rc.indexOf(a)){for(;null!==e;){var f=Cb(e);null!==f&&Ec(f);f=Yc(a,b,c,d);null===f&&hd(a,b,d,id,c);if(f===e)break;e=f;}null!==e&&d.stopPropagation();}else hd(a,b,d,null,c);}}var id=null;
    	function Yc(a,b,c,d){id=null;a=xb(d);a=Wc(a);if(null!==a)if(b=Vb(a),null===b)a=null;else if(c=b.tag,13===c){a=Wb(b);if(null!==a)return a;a=null;}else if(3===c){if(b.stateNode.current.memoizedState.isDehydrated)return 3===b.tag?b.stateNode.containerInfo:null;a=null;}else b!==a&&(a=null);id=a;return null}
    	function jd(a){switch(a){case "cancel":case "click":case "close":case "contextmenu":case "copy":case "cut":case "auxclick":case "dblclick":case "dragend":case "dragstart":case "drop":case "focusin":case "focusout":case "input":case "invalid":case "keydown":case "keypress":case "keyup":case "mousedown":case "mouseup":case "paste":case "pause":case "play":case "pointercancel":case "pointerdown":case "pointerup":case "ratechange":case "reset":case "resize":case "seeked":case "submit":case "touchcancel":case "touchend":case "touchstart":case "volumechange":case "change":case "selectionchange":case "textInput":case "compositionstart":case "compositionend":case "compositionupdate":case "beforeblur":case "afterblur":case "beforeinput":case "blur":case "fullscreenchange":case "focus":case "hashchange":case "popstate":case "select":case "selectstart":return 1;case "drag":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "mousemove":case "mouseout":case "mouseover":case "pointermove":case "pointerout":case "pointerover":case "scroll":case "toggle":case "touchmove":case "wheel":case "mouseenter":case "mouseleave":case "pointerenter":case "pointerleave":return 4;
    	case "message":switch(ec()){case fc:return 1;case gc:return 4;case hc:case ic:return 16;case jc:return 536870912;default:return 16}default:return 16}}var kd=null,ld=null,md=null;function nd(){if(md)return md;var a,b=ld,c=b.length,d,e="value"in kd?kd.value:kd.textContent,f=e.length;for(a=0;a<c&&b[a]===e[a];a++);var g=c-a;for(d=1;d<=g&&b[c-d]===e[f-d];d++);return md=e.slice(a,1<d?1-d:void 0)}
    	function od(a){var b=a.keyCode;"charCode"in a?(a=a.charCode,0===a&&13===b&&(a=13)):a=b;10===a&&(a=13);return 32<=a||13===a?a:0}function pd(){return  true}function qd(){return  false}
    	function rd(a){function b(b,d,e,f,g){this._reactName=b;this._targetInst=e;this.type=d;this.nativeEvent=f;this.target=g;this.currentTarget=null;for(var c in a)a.hasOwnProperty(c)&&(b=a[c],this[c]=b?b(f):f[c]);this.isDefaultPrevented=(null!=f.defaultPrevented?f.defaultPrevented:false===f.returnValue)?pd:qd;this.isPropagationStopped=qd;return this}A(b.prototype,{preventDefault:function(){this.defaultPrevented=true;var a=this.nativeEvent;a&&(a.preventDefault?a.preventDefault():"unknown"!==typeof a.returnValue&&
    	(a.returnValue=false),this.isDefaultPrevented=pd);},stopPropagation:function(){var a=this.nativeEvent;a&&(a.stopPropagation?a.stopPropagation():"unknown"!==typeof a.cancelBubble&&(a.cancelBubble=true),this.isPropagationStopped=pd);},persist:function(){},isPersistent:pd});return b}
    	var sd={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(a){return a.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},td=rd(sd),ud=A({},sd,{view:0,detail:0}),vd=rd(ud),wd,xd,yd,Ad=A({},ud,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:zd,button:0,buttons:0,relatedTarget:function(a){return void 0===a.relatedTarget?a.fromElement===a.srcElement?a.toElement:a.fromElement:a.relatedTarget},movementX:function(a){if("movementX"in
    	a)return a.movementX;a!==yd&&(yd&&"mousemove"===a.type?(wd=a.screenX-yd.screenX,xd=a.screenY-yd.screenY):xd=wd=0,yd=a);return wd},movementY:function(a){return "movementY"in a?a.movementY:xd}}),Bd=rd(Ad),Cd=A({},Ad,{dataTransfer:0}),Dd=rd(Cd),Ed=A({},ud,{relatedTarget:0}),Fd=rd(Ed),Gd=A({},sd,{animationName:0,elapsedTime:0,pseudoElement:0}),Hd=rd(Gd),Id=A({},sd,{clipboardData:function(a){return "clipboardData"in a?a.clipboardData:window.clipboardData}}),Jd=rd(Id),Kd=A({},sd,{data:0}),Ld=rd(Kd),Md={Esc:"Escape",
    	Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},Nd={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",
    	119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Od={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Pd(a){var b=this.nativeEvent;return b.getModifierState?b.getModifierState(a):(a=Od[a])?!!b[a]:false}function zd(){return Pd}
    	var Qd=A({},ud,{key:function(a){if(a.key){var b=Md[a.key]||a.key;if("Unidentified"!==b)return b}return "keypress"===a.type?(a=od(a),13===a?"Enter":String.fromCharCode(a)):"keydown"===a.type||"keyup"===a.type?Nd[a.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:zd,charCode:function(a){return "keypress"===a.type?od(a):0},keyCode:function(a){return "keydown"===a.type||"keyup"===a.type?a.keyCode:0},which:function(a){return "keypress"===
    	a.type?od(a):"keydown"===a.type||"keyup"===a.type?a.keyCode:0}}),Rd=rd(Qd),Sd=A({},Ad,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Td=rd(Sd),Ud=A({},ud,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:zd}),Vd=rd(Ud),Wd=A({},sd,{propertyName:0,elapsedTime:0,pseudoElement:0}),Xd=rd(Wd),Yd=A({},Ad,{deltaX:function(a){return "deltaX"in a?a.deltaX:"wheelDeltaX"in a?-a.wheelDeltaX:0},
    	deltaY:function(a){return "deltaY"in a?a.deltaY:"wheelDeltaY"in a?-a.wheelDeltaY:"wheelDelta"in a?-a.wheelDelta:0},deltaZ:0,deltaMode:0}),Zd=rd(Yd),$d=[9,13,27,32],ae=ia&&"CompositionEvent"in window,be=null;ia&&"documentMode"in document&&(be=document.documentMode);var ce=ia&&"TextEvent"in window&&!be,de=ia&&(!ae||be&&8<be&&11>=be),ee=String.fromCharCode(32),fe=false;
    	function ge(a,b){switch(a){case "keyup":return  -1!==$d.indexOf(b.keyCode);case "keydown":return 229!==b.keyCode;case "keypress":case "mousedown":case "focusout":return  true;default:return  false}}function he(a){a=a.detail;return "object"===typeof a&&"data"in a?a.data:null}var ie=false;function je(a,b){switch(a){case "compositionend":return he(b);case "keypress":if(32!==b.which)return null;fe=true;return ee;case "textInput":return a=b.data,a===ee&&fe?null:a;default:return null}}
    	function ke(a,b){if(ie)return "compositionend"===a||!ae&&ge(a,b)?(a=nd(),md=ld=kd=null,ie=false,a):null;switch(a){case "paste":return null;case "keypress":if(!(b.ctrlKey||b.altKey||b.metaKey)||b.ctrlKey&&b.altKey){if(b.char&&1<b.char.length)return b.char;if(b.which)return String.fromCharCode(b.which)}return null;case "compositionend":return de&&"ko"!==b.locale?null:b.data;default:return null}}
    	var le={color:true,date:true,datetime:true,"datetime-local":true,email:true,month:true,number:true,password:true,range:true,search:true,tel:true,text:true,time:true,url:true,week:true};function me(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return "input"===b?!!le[a.type]:"textarea"===b?true:false}function ne(a,b,c,d){Eb(d);b=oe(b,"onChange");0<b.length&&(c=new td("onChange","change",null,c,d),a.push({event:c,listeners:b}));}var pe=null,qe=null;function re(a){se(a,0);}function te(a){var b=ue(a);if(Wa(b))return a}
    	function ve(a,b){if("change"===a)return b}var we=false;if(ia){var xe;if(ia){var ye="oninput"in document;if(!ye){var ze=document.createElement("div");ze.setAttribute("oninput","return;");ye="function"===typeof ze.oninput;}xe=ye;}else xe=false;we=xe&&(!document.documentMode||9<document.documentMode);}function Ae(){pe&&(pe.detachEvent("onpropertychange",Be),qe=pe=null);}function Be(a){if("value"===a.propertyName&&te(qe)){var b=[];ne(b,qe,a,xb(a));Jb(re,b);}}
    	function Ce(a,b,c){"focusin"===a?(Ae(),pe=b,qe=c,pe.attachEvent("onpropertychange",Be)):"focusout"===a&&Ae();}function De(a){if("selectionchange"===a||"keyup"===a||"keydown"===a)return te(qe)}function Ee(a,b){if("click"===a)return te(b)}function Fe(a,b){if("input"===a||"change"===a)return te(b)}function Ge(a,b){return a===b&&(0!==a||1/a===1/b)||a!==a&&b!==b}var He="function"===typeof Object.is?Object.is:Ge;
    	function Ie(a,b){if(He(a,b))return  true;if("object"!==typeof a||null===a||"object"!==typeof b||null===b)return  false;var c=Object.keys(a),d=Object.keys(b);if(c.length!==d.length)return  false;for(d=0;d<c.length;d++){var e=c[d];if(!ja.call(b,e)||!He(a[e],b[e]))return  false}return  true}function Je(a){for(;a&&a.firstChild;)a=a.firstChild;return a}
    	function Ke(a,b){var c=Je(a);a=0;for(var d;c;){if(3===c.nodeType){d=a+c.textContent.length;if(a<=b&&d>=b)return {node:c,offset:b-a};a=d;}a:{for(;c;){if(c.nextSibling){c=c.nextSibling;break a}c=c.parentNode;}c=void 0;}c=Je(c);}}function Le(a,b){return a&&b?a===b?true:a&&3===a.nodeType?false:b&&3===b.nodeType?Le(a,b.parentNode):"contains"in a?a.contains(b):a.compareDocumentPosition?!!(a.compareDocumentPosition(b)&16):false:false}
    	function Me(){for(var a=window,b=Xa();b instanceof a.HTMLIFrameElement;){try{var c="string"===typeof b.contentWindow.location.href;}catch(d){c=false;}if(c)a=b.contentWindow;else break;b=Xa(a.document);}return b}function Ne(a){var b=a&&a.nodeName&&a.nodeName.toLowerCase();return b&&("input"===b&&("text"===a.type||"search"===a.type||"tel"===a.type||"url"===a.type||"password"===a.type)||"textarea"===b||"true"===a.contentEditable)}
    	function Oe(a){var b=Me(),c=a.focusedElem,d=a.selectionRange;if(b!==c&&c&&c.ownerDocument&&Le(c.ownerDocument.documentElement,c)){if(null!==d&&Ne(c))if(b=d.start,a=d.end,void 0===a&&(a=b),"selectionStart"in c)c.selectionStart=b,c.selectionEnd=Math.min(a,c.value.length);else if(a=(b=c.ownerDocument||document)&&b.defaultView||window,a.getSelection){a=a.getSelection();var e=c.textContent.length,f=Math.min(d.start,e);d=void 0===d.end?f:Math.min(d.end,e);!a.extend&&f>d&&(e=d,d=f,f=e);e=Ke(c,f);var g=Ke(c,
    	d);e&&g&&(1!==a.rangeCount||a.anchorNode!==e.node||a.anchorOffset!==e.offset||a.focusNode!==g.node||a.focusOffset!==g.offset)&&(b=b.createRange(),b.setStart(e.node,e.offset),a.removeAllRanges(),f>d?(a.addRange(b),a.extend(g.node,g.offset)):(b.setEnd(g.node,g.offset),a.addRange(b)));}b=[];for(a=c;a=a.parentNode;)1===a.nodeType&&b.push({element:a,left:a.scrollLeft,top:a.scrollTop});"function"===typeof c.focus&&c.focus();for(c=0;c<b.length;c++)a=b[c],a.element.scrollLeft=a.left,a.element.scrollTop=a.top;}}
    	var Pe=ia&&"documentMode"in document&&11>=document.documentMode,Qe=null,Re=null,Se=null,Te=false;
    	function Ue(a,b,c){var d=c.window===c?c.document:9===c.nodeType?c:c.ownerDocument;Te||null==Qe||Qe!==Xa(d)||(d=Qe,"selectionStart"in d&&Ne(d)?d={start:d.selectionStart,end:d.selectionEnd}:(d=(d.ownerDocument&&d.ownerDocument.defaultView||window).getSelection(),d={anchorNode:d.anchorNode,anchorOffset:d.anchorOffset,focusNode:d.focusNode,focusOffset:d.focusOffset}),Se&&Ie(Se,d)||(Se=d,d=oe(Re,"onSelect"),0<d.length&&(b=new td("onSelect","select",null,b,c),a.push({event:b,listeners:d}),b.target=Qe)));}
    	function Ve(a,b){var c={};c[a.toLowerCase()]=b.toLowerCase();c["Webkit"+a]="webkit"+b;c["Moz"+a]="moz"+b;return c}var We={animationend:Ve("Animation","AnimationEnd"),animationiteration:Ve("Animation","AnimationIteration"),animationstart:Ve("Animation","AnimationStart"),transitionend:Ve("Transition","TransitionEnd")},Xe={},Ye={};
    	ia&&(Ye=document.createElement("div").style,"AnimationEvent"in window||(delete We.animationend.animation,delete We.animationiteration.animation,delete We.animationstart.animation),"TransitionEvent"in window||delete We.transitionend.transition);function Ze(a){if(Xe[a])return Xe[a];if(!We[a])return a;var b=We[a],c;for(c in b)if(b.hasOwnProperty(c)&&c in Ye)return Xe[a]=b[c];return a}var $e=Ze("animationend"),af=Ze("animationiteration"),bf=Ze("animationstart"),cf=Ze("transitionend"),df=new Map,ef="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
    	function ff(a,b){df.set(a,b);fa(b,[a]);}for(var gf=0;gf<ef.length;gf++){var hf=ef[gf],jf=hf.toLowerCase(),kf=hf[0].toUpperCase()+hf.slice(1);ff(jf,"on"+kf);}ff($e,"onAnimationEnd");ff(af,"onAnimationIteration");ff(bf,"onAnimationStart");ff("dblclick","onDoubleClick");ff("focusin","onFocus");ff("focusout","onBlur");ff(cf,"onTransitionEnd");ha("onMouseEnter",["mouseout","mouseover"]);ha("onMouseLeave",["mouseout","mouseover"]);ha("onPointerEnter",["pointerout","pointerover"]);
    	ha("onPointerLeave",["pointerout","pointerover"]);fa("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));fa("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));fa("onBeforeInput",["compositionend","keypress","textInput","paste"]);fa("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));fa("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));
    	fa("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var lf="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),mf=new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
    	function nf(a,b,c){var d=a.type||"unknown-event";a.currentTarget=c;Ub(d,b,void 0,a);a.currentTarget=null;}
    	function se(a,b){b=0!==(b&4);for(var c=0;c<a.length;c++){var d=a[c],e=d.event;d=d.listeners;a:{var f=void 0;if(b)for(var g=d.length-1;0<=g;g--){var h=d[g],k=h.instance,l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k;}else for(g=0;g<d.length;g++){h=d[g];k=h.instance;l=h.currentTarget;h=h.listener;if(k!==f&&e.isPropagationStopped())break a;nf(e,h,l);f=k;}}}if(Qb)throw a=Rb,Qb=false,Rb=null,a;}
    	function D(a,b){var c=b[of];void 0===c&&(c=b[of]=new Set);var d=a+"__bubble";c.has(d)||(pf(b,a,2,false),c.add(d));}function qf(a,b,c){var d=0;b&&(d|=4);pf(c,a,d,b);}var rf="_reactListening"+Math.random().toString(36).slice(2);function sf(a){if(!a[rf]){a[rf]=true;da.forEach(function(b){"selectionchange"!==b&&(mf.has(b)||qf(b,false,a),qf(b,true,a));});var b=9===a.nodeType?a:a.ownerDocument;null===b||b[rf]||(b[rf]=true,qf("selectionchange",false,b));}}
    	function pf(a,b,c,d){switch(jd(b)){case 1:var e=ed;break;case 4:e=gd;break;default:e=fd;}c=e.bind(null,b,c,a);e=void 0;!Lb||"touchstart"!==b&&"touchmove"!==b&&"wheel"!==b||(e=true);d?void 0!==e?a.addEventListener(b,c,{capture:true,passive:e}):a.addEventListener(b,c,true):void 0!==e?a.addEventListener(b,c,{passive:e}):a.addEventListener(b,c,false);}
    	function hd(a,b,c,d,e){var f=d;if(0===(b&1)&&0===(b&2)&&null!==d)a:for(;;){if(null===d)return;var g=d.tag;if(3===g||4===g){var h=d.stateNode.containerInfo;if(h===e||8===h.nodeType&&h.parentNode===e)break;if(4===g)for(g=d.return;null!==g;){var k=g.tag;if(3===k||4===k)if(k=g.stateNode.containerInfo,k===e||8===k.nodeType&&k.parentNode===e)return;g=g.return;}for(;null!==h;){g=Wc(h);if(null===g)return;k=g.tag;if(5===k||6===k){d=f=g;continue a}h=h.parentNode;}}d=d.return;}Jb(function(){var d=f,e=xb(c),g=[];
    	a:{var h=df.get(a);if(void 0!==h){var k=td,n=a;switch(a){case "keypress":if(0===od(c))break a;case "keydown":case "keyup":k=Rd;break;case "focusin":n="focus";k=Fd;break;case "focusout":n="blur";k=Fd;break;case "beforeblur":case "afterblur":k=Fd;break;case "click":if(2===c.button)break a;case "auxclick":case "dblclick":case "mousedown":case "mousemove":case "mouseup":case "mouseout":case "mouseover":case "contextmenu":k=Bd;break;case "drag":case "dragend":case "dragenter":case "dragexit":case "dragleave":case "dragover":case "dragstart":case "drop":k=
    	Dd;break;case "touchcancel":case "touchend":case "touchmove":case "touchstart":k=Vd;break;case $e:case af:case bf:k=Hd;break;case cf:k=Xd;break;case "scroll":k=vd;break;case "wheel":k=Zd;break;case "copy":case "cut":case "paste":k=Jd;break;case "gotpointercapture":case "lostpointercapture":case "pointercancel":case "pointerdown":case "pointermove":case "pointerout":case "pointerover":case "pointerup":k=Td;}var t=0!==(b&4),J=!t&&"scroll"===a,x=t?null!==h?h+"Capture":null:h;t=[];for(var w=d,u;null!==
    	w;){u=w;var F=u.stateNode;5===u.tag&&null!==F&&(u=F,null!==x&&(F=Kb(w,x),null!=F&&t.push(tf(w,F,u))));if(J)break;w=w.return;}0<t.length&&(h=new k(h,n,null,c,e),g.push({event:h,listeners:t}));}}if(0===(b&7)){a:{h="mouseover"===a||"pointerover"===a;k="mouseout"===a||"pointerout"===a;if(h&&c!==wb&&(n=c.relatedTarget||c.fromElement)&&(Wc(n)||n[uf]))break a;if(k||h){h=e.window===e?e:(h=e.ownerDocument)?h.defaultView||h.parentWindow:window;if(k){if(n=c.relatedTarget||c.toElement,k=d,n=n?Wc(n):null,null!==
    	n&&(J=Vb(n),n!==J||5!==n.tag&&6!==n.tag))n=null;}else k=null,n=d;if(k!==n){t=Bd;F="onMouseLeave";x="onMouseEnter";w="mouse";if("pointerout"===a||"pointerover"===a)t=Td,F="onPointerLeave",x="onPointerEnter",w="pointer";J=null==k?h:ue(k);u=null==n?h:ue(n);h=new t(F,w+"leave",k,c,e);h.target=J;h.relatedTarget=u;F=null;Wc(e)===d&&(t=new t(x,w+"enter",n,c,e),t.target=u,t.relatedTarget=J,F=t);J=F;if(k&&n)b:{t=k;x=n;w=0;for(u=t;u;u=vf(u))w++;u=0;for(F=x;F;F=vf(F))u++;for(;0<w-u;)t=vf(t),w--;for(;0<u-w;)x=
    	vf(x),u--;for(;w--;){if(t===x||null!==x&&t===x.alternate)break b;t=vf(t);x=vf(x);}t=null;}else t=null;null!==k&&wf(g,h,k,t,false);null!==n&&null!==J&&wf(g,J,n,t,true);}}}a:{h=d?ue(d):window;k=h.nodeName&&h.nodeName.toLowerCase();if("select"===k||"input"===k&&"file"===h.type)var na=ve;else if(me(h))if(we)na=Fe;else {na=De;var xa=Ce;}else (k=h.nodeName)&&"input"===k.toLowerCase()&&("checkbox"===h.type||"radio"===h.type)&&(na=Ee);if(na&&(na=na(a,d))){ne(g,na,c,e);break a}xa&&xa(a,h,d);"focusout"===a&&(xa=h._wrapperState)&&
    	xa.controlled&&"number"===h.type&&cb(h,"number",h.value);}xa=d?ue(d):window;switch(a){case "focusin":if(me(xa)||"true"===xa.contentEditable)Qe=xa,Re=d,Se=null;break;case "focusout":Se=Re=Qe=null;break;case "mousedown":Te=true;break;case "contextmenu":case "mouseup":case "dragend":Te=false;Ue(g,c,e);break;case "selectionchange":if(Pe)break;case "keydown":case "keyup":Ue(g,c,e);}var $a;if(ae)b:{switch(a){case "compositionstart":var ba="onCompositionStart";break b;case "compositionend":ba="onCompositionEnd";
    	break b;case "compositionupdate":ba="onCompositionUpdate";break b}ba=void 0;}else ie?ge(a,c)&&(ba="onCompositionEnd"):"keydown"===a&&229===c.keyCode&&(ba="onCompositionStart");ba&&(de&&"ko"!==c.locale&&(ie||"onCompositionStart"!==ba?"onCompositionEnd"===ba&&ie&&($a=nd()):(kd=e,ld="value"in kd?kd.value:kd.textContent,ie=true)),xa=oe(d,ba),0<xa.length&&(ba=new Ld(ba,a,null,c,e),g.push({event:ba,listeners:xa}),$a?ba.data=$a:($a=he(c),null!==$a&&(ba.data=$a))));if($a=ce?je(a,c):ke(a,c))d=oe(d,"onBeforeInput"),
    	0<d.length&&(e=new Ld("onBeforeInput","beforeinput",null,c,e),g.push({event:e,listeners:d}),e.data=$a);}se(g,b);});}function tf(a,b,c){return {instance:a,listener:b,currentTarget:c}}function oe(a,b){for(var c=b+"Capture",d=[];null!==a;){var e=a,f=e.stateNode;5===e.tag&&null!==f&&(e=f,f=Kb(a,c),null!=f&&d.unshift(tf(a,f,e)),f=Kb(a,b),null!=f&&d.push(tf(a,f,e)));a=a.return;}return d}function vf(a){if(null===a)return null;do a=a.return;while(a&&5!==a.tag);return a?a:null}
    	function wf(a,b,c,d,e){for(var f=b._reactName,g=[];null!==c&&c!==d;){var h=c,k=h.alternate,l=h.stateNode;if(null!==k&&k===d)break;5===h.tag&&null!==l&&(h=l,e?(k=Kb(c,f),null!=k&&g.unshift(tf(c,k,h))):e||(k=Kb(c,f),null!=k&&g.push(tf(c,k,h))));c=c.return;}0!==g.length&&a.push({event:b,listeners:g});}var xf=/\r\n?/g,yf=/\u0000|\uFFFD/g;function zf(a){return ("string"===typeof a?a:""+a).replace(xf,"\n").replace(yf,"")}function Af(a,b,c){b=zf(b);if(zf(a)!==b&&c)throw Error(p(425));}function Bf(){}
    	var Cf=null,Df=null;function Ef(a,b){return "textarea"===a||"noscript"===a||"string"===typeof b.children||"number"===typeof b.children||"object"===typeof b.dangerouslySetInnerHTML&&null!==b.dangerouslySetInnerHTML&&null!=b.dangerouslySetInnerHTML.__html}
    	var Ff="function"===typeof setTimeout?setTimeout:void 0,Gf="function"===typeof clearTimeout?clearTimeout:void 0,Hf="function"===typeof Promise?Promise:void 0,Jf="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof Hf?function(a){return Hf.resolve(null).then(a).catch(If)}:Ff;function If(a){setTimeout(function(){throw a;});}
    	function Kf(a,b){var c=b,d=0;do{var e=c.nextSibling;a.removeChild(c);if(e&&8===e.nodeType)if(c=e.data,"/$"===c){if(0===d){a.removeChild(e);bd(b);return}d--;}else "$"!==c&&"$?"!==c&&"$!"!==c||d++;c=e;}while(c);bd(b);}function Lf(a){for(;null!=a;a=a.nextSibling){var b=a.nodeType;if(1===b||3===b)break;if(8===b){b=a.data;if("$"===b||"$!"===b||"$?"===b)break;if("/$"===b)return null}}return a}
    	function Mf(a){a=a.previousSibling;for(var b=0;a;){if(8===a.nodeType){var c=a.data;if("$"===c||"$!"===c||"$?"===c){if(0===b)return a;b--;}else "/$"===c&&b++;}a=a.previousSibling;}return null}var Nf=Math.random().toString(36).slice(2),Of="__reactFiber$"+Nf,Pf="__reactProps$"+Nf,uf="__reactContainer$"+Nf,of="__reactEvents$"+Nf,Qf="__reactListeners$"+Nf,Rf="__reactHandles$"+Nf;
    	function Wc(a){var b=a[Of];if(b)return b;for(var c=a.parentNode;c;){if(b=c[uf]||c[Of]){c=b.alternate;if(null!==b.child||null!==c&&null!==c.child)for(a=Mf(a);null!==a;){if(c=a[Of])return c;a=Mf(a);}return b}a=c;c=a.parentNode;}return null}function Cb(a){a=a[Of]||a[uf];return !a||5!==a.tag&&6!==a.tag&&13!==a.tag&&3!==a.tag?null:a}function ue(a){if(5===a.tag||6===a.tag)return a.stateNode;throw Error(p(33));}function Db(a){return a[Pf]||null}var Sf=[],Tf=-1;function Uf(a){return {current:a}}
    	function E(a){0>Tf||(a.current=Sf[Tf],Sf[Tf]=null,Tf--);}function G(a,b){Tf++;Sf[Tf]=a.current;a.current=b;}var Vf={},H=Uf(Vf),Wf=Uf(false),Xf=Vf;function Yf(a,b){var c=a.type.contextTypes;if(!c)return Vf;var d=a.stateNode;if(d&&d.__reactInternalMemoizedUnmaskedChildContext===b)return d.__reactInternalMemoizedMaskedChildContext;var e={},f;for(f in c)e[f]=b[f];d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=b,a.__reactInternalMemoizedMaskedChildContext=e);return e}
    	function Zf(a){a=a.childContextTypes;return null!==a&&void 0!==a}function $f(){E(Wf);E(H);}function ag(a,b,c){if(H.current!==Vf)throw Error(p(168));G(H,b);G(Wf,c);}function bg(a,b,c){var d=a.stateNode;b=b.childContextTypes;if("function"!==typeof d.getChildContext)return c;d=d.getChildContext();for(var e in d)if(!(e in b))throw Error(p(108,Ra(a)||"Unknown",e));return A({},c,d)}
    	function cg(a){a=(a=a.stateNode)&&a.__reactInternalMemoizedMergedChildContext||Vf;Xf=H.current;G(H,a);G(Wf,Wf.current);return  true}function dg(a,b,c){var d=a.stateNode;if(!d)throw Error(p(169));c?(a=bg(a,b,Xf),d.__reactInternalMemoizedMergedChildContext=a,E(Wf),E(H),G(H,a)):E(Wf);G(Wf,c);}var eg=null,fg=false,gg=false;function hg(a){null===eg?eg=[a]:eg.push(a);}function ig(a){fg=true;hg(a);}
    	function jg(){if(!gg&&null!==eg){gg=true;var a=0,b=C;try{var c=eg;for(C=1;a<c.length;a++){var d=c[a];do d=d(!0);while(null!==d)}eg=null;fg=!1;}catch(e){throw null!==eg&&(eg=eg.slice(a+1)),ac(fc,jg),e;}finally{C=b,gg=false;}}return null}var kg=[],lg=0,mg=null,ng=0,og=[],pg=0,qg=null,rg=1,sg="";function tg(a,b){kg[lg++]=ng;kg[lg++]=mg;mg=a;ng=b;}
    	function ug(a,b,c){og[pg++]=rg;og[pg++]=sg;og[pg++]=qg;qg=a;var d=rg;a=sg;var e=32-oc(d)-1;d&=~(1<<e);c+=1;var f=32-oc(b)+e;if(30<f){var g=e-e%5;f=(d&(1<<g)-1).toString(32);d>>=g;e-=g;rg=1<<32-oc(b)+e|c<<e|d;sg=f+a;}else rg=1<<f|c<<e|d,sg=a;}function vg(a){null!==a.return&&(tg(a,1),ug(a,1,0));}function wg(a){for(;a===mg;)mg=kg[--lg],kg[lg]=null,ng=kg[--lg],kg[lg]=null;for(;a===qg;)qg=og[--pg],og[pg]=null,sg=og[--pg],og[pg]=null,rg=og[--pg],og[pg]=null;}var xg=null,yg=null,I=false,zg=null;
    	function Ag(a,b){var c=Bg(5,null,null,0);c.elementType="DELETED";c.stateNode=b;c.return=a;b=a.deletions;null===b?(a.deletions=[c],a.flags|=16):b.push(c);}
    	function Cg(a,b){switch(a.tag){case 5:var c=a.type;b=1!==b.nodeType||c.toLowerCase()!==b.nodeName.toLowerCase()?null:b;return null!==b?(a.stateNode=b,xg=a,yg=Lf(b.firstChild),true):false;case 6:return b=""===a.pendingProps||3!==b.nodeType?null:b,null!==b?(a.stateNode=b,xg=a,yg=null,true):false;case 13:return b=8!==b.nodeType?null:b,null!==b?(c=null!==qg?{id:rg,overflow:sg}:null,a.memoizedState={dehydrated:b,treeContext:c,retryLane:1073741824},c=Bg(18,null,null,0),c.stateNode=b,c.return=a,a.child=c,xg=a,yg=
    	null,true):false;default:return  false}}function Dg(a){return 0!==(a.mode&1)&&0===(a.flags&128)}function Eg(a){if(I){var b=yg;if(b){var c=b;if(!Cg(a,b)){if(Dg(a))throw Error(p(418));b=Lf(c.nextSibling);var d=xg;b&&Cg(a,b)?Ag(d,c):(a.flags=a.flags&-4097|2,I=false,xg=a);}}else {if(Dg(a))throw Error(p(418));a.flags=a.flags&-4097|2;I=false;xg=a;}}}function Fg(a){for(a=a.return;null!==a&&5!==a.tag&&3!==a.tag&&13!==a.tag;)a=a.return;xg=a;}
    	function Gg(a){if(a!==xg)return  false;if(!I)return Fg(a),I=true,false;var b;(b=3!==a.tag)&&!(b=5!==a.tag)&&(b=a.type,b="head"!==b&&"body"!==b&&!Ef(a.type,a.memoizedProps));if(b&&(b=yg)){if(Dg(a))throw Hg(),Error(p(418));for(;b;)Ag(a,b),b=Lf(b.nextSibling);}Fg(a);if(13===a.tag){a=a.memoizedState;a=null!==a?a.dehydrated:null;if(!a)throw Error(p(317));a:{a=a.nextSibling;for(b=0;a;){if(8===a.nodeType){var c=a.data;if("/$"===c){if(0===b){yg=Lf(a.nextSibling);break a}b--;}else "$"!==c&&"$!"!==c&&"$?"!==c||b++;}a=a.nextSibling;}yg=
    	null;}}else yg=xg?Lf(a.stateNode.nextSibling):null;return  true}function Hg(){for(var a=yg;a;)a=Lf(a.nextSibling);}function Ig(){yg=xg=null;I=false;}function Jg(a){null===zg?zg=[a]:zg.push(a);}var Kg=ua.ReactCurrentBatchConfig;
    	function Lg(a,b,c){a=c.ref;if(null!==a&&"function"!==typeof a&&"object"!==typeof a){if(c._owner){c=c._owner;if(c){if(1!==c.tag)throw Error(p(309));var d=c.stateNode;}if(!d)throw Error(p(147,a));var e=d,f=""+a;if(null!==b&&null!==b.ref&&"function"===typeof b.ref&&b.ref._stringRef===f)return b.ref;b=function(a){var b=e.refs;null===a?delete b[f]:b[f]=a;};b._stringRef=f;return b}if("string"!==typeof a)throw Error(p(284));if(!c._owner)throw Error(p(290,a));}return a}
    	function Mg(a,b){a=Object.prototype.toString.call(b);throw Error(p(31,"[object Object]"===a?"object with keys {"+Object.keys(b).join(", ")+"}":a));}function Ng(a){var b=a._init;return b(a._payload)}
    	function Og(a){function b(b,c){if(a){var d=b.deletions;null===d?(b.deletions=[c],b.flags|=16):d.push(c);}}function c(c,d){if(!a)return null;for(;null!==d;)b(c,d),d=d.sibling;return null}function d(a,b){for(a=new Map;null!==b;)null!==b.key?a.set(b.key,b):a.set(b.index,b),b=b.sibling;return a}function e(a,b){a=Pg(a,b);a.index=0;a.sibling=null;return a}function f(b,c,d){b.index=d;if(!a)return b.flags|=1048576,c;d=b.alternate;if(null!==d)return d=d.index,d<c?(b.flags|=2,c):d;b.flags|=2;return c}function g(b){a&&
    	null===b.alternate&&(b.flags|=2);return b}function h(a,b,c,d){if(null===b||6!==b.tag)return b=Qg(c,a.mode,d),b.return=a,b;b=e(b,c);b.return=a;return b}function k(a,b,c,d){var f=c.type;if(f===ya)return m(a,b,c.props.children,d,c.key);if(null!==b&&(b.elementType===f||"object"===typeof f&&null!==f&&f.$$typeof===Ha&&Ng(f)===b.type))return d=e(b,c.props),d.ref=Lg(a,b,c),d.return=a,d;d=Rg(c.type,c.key,c.props,null,a.mode,d);d.ref=Lg(a,b,c);d.return=a;return d}function l(a,b,c,d){if(null===b||4!==b.tag||
    	b.stateNode.containerInfo!==c.containerInfo||b.stateNode.implementation!==c.implementation)return b=Sg(c,a.mode,d),b.return=a,b;b=e(b,c.children||[]);b.return=a;return b}function m(a,b,c,d,f){if(null===b||7!==b.tag)return b=Tg(c,a.mode,d,f),b.return=a,b;b=e(b,c);b.return=a;return b}function q(a,b,c){if("string"===typeof b&&""!==b||"number"===typeof b)return b=Qg(""+b,a.mode,c),b.return=a,b;if("object"===typeof b&&null!==b){switch(b.$$typeof){case va:return c=Rg(b.type,b.key,b.props,null,a.mode,c),
    	c.ref=Lg(a,null,b),c.return=a,c;case wa:return b=Sg(b,a.mode,c),b.return=a,b;case Ha:var d=b._init;return q(a,d(b._payload),c)}if(eb(b)||Ka(b))return b=Tg(b,a.mode,c,null),b.return=a,b;Mg(a,b);}return null}function r(a,b,c,d){var e=null!==b?b.key:null;if("string"===typeof c&&""!==c||"number"===typeof c)return null!==e?null:h(a,b,""+c,d);if("object"===typeof c&&null!==c){switch(c.$$typeof){case va:return c.key===e?k(a,b,c,d):null;case wa:return c.key===e?l(a,b,c,d):null;case Ha:return e=c._init,r(a,
    	b,e(c._payload),d)}if(eb(c)||Ka(c))return null!==e?null:m(a,b,c,d,null);Mg(a,c);}return null}function y(a,b,c,d,e){if("string"===typeof d&&""!==d||"number"===typeof d)return a=a.get(c)||null,h(b,a,""+d,e);if("object"===typeof d&&null!==d){switch(d.$$typeof){case va:return a=a.get(null===d.key?c:d.key)||null,k(b,a,d,e);case wa:return a=a.get(null===d.key?c:d.key)||null,l(b,a,d,e);case Ha:var f=d._init;return y(a,b,c,f(d._payload),e)}if(eb(d)||Ka(d))return a=a.get(c)||null,m(b,a,d,e,null);Mg(b,d);}return null}
    	function n(e,g,h,k){for(var l=null,m=null,u=g,w=g=0,x=null;null!==u&&w<h.length;w++){u.index>w?(x=u,u=null):x=u.sibling;var n=r(e,u,h[w],k);if(null===n){null===u&&(u=x);break}a&&u&&null===n.alternate&&b(e,u);g=f(n,g,w);null===m?l=n:m.sibling=n;m=n;u=x;}if(w===h.length)return c(e,u),I&&tg(e,w),l;if(null===u){for(;w<h.length;w++)u=q(e,h[w],k),null!==u&&(g=f(u,g,w),null===m?l=u:m.sibling=u,m=u);I&&tg(e,w);return l}for(u=d(e,u);w<h.length;w++)x=y(u,e,w,h[w],k),null!==x&&(a&&null!==x.alternate&&u.delete(null===
    	x.key?w:x.key),g=f(x,g,w),null===m?l=x:m.sibling=x,m=x);a&&u.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function t(e,g,h,k){var l=Ka(h);if("function"!==typeof l)throw Error(p(150));h=l.call(h);if(null==h)throw Error(p(151));for(var u=l=null,m=g,w=g=0,x=null,n=h.next();null!==m&&!n.done;w++,n=h.next()){m.index>w?(x=m,m=null):x=m.sibling;var t=r(e,m,n.value,k);if(null===t){null===m&&(m=x);break}a&&m&&null===t.alternate&&b(e,m);g=f(t,g,w);null===u?l=t:u.sibling=t;u=t;m=x;}if(n.done)return c(e,
    	m),I&&tg(e,w),l;if(null===m){for(;!n.done;w++,n=h.next())n=q(e,n.value,k),null!==n&&(g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);I&&tg(e,w);return l}for(m=d(e,m);!n.done;w++,n=h.next())n=y(m,e,w,n.value,k),null!==n&&(a&&null!==n.alternate&&m.delete(null===n.key?w:n.key),g=f(n,g,w),null===u?l=n:u.sibling=n,u=n);a&&m.forEach(function(a){return b(e,a)});I&&tg(e,w);return l}function J(a,d,f,h){"object"===typeof f&&null!==f&&f.type===ya&&null===f.key&&(f=f.props.children);if("object"===typeof f&&null!==f){switch(f.$$typeof){case va:a:{for(var k=
    	f.key,l=d;null!==l;){if(l.key===k){k=f.type;if(k===ya){if(7===l.tag){c(a,l.sibling);d=e(l,f.props.children);d.return=a;a=d;break a}}else if(l.elementType===k||"object"===typeof k&&null!==k&&k.$$typeof===Ha&&Ng(k)===l.type){c(a,l.sibling);d=e(l,f.props);d.ref=Lg(a,l,f);d.return=a;a=d;break a}c(a,l);break}else b(a,l);l=l.sibling;}f.type===ya?(d=Tg(f.props.children,a.mode,h,f.key),d.return=a,a=d):(h=Rg(f.type,f.key,f.props,null,a.mode,h),h.ref=Lg(a,d,f),h.return=a,a=h);}return g(a);case wa:a:{for(l=f.key;null!==
    	d;){if(d.key===l)if(4===d.tag&&d.stateNode.containerInfo===f.containerInfo&&d.stateNode.implementation===f.implementation){c(a,d.sibling);d=e(d,f.children||[]);d.return=a;a=d;break a}else {c(a,d);break}else b(a,d);d=d.sibling;}d=Sg(f,a.mode,h);d.return=a;a=d;}return g(a);case Ha:return l=f._init,J(a,d,l(f._payload),h)}if(eb(f))return n(a,d,f,h);if(Ka(f))return t(a,d,f,h);Mg(a,f);}return "string"===typeof f&&""!==f||"number"===typeof f?(f=""+f,null!==d&&6===d.tag?(c(a,d.sibling),d=e(d,f),d.return=a,a=d):
    	(c(a,d),d=Qg(f,a.mode,h),d.return=a,a=d),g(a)):c(a,d)}return J}var Ug=Og(true),Vg=Og(false),Wg=Uf(null),Xg=null,Yg=null,Zg=null;function $g(){Zg=Yg=Xg=null;}function ah(a){var b=Wg.current;E(Wg);a._currentValue=b;}function bh(a,b,c){for(;null!==a;){var d=a.alternate;(a.childLanes&b)!==b?(a.childLanes|=b,null!==d&&(d.childLanes|=b)):null!==d&&(d.childLanes&b)!==b&&(d.childLanes|=b);if(a===c)break;a=a.return;}}
    	function ch(a,b){Xg=a;Zg=Yg=null;a=a.dependencies;null!==a&&null!==a.firstContext&&(0!==(a.lanes&b)&&(dh=true),a.firstContext=null);}function eh(a){var b=a._currentValue;if(Zg!==a)if(a={context:a,memoizedValue:b,next:null},null===Yg){if(null===Xg)throw Error(p(308));Yg=a;Xg.dependencies={lanes:0,firstContext:a};}else Yg=Yg.next=a;return b}var fh=null;function gh(a){null===fh?fh=[a]:fh.push(a);}
    	function hh(a,b,c,d){var e=b.interleaved;null===e?(c.next=c,gh(b)):(c.next=e.next,e.next=c);b.interleaved=c;return ih(a,d)}function ih(a,b){a.lanes|=b;var c=a.alternate;null!==c&&(c.lanes|=b);c=a;for(a=a.return;null!==a;)a.childLanes|=b,c=a.alternate,null!==c&&(c.childLanes|=b),c=a,a=a.return;return 3===c.tag?c.stateNode:null}var jh=false;function kh(a){a.updateQueue={baseState:a.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null};}
    	function lh(a,b){a=a.updateQueue;b.updateQueue===a&&(b.updateQueue={baseState:a.baseState,firstBaseUpdate:a.firstBaseUpdate,lastBaseUpdate:a.lastBaseUpdate,shared:a.shared,effects:a.effects});}function mh(a,b){return {eventTime:a,lane:b,tag:0,payload:null,callback:null,next:null}}
    	function nh(a,b,c){var d=a.updateQueue;if(null===d)return null;d=d.shared;if(0!==(K&2)){var e=d.pending;null===e?b.next=b:(b.next=e.next,e.next=b);d.pending=b;return ih(a,c)}e=d.interleaved;null===e?(b.next=b,gh(d)):(b.next=e.next,e.next=b);d.interleaved=b;return ih(a,c)}function oh(a,b,c){b=b.updateQueue;if(null!==b&&(b=b.shared,0!==(c&4194240))){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c);}}
    	function ph(a,b){var c=a.updateQueue,d=a.alternate;if(null!==d&&(d=d.updateQueue,c===d)){var e=null,f=null;c=c.firstBaseUpdate;if(null!==c){do{var g={eventTime:c.eventTime,lane:c.lane,tag:c.tag,payload:c.payload,callback:c.callback,next:null};null===f?e=f=g:f=f.next=g;c=c.next;}while(null!==c);null===f?e=f=b:f=f.next=b;}else e=f=b;c={baseState:d.baseState,firstBaseUpdate:e,lastBaseUpdate:f,shared:d.shared,effects:d.effects};a.updateQueue=c;return}a=c.lastBaseUpdate;null===a?c.firstBaseUpdate=b:a.next=
    	b;c.lastBaseUpdate=b;}
    	function qh(a,b,c,d){var e=a.updateQueue;jh=false;var f=e.firstBaseUpdate,g=e.lastBaseUpdate,h=e.shared.pending;if(null!==h){e.shared.pending=null;var k=h,l=k.next;k.next=null;null===g?f=l:g.next=l;g=k;var m=a.alternate;null!==m&&(m=m.updateQueue,h=m.lastBaseUpdate,h!==g&&(null===h?m.firstBaseUpdate=l:h.next=l,m.lastBaseUpdate=k));}if(null!==f){var q=e.baseState;g=0;m=l=k=null;h=f;do{var r=h.lane,y=h.eventTime;if((d&r)===r){null!==m&&(m=m.next={eventTime:y,lane:0,tag:h.tag,payload:h.payload,callback:h.callback,
    	next:null});a:{var n=a,t=h;r=b;y=c;switch(t.tag){case 1:n=t.payload;if("function"===typeof n){q=n.call(y,q,r);break a}q=n;break a;case 3:n.flags=n.flags&-65537|128;case 0:n=t.payload;r="function"===typeof n?n.call(y,q,r):n;if(null===r||void 0===r)break a;q=A({},q,r);break a;case 2:jh=true;}}null!==h.callback&&0!==h.lane&&(a.flags|=64,r=e.effects,null===r?e.effects=[h]:r.push(h));}else y={eventTime:y,lane:r,tag:h.tag,payload:h.payload,callback:h.callback,next:null},null===m?(l=m=y,k=q):m=m.next=y,g|=r;
    	h=h.next;if(null===h)if(h=e.shared.pending,null===h)break;else r=h,h=r.next,r.next=null,e.lastBaseUpdate=r,e.shared.pending=null;}while(1);null===m&&(k=q);e.baseState=k;e.firstBaseUpdate=l;e.lastBaseUpdate=m;b=e.shared.interleaved;if(null!==b){e=b;do g|=e.lane,e=e.next;while(e!==b)}else null===f&&(e.shared.lanes=0);rh|=g;a.lanes=g;a.memoizedState=q;}}
    	function sh(a,b,c){a=b.effects;b.effects=null;if(null!==a)for(b=0;b<a.length;b++){var d=a[b],e=d.callback;if(null!==e){d.callback=null;d=c;if("function"!==typeof e)throw Error(p(191,e));e.call(d);}}}var th={},uh=Uf(th),vh=Uf(th),wh=Uf(th);function xh(a){if(a===th)throw Error(p(174));return a}
    	function yh(a,b){G(wh,b);G(vh,a);G(uh,th);a=b.nodeType;switch(a){case 9:case 11:b=(b=b.documentElement)?b.namespaceURI:lb(null,"");break;default:a=8===a?b.parentNode:b,b=a.namespaceURI||null,a=a.tagName,b=lb(b,a);}E(uh);G(uh,b);}function zh(){E(uh);E(vh);E(wh);}function Ah(a){xh(wh.current);var b=xh(uh.current);var c=lb(b,a.type);b!==c&&(G(vh,a),G(uh,c));}function Bh(a){vh.current===a&&(E(uh),E(vh));}var L=Uf(0);
    	function Ch(a){for(var b=a;null!==b;){if(13===b.tag){var c=b.memoizedState;if(null!==c&&(c=c.dehydrated,null===c||"$?"===c.data||"$!"===c.data))return b}else if(19===b.tag&&void 0!==b.memoizedProps.revealOrder){if(0!==(b.flags&128))return b}else if(null!==b.child){b.child.return=b;b=b.child;continue}if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return null;b=b.return;}b.sibling.return=b.return;b=b.sibling;}return null}var Dh=[];
    	function Eh(){for(var a=0;a<Dh.length;a++)Dh[a]._workInProgressVersionPrimary=null;Dh.length=0;}var Fh=ua.ReactCurrentDispatcher,Gh=ua.ReactCurrentBatchConfig,Hh=0,M=null,N=null,O=null,Ih=false,Jh=false,Kh=0,Lh=0;function P(){throw Error(p(321));}function Mh(a,b){if(null===b)return  false;for(var c=0;c<b.length&&c<a.length;c++)if(!He(a[c],b[c]))return  false;return  true}
    	function Nh(a,b,c,d,e,f){Hh=f;M=b;b.memoizedState=null;b.updateQueue=null;b.lanes=0;Fh.current=null===a||null===a.memoizedState?Oh:Ph;a=c(d,e);if(Jh){f=0;do{Jh=false;Kh=0;if(25<=f)throw Error(p(301));f+=1;O=N=null;b.updateQueue=null;Fh.current=Qh;a=c(d,e);}while(Jh)}Fh.current=Rh;b=null!==N&&null!==N.next;Hh=0;O=N=M=null;Ih=false;if(b)throw Error(p(300));return a}function Sh(){var a=0!==Kh;Kh=0;return a}
    	function Th(){var a={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===O?M.memoizedState=O=a:O=O.next=a;return O}function Uh(){if(null===N){var a=M.alternate;a=null!==a?a.memoizedState:null;}else a=N.next;var b=null===O?M.memoizedState:O.next;if(null!==b)O=b,N=a;else {if(null===a)throw Error(p(310));N=a;a={memoizedState:N.memoizedState,baseState:N.baseState,baseQueue:N.baseQueue,queue:N.queue,next:null};null===O?M.memoizedState=O=a:O=O.next=a;}return O}
    	function Vh(a,b){return "function"===typeof b?b(a):b}
    	function Wh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=N,e=d.baseQueue,f=c.pending;if(null!==f){if(null!==e){var g=e.next;e.next=f.next;f.next=g;}d.baseQueue=e=f;c.pending=null;}if(null!==e){f=e.next;d=d.baseState;var h=g=null,k=null,l=f;do{var m=l.lane;if((Hh&m)===m)null!==k&&(k=k.next={lane:0,action:l.action,hasEagerState:l.hasEagerState,eagerState:l.eagerState,next:null}),d=l.hasEagerState?l.eagerState:a(d,l.action);else {var q={lane:m,action:l.action,hasEagerState:l.hasEagerState,
    	eagerState:l.eagerState,next:null};null===k?(h=k=q,g=d):k=k.next=q;M.lanes|=m;rh|=m;}l=l.next;}while(null!==l&&l!==f);null===k?g=d:k.next=h;He(d,b.memoizedState)||(dh=true);b.memoizedState=d;b.baseState=g;b.baseQueue=k;c.lastRenderedState=d;}a=c.interleaved;if(null!==a){e=a;do f=e.lane,M.lanes|=f,rh|=f,e=e.next;while(e!==a)}else null===e&&(c.lanes=0);return [b.memoizedState,c.dispatch]}
    	function Xh(a){var b=Uh(),c=b.queue;if(null===c)throw Error(p(311));c.lastRenderedReducer=a;var d=c.dispatch,e=c.pending,f=b.memoizedState;if(null!==e){c.pending=null;var g=e=e.next;do f=a(f,g.action),g=g.next;while(g!==e);He(f,b.memoizedState)||(dh=true);b.memoizedState=f;null===b.baseQueue&&(b.baseState=f);c.lastRenderedState=f;}return [f,d]}function Yh(){}
    	function Zh(a,b){var c=M,d=Uh(),e=b(),f=!He(d.memoizedState,e);f&&(d.memoizedState=e,dh=true);d=d.queue;$h(ai.bind(null,c,d,a),[a]);if(d.getSnapshot!==b||f||null!==O&&O.memoizedState.tag&1){c.flags|=2048;bi(9,ci.bind(null,c,d,e,b),void 0,null);if(null===Q)throw Error(p(349));0!==(Hh&30)||di(c,b,e);}return e}function di(a,b,c){a.flags|=16384;a={getSnapshot:b,value:c};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.stores=[a]):(c=b.stores,null===c?b.stores=[a]:c.push(a));}
    	function ci(a,b,c,d){b.value=c;b.getSnapshot=d;ei(b)&&fi(a);}function ai(a,b,c){return c(function(){ei(b)&&fi(a);})}function ei(a){var b=a.getSnapshot;a=a.value;try{var c=b();return !He(a,c)}catch(d){return  true}}function fi(a){var b=ih(a,1);null!==b&&gi(b,a,1,-1);}
    	function hi(a){var b=Th();"function"===typeof a&&(a=a());b.memoizedState=b.baseState=a;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Vh,lastRenderedState:a};b.queue=a;a=a.dispatch=ii.bind(null,M,a);return [b.memoizedState,a]}
    	function bi(a,b,c,d){a={tag:a,create:b,destroy:c,deps:d,next:null};b=M.updateQueue;null===b?(b={lastEffect:null,stores:null},M.updateQueue=b,b.lastEffect=a.next=a):(c=b.lastEffect,null===c?b.lastEffect=a.next=a:(d=c.next,c.next=a,a.next=d,b.lastEffect=a));return a}function ji(){return Uh().memoizedState}function ki(a,b,c,d){var e=Th();M.flags|=a;e.memoizedState=bi(1|b,c,void 0,void 0===d?null:d);}
    	function li(a,b,c,d){var e=Uh();d=void 0===d?null:d;var f=void 0;if(null!==N){var g=N.memoizedState;f=g.destroy;if(null!==d&&Mh(d,g.deps)){e.memoizedState=bi(b,c,f,d);return}}M.flags|=a;e.memoizedState=bi(1|b,c,f,d);}function mi(a,b){return ki(8390656,8,a,b)}function $h(a,b){return li(2048,8,a,b)}function ni(a,b){return li(4,2,a,b)}function oi(a,b){return li(4,4,a,b)}
    	function pi(a,b){if("function"===typeof b)return a=a(),b(a),function(){b(null);};if(null!==b&&void 0!==b)return a=a(),b.current=a,function(){b.current=null;}}function qi(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return li(4,4,pi.bind(null,b,a),c)}function ri(){}function si(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];c.memoizedState=[a,b];return a}
    	function ti(a,b){var c=Uh();b=void 0===b?null:b;var d=c.memoizedState;if(null!==d&&null!==b&&Mh(b,d[1]))return d[0];a=a();c.memoizedState=[a,b];return a}function ui(a,b,c){if(0===(Hh&21))return a.baseState&&(a.baseState=false,dh=true),a.memoizedState=c;He(c,b)||(c=yc(),M.lanes|=c,rh|=c,a.baseState=true);return b}function vi(a,b){var c=C;C=0!==c&&4>c?c:4;a(true);var d=Gh.transition;Gh.transition={};try{a(!1),b();}finally{C=c,Gh.transition=d;}}function wi(){return Uh().memoizedState}
    	function xi(a,b,c){var d=yi(a);c={lane:d,action:c,hasEagerState:false,eagerState:null,next:null};if(zi(a))Ai(b,c);else if(c=hh(a,b,c,d),null!==c){var e=R();gi(c,a,d,e);Bi(c,b,d);}}
    	function ii(a,b,c){var d=yi(a),e={lane:d,action:c,hasEagerState:false,eagerState:null,next:null};if(zi(a))Ai(b,e);else {var f=a.alternate;if(0===a.lanes&&(null===f||0===f.lanes)&&(f=b.lastRenderedReducer,null!==f))try{var g=b.lastRenderedState,h=f(g,c);e.hasEagerState=!0;e.eagerState=h;if(He(h,g)){var k=b.interleaved;null===k?(e.next=e,gh(b)):(e.next=k.next,k.next=e);b.interleaved=e;return}}catch(l){}finally{}c=hh(a,b,e,d);null!==c&&(e=R(),gi(c,a,d,e),Bi(c,b,d));}}
    	function zi(a){var b=a.alternate;return a===M||null!==b&&b===M}function Ai(a,b){Jh=Ih=true;var c=a.pending;null===c?b.next=b:(b.next=c.next,c.next=b);a.pending=b;}function Bi(a,b,c){if(0!==(c&4194240)){var d=b.lanes;d&=a.pendingLanes;c|=d;b.lanes=c;Cc(a,c);}}
    	var Rh={readContext:eh,useCallback:P,useContext:P,useEffect:P,useImperativeHandle:P,useInsertionEffect:P,useLayoutEffect:P,useMemo:P,useReducer:P,useRef:P,useState:P,useDebugValue:P,useDeferredValue:P,useTransition:P,useMutableSource:P,useSyncExternalStore:P,useId:P,unstable_isNewReconciler:false},Oh={readContext:eh,useCallback:function(a,b){Th().memoizedState=[a,void 0===b?null:b];return a},useContext:eh,useEffect:mi,useImperativeHandle:function(a,b,c){c=null!==c&&void 0!==c?c.concat([a]):null;return ki(4194308,
    	4,pi.bind(null,b,a),c)},useLayoutEffect:function(a,b){return ki(4194308,4,a,b)},useInsertionEffect:function(a,b){return ki(4,2,a,b)},useMemo:function(a,b){var c=Th();b=void 0===b?null:b;a=a();c.memoizedState=[a,b];return a},useReducer:function(a,b,c){var d=Th();b=void 0!==c?c(b):b;d.memoizedState=d.baseState=b;a={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:a,lastRenderedState:b};d.queue=a;a=a.dispatch=xi.bind(null,M,a);return [d.memoizedState,a]},useRef:function(a){var b=
    	Th();a={current:a};return b.memoizedState=a},useState:hi,useDebugValue:ri,useDeferredValue:function(a){return Th().memoizedState=a},useTransition:function(){var a=hi(false),b=a[0];a=vi.bind(null,a[1]);Th().memoizedState=a;return [b,a]},useMutableSource:function(){},useSyncExternalStore:function(a,b,c){var d=M,e=Th();if(I){if(void 0===c)throw Error(p(407));c=c();}else {c=b();if(null===Q)throw Error(p(349));0!==(Hh&30)||di(d,b,c);}e.memoizedState=c;var f={value:c,getSnapshot:b};e.queue=f;mi(ai.bind(null,d,
    	f,a),[a]);d.flags|=2048;bi(9,ci.bind(null,d,f,c,b),void 0,null);return c},useId:function(){var a=Th(),b=Q.identifierPrefix;if(I){var c=sg;var d=rg;c=(d&~(1<<32-oc(d)-1)).toString(32)+c;b=":"+b+"R"+c;c=Kh++;0<c&&(b+="H"+c.toString(32));b+=":";}else c=Lh++,b=":"+b+"r"+c.toString(32)+":";return a.memoizedState=b},unstable_isNewReconciler:false},Ph={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Wh,useRef:ji,useState:function(){return Wh(Vh)},
    	useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return ui(b,N.memoizedState,a)},useTransition:function(){var a=Wh(Vh)[0],b=Uh().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:false},Qh={readContext:eh,useCallback:si,useContext:eh,useEffect:$h,useImperativeHandle:qi,useInsertionEffect:ni,useLayoutEffect:oi,useMemo:ti,useReducer:Xh,useRef:ji,useState:function(){return Xh(Vh)},useDebugValue:ri,useDeferredValue:function(a){var b=Uh();return null===
    	N?b.memoizedState=a:ui(b,N.memoizedState,a)},useTransition:function(){var a=Xh(Vh)[0],b=Uh().memoizedState;return [a,b]},useMutableSource:Yh,useSyncExternalStore:Zh,useId:wi,unstable_isNewReconciler:false};function Ci(a,b){if(a&&a.defaultProps){b=A({},b);a=a.defaultProps;for(var c in a) void 0===b[c]&&(b[c]=a[c]);return b}return b}function Di(a,b,c,d){b=a.memoizedState;c=c(d,b);c=null===c||void 0===c?b:A({},b,c);a.memoizedState=c;0===a.lanes&&(a.updateQueue.baseState=c);}
    	var Ei={isMounted:function(a){return (a=a._reactInternals)?Vb(a)===a:false},enqueueSetState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e));},enqueueReplaceState:function(a,b,c){a=a._reactInternals;var d=R(),e=yi(a),f=mh(d,e);f.tag=1;f.payload=b;void 0!==c&&null!==c&&(f.callback=c);b=nh(a,f,e);null!==b&&(gi(b,a,e,d),oh(b,a,e));},enqueueForceUpdate:function(a,b){a=a._reactInternals;var c=R(),d=
    	yi(a),e=mh(c,d);e.tag=2;void 0!==b&&null!==b&&(e.callback=b);b=nh(a,e,d);null!==b&&(gi(b,a,d,c),oh(b,a,d));}};function Fi(a,b,c,d,e,f,g){a=a.stateNode;return "function"===typeof a.shouldComponentUpdate?a.shouldComponentUpdate(d,f,g):b.prototype&&b.prototype.isPureReactComponent?!Ie(c,d)||!Ie(e,f):true}
    	function Gi(a,b,c){var d=false,e=Vf;var f=b.contextType;"object"===typeof f&&null!==f?f=eh(f):(e=Zf(b)?Xf:H.current,d=b.contextTypes,f=(d=null!==d&&void 0!==d)?Yf(a,e):Vf);b=new b(c,f);a.memoizedState=null!==b.state&&void 0!==b.state?b.state:null;b.updater=Ei;a.stateNode=b;b._reactInternals=a;d&&(a=a.stateNode,a.__reactInternalMemoizedUnmaskedChildContext=e,a.__reactInternalMemoizedMaskedChildContext=f);return b}
    	function Hi(a,b,c,d){a=b.state;"function"===typeof b.componentWillReceiveProps&&b.componentWillReceiveProps(c,d);"function"===typeof b.UNSAFE_componentWillReceiveProps&&b.UNSAFE_componentWillReceiveProps(c,d);b.state!==a&&Ei.enqueueReplaceState(b,b.state,null);}
    	function Ii(a,b,c,d){var e=a.stateNode;e.props=c;e.state=a.memoizedState;e.refs={};kh(a);var f=b.contextType;"object"===typeof f&&null!==f?e.context=eh(f):(f=Zf(b)?Xf:H.current,e.context=Yf(a,f));e.state=a.memoizedState;f=b.getDerivedStateFromProps;"function"===typeof f&&(Di(a,b,f,c),e.state=a.memoizedState);"function"===typeof b.getDerivedStateFromProps||"function"===typeof e.getSnapshotBeforeUpdate||"function"!==typeof e.UNSAFE_componentWillMount&&"function"!==typeof e.componentWillMount||(b=e.state,
    	"function"===typeof e.componentWillMount&&e.componentWillMount(),"function"===typeof e.UNSAFE_componentWillMount&&e.UNSAFE_componentWillMount(),b!==e.state&&Ei.enqueueReplaceState(e,e.state,null),qh(a,c,e,d),e.state=a.memoizedState);"function"===typeof e.componentDidMount&&(a.flags|=4194308);}function Ji(a,b){try{var c="",d=b;do c+=Pa(d),d=d.return;while(d);var e=c;}catch(f){e="\nError generating stack: "+f.message+"\n"+f.stack;}return {value:a,source:b,stack:e,digest:null}}
    	function Ki(a,b,c){return {value:a,source:null,stack:null!=c?c:null,digest:null!=b?b:null}}function Li(a,b){try{console.error(b.value);}catch(c){setTimeout(function(){throw c;});}}var Mi="function"===typeof WeakMap?WeakMap:Map;function Ni(a,b,c){c=mh(-1,c);c.tag=3;c.payload={element:null};var d=b.value;c.callback=function(){Oi||(Oi=true,Pi=d);Li(a,b);};return c}
    	function Qi(a,b,c){c=mh(-1,c);c.tag=3;var d=a.type.getDerivedStateFromError;if("function"===typeof d){var e=b.value;c.payload=function(){return d(e)};c.callback=function(){Li(a,b);};}var f=a.stateNode;null!==f&&"function"===typeof f.componentDidCatch&&(c.callback=function(){Li(a,b);"function"!==typeof d&&(null===Ri?Ri=new Set([this]):Ri.add(this));var c=b.stack;this.componentDidCatch(b.value,{componentStack:null!==c?c:""});});return c}
    	function Si(a,b,c){var d=a.pingCache;if(null===d){d=a.pingCache=new Mi;var e=new Set;d.set(b,e);}else e=d.get(b),void 0===e&&(e=new Set,d.set(b,e));e.has(c)||(e.add(c),a=Ti.bind(null,a,b,c),b.then(a,a));}function Ui(a){do{var b;if(b=13===a.tag)b=a.memoizedState,b=null!==b?null!==b.dehydrated?true:false:true;if(b)return a;a=a.return;}while(null!==a);return null}
    	function Vi(a,b,c,d,e){if(0===(a.mode&1))return a===b?a.flags|=65536:(a.flags|=128,c.flags|=131072,c.flags&=-52805,1===c.tag&&(null===c.alternate?c.tag=17:(b=mh(-1,1),b.tag=2,nh(c,b,1))),c.lanes|=1),a;a.flags|=65536;a.lanes=e;return a}var Wi=ua.ReactCurrentOwner,dh=false;function Xi(a,b,c,d){b.child=null===a?Vg(b,null,c,d):Ug(b,a.child,c,d);}
    	function Yi(a,b,c,d,e){c=c.render;var f=b.ref;ch(b,e);d=Nh(a,b,c,d,f,e);c=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&c&&vg(b);b.flags|=1;Xi(a,b,d,e);return b.child}
    	function $i(a,b,c,d,e){if(null===a){var f=c.type;if("function"===typeof f&&!aj(f)&&void 0===f.defaultProps&&null===c.compare&&void 0===c.defaultProps)return b.tag=15,b.type=f,bj(a,b,f,d,e);a=Rg(c.type,null,d,b,b.mode,e);a.ref=b.ref;a.return=b;return b.child=a}f=a.child;if(0===(a.lanes&e)){var g=f.memoizedProps;c=c.compare;c=null!==c?c:Ie;if(c(g,d)&&a.ref===b.ref)return Zi(a,b,e)}b.flags|=1;a=Pg(f,d);a.ref=b.ref;a.return=b;return b.child=a}
    	function bj(a,b,c,d,e){if(null!==a){var f=a.memoizedProps;if(Ie(f,d)&&a.ref===b.ref)if(dh=false,b.pendingProps=d=f,0!==(a.lanes&e))0!==(a.flags&131072)&&(dh=true);else return b.lanes=a.lanes,Zi(a,b,e)}return cj(a,b,c,d,e)}
    	function dj(a,b,c){var d=b.pendingProps,e=d.children,f=null!==a?a.memoizedState:null;if("hidden"===d.mode)if(0===(b.mode&1))b.memoizedState={baseLanes:0,cachePool:null,transitions:null},G(ej,fj),fj|=c;else {if(0===(c&1073741824))return a=null!==f?f.baseLanes|c:c,b.lanes=b.childLanes=1073741824,b.memoizedState={baseLanes:a,cachePool:null,transitions:null},b.updateQueue=null,G(ej,fj),fj|=a,null;b.memoizedState={baseLanes:0,cachePool:null,transitions:null};d=null!==f?f.baseLanes:c;G(ej,fj);fj|=d;}else null!==
    	f?(d=f.baseLanes|c,b.memoizedState=null):d=c,G(ej,fj),fj|=d;Xi(a,b,e,c);return b.child}function gj(a,b){var c=b.ref;if(null===a&&null!==c||null!==a&&a.ref!==c)b.flags|=512,b.flags|=2097152;}function cj(a,b,c,d,e){var f=Zf(c)?Xf:H.current;f=Yf(b,f);ch(b,e);c=Nh(a,b,c,d,f,e);d=Sh();if(null!==a&&!dh)return b.updateQueue=a.updateQueue,b.flags&=-2053,a.lanes&=~e,Zi(a,b,e);I&&d&&vg(b);b.flags|=1;Xi(a,b,c,e);return b.child}
    	function hj(a,b,c,d,e){if(Zf(c)){var f=true;cg(b);}else f=false;ch(b,e);if(null===b.stateNode)ij(a,b),Gi(b,c,d),Ii(b,c,d,e),d=true;else if(null===a){var g=b.stateNode,h=b.memoizedProps;g.props=h;var k=g.context,l=c.contextType;"object"===typeof l&&null!==l?l=eh(l):(l=Zf(c)?Xf:H.current,l=Yf(b,l));var m=c.getDerivedStateFromProps,q="function"===typeof m||"function"===typeof g.getSnapshotBeforeUpdate;q||"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||
    	(h!==d||k!==l)&&Hi(b,g,d,l);jh=false;var r=b.memoizedState;g.state=r;qh(b,d,g,e);k=b.memoizedState;h!==d||r!==k||Wf.current||jh?("function"===typeof m&&(Di(b,c,m,d),k=b.memoizedState),(h=jh||Fi(b,c,h,d,r,k,l))?(q||"function"!==typeof g.UNSAFE_componentWillMount&&"function"!==typeof g.componentWillMount||("function"===typeof g.componentWillMount&&g.componentWillMount(),"function"===typeof g.UNSAFE_componentWillMount&&g.UNSAFE_componentWillMount()),"function"===typeof g.componentDidMount&&(b.flags|=4194308)):
    	("function"===typeof g.componentDidMount&&(b.flags|=4194308),b.memoizedProps=d,b.memoizedState=k),g.props=d,g.state=k,g.context=l,d=h):("function"===typeof g.componentDidMount&&(b.flags|=4194308),d=false);}else {g=b.stateNode;lh(a,b);h=b.memoizedProps;l=b.type===b.elementType?h:Ci(b.type,h);g.props=l;q=b.pendingProps;r=g.context;k=c.contextType;"object"===typeof k&&null!==k?k=eh(k):(k=Zf(c)?Xf:H.current,k=Yf(b,k));var y=c.getDerivedStateFromProps;(m="function"===typeof y||"function"===typeof g.getSnapshotBeforeUpdate)||
    	"function"!==typeof g.UNSAFE_componentWillReceiveProps&&"function"!==typeof g.componentWillReceiveProps||(h!==q||r!==k)&&Hi(b,g,d,k);jh=false;r=b.memoizedState;g.state=r;qh(b,d,g,e);var n=b.memoizedState;h!==q||r!==n||Wf.current||jh?("function"===typeof y&&(Di(b,c,y,d),n=b.memoizedState),(l=jh||Fi(b,c,l,d,r,n,k)||false)?(m||"function"!==typeof g.UNSAFE_componentWillUpdate&&"function"!==typeof g.componentWillUpdate||("function"===typeof g.componentWillUpdate&&g.componentWillUpdate(d,n,k),"function"===typeof g.UNSAFE_componentWillUpdate&&
    	g.UNSAFE_componentWillUpdate(d,n,k)),"function"===typeof g.componentDidUpdate&&(b.flags|=4),"function"===typeof g.getSnapshotBeforeUpdate&&(b.flags|=1024)):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),b.memoizedProps=d,b.memoizedState=n),g.props=d,g.state=n,g.context=k,d=l):("function"!==typeof g.componentDidUpdate||h===a.memoizedProps&&r===
    	a.memoizedState||(b.flags|=4),"function"!==typeof g.getSnapshotBeforeUpdate||h===a.memoizedProps&&r===a.memoizedState||(b.flags|=1024),d=false);}return jj(a,b,c,d,f,e)}
    	function jj(a,b,c,d,e,f){gj(a,b);var g=0!==(b.flags&128);if(!d&&!g)return e&&dg(b,c,false),Zi(a,b,f);d=b.stateNode;Wi.current=b;var h=g&&"function"!==typeof c.getDerivedStateFromError?null:d.render();b.flags|=1;null!==a&&g?(b.child=Ug(b,a.child,null,f),b.child=Ug(b,null,h,f)):Xi(a,b,h,f);b.memoizedState=d.state;e&&dg(b,c,true);return b.child}function kj(a){var b=a.stateNode;b.pendingContext?ag(a,b.pendingContext,b.pendingContext!==b.context):b.context&&ag(a,b.context,false);yh(a,b.containerInfo);}
    	function lj(a,b,c,d,e){Ig();Jg(e);b.flags|=256;Xi(a,b,c,d);return b.child}var mj={dehydrated:null,treeContext:null,retryLane:0};function nj(a){return {baseLanes:a,cachePool:null,transitions:null}}
    	function oj(a,b,c){var d=b.pendingProps,e=L.current,f=false,g=0!==(b.flags&128),h;(h=g)||(h=null!==a&&null===a.memoizedState?false:0!==(e&2));if(h)f=true,b.flags&=-129;else if(null===a||null!==a.memoizedState)e|=1;G(L,e&1);if(null===a){Eg(b);a=b.memoizedState;if(null!==a&&(a=a.dehydrated,null!==a))return 0===(b.mode&1)?b.lanes=1:"$!"===a.data?b.lanes=8:b.lanes=1073741824,null;g=d.children;a=d.fallback;return f?(d=b.mode,f=b.child,g={mode:"hidden",children:g},0===(d&1)&&null!==f?(f.childLanes=0,f.pendingProps=
    	g):f=pj(g,d,0,null),a=Tg(a,d,c,null),f.return=b,a.return=b,f.sibling=a,b.child=f,b.child.memoizedState=nj(c),b.memoizedState=mj,a):qj(b,g)}e=a.memoizedState;if(null!==e&&(h=e.dehydrated,null!==h))return rj(a,b,g,d,h,e,c);if(f){f=d.fallback;g=b.mode;e=a.child;h=e.sibling;var k={mode:"hidden",children:d.children};0===(g&1)&&b.child!==e?(d=b.child,d.childLanes=0,d.pendingProps=k,b.deletions=null):(d=Pg(e,k),d.subtreeFlags=e.subtreeFlags&14680064);null!==h?f=Pg(h,f):(f=Tg(f,g,c,null),f.flags|=2);f.return=
    	b;d.return=b;d.sibling=f;b.child=d;d=f;f=b.child;g=a.child.memoizedState;g=null===g?nj(c):{baseLanes:g.baseLanes|c,cachePool:null,transitions:g.transitions};f.memoizedState=g;f.childLanes=a.childLanes&~c;b.memoizedState=mj;return d}f=a.child;a=f.sibling;d=Pg(f,{mode:"visible",children:d.children});0===(b.mode&1)&&(d.lanes=c);d.return=b;d.sibling=null;null!==a&&(c=b.deletions,null===c?(b.deletions=[a],b.flags|=16):c.push(a));b.child=d;b.memoizedState=null;return d}
    	function qj(a,b){b=pj({mode:"visible",children:b},a.mode,0,null);b.return=a;return a.child=b}function sj(a,b,c,d){null!==d&&Jg(d);Ug(b,a.child,null,c);a=qj(b,b.pendingProps.children);a.flags|=2;b.memoizedState=null;return a}
    	function rj(a,b,c,d,e,f,g){if(c){if(b.flags&256)return b.flags&=-257,d=Ki(Error(p(422))),sj(a,b,g,d);if(null!==b.memoizedState)return b.child=a.child,b.flags|=128,null;f=d.fallback;e=b.mode;d=pj({mode:"visible",children:d.children},e,0,null);f=Tg(f,e,g,null);f.flags|=2;d.return=b;f.return=b;d.sibling=f;b.child=d;0!==(b.mode&1)&&Ug(b,a.child,null,g);b.child.memoizedState=nj(g);b.memoizedState=mj;return f}if(0===(b.mode&1))return sj(a,b,g,null);if("$!"===e.data){d=e.nextSibling&&e.nextSibling.dataset;
    	if(d)var h=d.dgst;d=h;f=Error(p(419));d=Ki(f,d,void 0);return sj(a,b,g,d)}h=0!==(g&a.childLanes);if(dh||h){d=Q;if(null!==d){switch(g&-g){case 4:e=2;break;case 16:e=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:e=32;break;case 536870912:e=268435456;break;default:e=0;}e=0!==(e&(d.suspendedLanes|g))?0:e;
    	0!==e&&e!==f.retryLane&&(f.retryLane=e,ih(a,e),gi(d,a,e,-1));}tj();d=Ki(Error(p(421)));return sj(a,b,g,d)}if("$?"===e.data)return b.flags|=128,b.child=a.child,b=uj.bind(null,a),e._reactRetry=b,null;a=f.treeContext;yg=Lf(e.nextSibling);xg=b;I=true;zg=null;null!==a&&(og[pg++]=rg,og[pg++]=sg,og[pg++]=qg,rg=a.id,sg=a.overflow,qg=b);b=qj(b,d.children);b.flags|=4096;return b}function vj(a,b,c){a.lanes|=b;var d=a.alternate;null!==d&&(d.lanes|=b);bh(a.return,b,c);}
    	function wj(a,b,c,d,e){var f=a.memoizedState;null===f?a.memoizedState={isBackwards:b,rendering:null,renderingStartTime:0,last:d,tail:c,tailMode:e}:(f.isBackwards=b,f.rendering=null,f.renderingStartTime=0,f.last=d,f.tail=c,f.tailMode=e);}
    	function xj(a,b,c){var d=b.pendingProps,e=d.revealOrder,f=d.tail;Xi(a,b,d.children,c);d=L.current;if(0!==(d&2))d=d&1|2,b.flags|=128;else {if(null!==a&&0!==(a.flags&128))a:for(a=b.child;null!==a;){if(13===a.tag)null!==a.memoizedState&&vj(a,c,b);else if(19===a.tag)vj(a,c,b);else if(null!==a.child){a.child.return=a;a=a.child;continue}if(a===b)break a;for(;null===a.sibling;){if(null===a.return||a.return===b)break a;a=a.return;}a.sibling.return=a.return;a=a.sibling;}d&=1;}G(L,d);if(0===(b.mode&1))b.memoizedState=
    	null;else switch(e){case "forwards":c=b.child;for(e=null;null!==c;)a=c.alternate,null!==a&&null===Ch(a)&&(e=c),c=c.sibling;c=e;null===c?(e=b.child,b.child=null):(e=c.sibling,c.sibling=null);wj(b,false,e,c,f);break;case "backwards":c=null;e=b.child;for(b.child=null;null!==e;){a=e.alternate;if(null!==a&&null===Ch(a)){b.child=e;break}a=e.sibling;e.sibling=c;c=e;e=a;}wj(b,true,c,null,f);break;case "together":wj(b,false,null,null,void 0);break;default:b.memoizedState=null;}return b.child}
    	function ij(a,b){0===(b.mode&1)&&null!==a&&(a.alternate=null,b.alternate=null,b.flags|=2);}function Zi(a,b,c){null!==a&&(b.dependencies=a.dependencies);rh|=b.lanes;if(0===(c&b.childLanes))return null;if(null!==a&&b.child!==a.child)throw Error(p(153));if(null!==b.child){a=b.child;c=Pg(a,a.pendingProps);b.child=c;for(c.return=b;null!==a.sibling;)a=a.sibling,c=c.sibling=Pg(a,a.pendingProps),c.return=b;c.sibling=null;}return b.child}
    	function yj(a,b,c){switch(b.tag){case 3:kj(b);Ig();break;case 5:Ah(b);break;case 1:Zf(b.type)&&cg(b);break;case 4:yh(b,b.stateNode.containerInfo);break;case 10:var d=b.type._context,e=b.memoizedProps.value;G(Wg,d._currentValue);d._currentValue=e;break;case 13:d=b.memoizedState;if(null!==d){if(null!==d.dehydrated)return G(L,L.current&1),b.flags|=128,null;if(0!==(c&b.child.childLanes))return oj(a,b,c);G(L,L.current&1);a=Zi(a,b,c);return null!==a?a.sibling:null}G(L,L.current&1);break;case 19:d=0!==(c&
    	b.childLanes);if(0!==(a.flags&128)){if(d)return xj(a,b,c);b.flags|=128;}e=b.memoizedState;null!==e&&(e.rendering=null,e.tail=null,e.lastEffect=null);G(L,L.current);if(d)break;else return null;case 22:case 23:return b.lanes=0,dj(a,b,c)}return Zi(a,b,c)}var zj,Aj,Bj,Cj;
    	zj=function(a,b){for(var c=b.child;null!==c;){if(5===c.tag||6===c.tag)a.appendChild(c.stateNode);else if(4!==c.tag&&null!==c.child){c.child.return=c;c=c.child;continue}if(c===b)break;for(;null===c.sibling;){if(null===c.return||c.return===b)return;c=c.return;}c.sibling.return=c.return;c=c.sibling;}};Aj=function(){};
    	Bj=function(a,b,c,d){var e=a.memoizedProps;if(e!==d){a=b.stateNode;xh(uh.current);var f=null;switch(c){case "input":e=Ya(a,e);d=Ya(a,d);f=[];break;case "select":e=A({},e,{value:void 0});d=A({},d,{value:void 0});f=[];break;case "textarea":e=gb(a,e);d=gb(a,d);f=[];break;default:"function"!==typeof e.onClick&&"function"===typeof d.onClick&&(a.onclick=Bf);}ub(c,d);var g;c=null;for(l in e)if(!d.hasOwnProperty(l)&&e.hasOwnProperty(l)&&null!=e[l])if("style"===l){var h=e[l];for(g in h)h.hasOwnProperty(g)&&
    	(c||(c={}),c[g]="");}else "dangerouslySetInnerHTML"!==l&&"children"!==l&&"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&"autoFocus"!==l&&(ea.hasOwnProperty(l)?f||(f=[]):(f=f||[]).push(l,null));for(l in d){var k=d[l];h=null!=e?e[l]:void 0;if(d.hasOwnProperty(l)&&k!==h&&(null!=k||null!=h))if("style"===l)if(h){for(g in h)!h.hasOwnProperty(g)||k&&k.hasOwnProperty(g)||(c||(c={}),c[g]="");for(g in k)k.hasOwnProperty(g)&&h[g]!==k[g]&&(c||(c={}),c[g]=k[g]);}else c||(f||(f=[]),f.push(l,
    	c)),c=k;else "dangerouslySetInnerHTML"===l?(k=k?k.__html:void 0,h=h?h.__html:void 0,null!=k&&h!==k&&(f=f||[]).push(l,k)):"children"===l?"string"!==typeof k&&"number"!==typeof k||(f=f||[]).push(l,""+k):"suppressContentEditableWarning"!==l&&"suppressHydrationWarning"!==l&&(ea.hasOwnProperty(l)?(null!=k&&"onScroll"===l&&D("scroll",a),f||h===k||(f=[])):(f=f||[]).push(l,k));}c&&(f=f||[]).push("style",c);var l=f;if(b.updateQueue=l)b.flags|=4;}};Cj=function(a,b,c,d){c!==d&&(b.flags|=4);};
    	function Dj(a,b){if(!I)switch(a.tailMode){case "hidden":b=a.tail;for(var c=null;null!==b;)null!==b.alternate&&(c=b),b=b.sibling;null===c?a.tail=null:c.sibling=null;break;case "collapsed":c=a.tail;for(var d=null;null!==c;)null!==c.alternate&&(d=c),c=c.sibling;null===d?b||null===a.tail?a.tail=null:a.tail.sibling=null:d.sibling=null;}}
    	function S(a){var b=null!==a.alternate&&a.alternate.child===a.child,c=0,d=0;if(b)for(var e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags&14680064,d|=e.flags&14680064,e.return=a,e=e.sibling;else for(e=a.child;null!==e;)c|=e.lanes|e.childLanes,d|=e.subtreeFlags,d|=e.flags,e.return=a,e=e.sibling;a.subtreeFlags|=d;a.childLanes=c;return b}
    	function Ej(a,b,c){var d=b.pendingProps;wg(b);switch(b.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return S(b),null;case 1:return Zf(b.type)&&$f(),S(b),null;case 3:d=b.stateNode;zh();E(Wf);E(H);Eh();d.pendingContext&&(d.context=d.pendingContext,d.pendingContext=null);if(null===a||null===a.child)Gg(b)?b.flags|=4:null===a||a.memoizedState.isDehydrated&&0===(b.flags&256)||(b.flags|=1024,null!==zg&&(Fj(zg),zg=null));Aj(a,b);S(b);return null;case 5:Bh(b);var e=xh(wh.current);
    	c=b.type;if(null!==a&&null!=b.stateNode)Bj(a,b,c,d,e),a.ref!==b.ref&&(b.flags|=512,b.flags|=2097152);else {if(!d){if(null===b.stateNode)throw Error(p(166));S(b);return null}a=xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.type;var f=b.memoizedProps;d[Of]=b;d[Pf]=f;a=0!==(b.mode&1);switch(c){case "dialog":D("cancel",d);D("close",d);break;case "iframe":case "object":case "embed":D("load",d);break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],d);break;case "source":D("error",d);break;case "img":case "image":case "link":D("error",
    	d);D("load",d);break;case "details":D("toggle",d);break;case "input":Za(d,f);D("invalid",d);break;case "select":d._wrapperState={wasMultiple:!!f.multiple};D("invalid",d);break;case "textarea":hb(d,f),D("invalid",d);}ub(c,f);e=null;for(var g in f)if(f.hasOwnProperty(g)){var h=f[g];"children"===g?"string"===typeof h?d.textContent!==h&&(true!==f.suppressHydrationWarning&&Af(d.textContent,h,a),e=["children",h]):"number"===typeof h&&d.textContent!==""+h&&(true!==f.suppressHydrationWarning&&Af(d.textContent,
    	h,a),e=["children",""+h]):ea.hasOwnProperty(g)&&null!=h&&"onScroll"===g&&D("scroll",d);}switch(c){case "input":Va(d);db(d,f,true);break;case "textarea":Va(d);jb(d);break;case "select":case "option":break;default:"function"===typeof f.onClick&&(d.onclick=Bf);}d=e;b.updateQueue=d;null!==d&&(b.flags|=4);}else {g=9===e.nodeType?e:e.ownerDocument;"http://www.w3.org/1999/xhtml"===a&&(a=kb(c));"http://www.w3.org/1999/xhtml"===a?"script"===c?(a=g.createElement("div"),a.innerHTML="<script>\x3c/script>",a=a.removeChild(a.firstChild)):
    	"string"===typeof d.is?a=g.createElement(c,{is:d.is}):(a=g.createElement(c),"select"===c&&(g=a,d.multiple?g.multiple=true:d.size&&(g.size=d.size))):a=g.createElementNS(a,c);a[Of]=b;a[Pf]=d;zj(a,b,false,false);b.stateNode=a;a:{g=vb(c,d);switch(c){case "dialog":D("cancel",a);D("close",a);e=d;break;case "iframe":case "object":case "embed":D("load",a);e=d;break;case "video":case "audio":for(e=0;e<lf.length;e++)D(lf[e],a);e=d;break;case "source":D("error",a);e=d;break;case "img":case "image":case "link":D("error",
    	a);D("load",a);e=d;break;case "details":D("toggle",a);e=d;break;case "input":Za(a,d);e=Ya(a,d);D("invalid",a);break;case "option":e=d;break;case "select":a._wrapperState={wasMultiple:!!d.multiple};e=A({},d,{value:void 0});D("invalid",a);break;case "textarea":hb(a,d);e=gb(a,d);D("invalid",a);break;default:e=d;}ub(c,e);h=e;for(f in h)if(h.hasOwnProperty(f)){var k=h[f];"style"===f?sb(a,k):"dangerouslySetInnerHTML"===f?(k=k?k.__html:void 0,null!=k&&nb(a,k)):"children"===f?"string"===typeof k?("textarea"!==
    	c||""!==k)&&ob(a,k):"number"===typeof k&&ob(a,""+k):"suppressContentEditableWarning"!==f&&"suppressHydrationWarning"!==f&&"autoFocus"!==f&&(ea.hasOwnProperty(f)?null!=k&&"onScroll"===f&&D("scroll",a):null!=k&&ta(a,f,k,g));}switch(c){case "input":Va(a);db(a,d,false);break;case "textarea":Va(a);jb(a);break;case "option":null!=d.value&&a.setAttribute("value",""+Sa(d.value));break;case "select":a.multiple=!!d.multiple;f=d.value;null!=f?fb(a,!!d.multiple,f,false):null!=d.defaultValue&&fb(a,!!d.multiple,d.defaultValue,
    	true);break;default:"function"===typeof e.onClick&&(a.onclick=Bf);}switch(c){case "button":case "input":case "select":case "textarea":d=!!d.autoFocus;break a;case "img":d=true;break a;default:d=false;}}d&&(b.flags|=4);}null!==b.ref&&(b.flags|=512,b.flags|=2097152);}S(b);return null;case 6:if(a&&null!=b.stateNode)Cj(a,b,a.memoizedProps,d);else {if("string"!==typeof d&&null===b.stateNode)throw Error(p(166));c=xh(wh.current);xh(uh.current);if(Gg(b)){d=b.stateNode;c=b.memoizedProps;d[Of]=b;if(f=d.nodeValue!==c)if(a=
    	xg,null!==a)switch(a.tag){case 3:Af(d.nodeValue,c,0!==(a.mode&1));break;case 5:true!==a.memoizedProps.suppressHydrationWarning&&Af(d.nodeValue,c,0!==(a.mode&1));}f&&(b.flags|=4);}else d=(9===c.nodeType?c:c.ownerDocument).createTextNode(d),d[Of]=b,b.stateNode=d;}S(b);return null;case 13:E(L);d=b.memoizedState;if(null===a||null!==a.memoizedState&&null!==a.memoizedState.dehydrated){if(I&&null!==yg&&0!==(b.mode&1)&&0===(b.flags&128))Hg(),Ig(),b.flags|=98560,f=false;else if(f=Gg(b),null!==d&&null!==d.dehydrated){if(null===
    	a){if(!f)throw Error(p(318));f=b.memoizedState;f=null!==f?f.dehydrated:null;if(!f)throw Error(p(317));f[Of]=b;}else Ig(),0===(b.flags&128)&&(b.memoizedState=null),b.flags|=4;S(b);f=false;}else null!==zg&&(Fj(zg),zg=null),f=true;if(!f)return b.flags&65536?b:null}if(0!==(b.flags&128))return b.lanes=c,b;d=null!==d;d!==(null!==a&&null!==a.memoizedState)&&d&&(b.child.flags|=8192,0!==(b.mode&1)&&(null===a||0!==(L.current&1)?0===T&&(T=3):tj()));null!==b.updateQueue&&(b.flags|=4);S(b);return null;case 4:return zh(),
    	Aj(a,b),null===a&&sf(b.stateNode.containerInfo),S(b),null;case 10:return ah(b.type._context),S(b),null;case 17:return Zf(b.type)&&$f(),S(b),null;case 19:E(L);f=b.memoizedState;if(null===f)return S(b),null;d=0!==(b.flags&128);g=f.rendering;if(null===g)if(d)Dj(f,false);else {if(0!==T||null!==a&&0!==(a.flags&128))for(a=b.child;null!==a;){g=Ch(a);if(null!==g){b.flags|=128;Dj(f,false);d=g.updateQueue;null!==d&&(b.updateQueue=d,b.flags|=4);b.subtreeFlags=0;d=c;for(c=b.child;null!==c;)f=c,a=d,f.flags&=14680066,
    	g=f.alternate,null===g?(f.childLanes=0,f.lanes=a,f.child=null,f.subtreeFlags=0,f.memoizedProps=null,f.memoizedState=null,f.updateQueue=null,f.dependencies=null,f.stateNode=null):(f.childLanes=g.childLanes,f.lanes=g.lanes,f.child=g.child,f.subtreeFlags=0,f.deletions=null,f.memoizedProps=g.memoizedProps,f.memoizedState=g.memoizedState,f.updateQueue=g.updateQueue,f.type=g.type,a=g.dependencies,f.dependencies=null===a?null:{lanes:a.lanes,firstContext:a.firstContext}),c=c.sibling;G(L,L.current&1|2);return b.child}a=
    	a.sibling;}null!==f.tail&&B()>Gj&&(b.flags|=128,d=true,Dj(f,false),b.lanes=4194304);}else {if(!d)if(a=Ch(g),null!==a){if(b.flags|=128,d=true,c=a.updateQueue,null!==c&&(b.updateQueue=c,b.flags|=4),Dj(f,true),null===f.tail&&"hidden"===f.tailMode&&!g.alternate&&!I)return S(b),null}else 2*B()-f.renderingStartTime>Gj&&1073741824!==c&&(b.flags|=128,d=true,Dj(f,false),b.lanes=4194304);f.isBackwards?(g.sibling=b.child,b.child=g):(c=f.last,null!==c?c.sibling=g:b.child=g,f.last=g);}if(null!==f.tail)return b=f.tail,f.rendering=
    	b,f.tail=b.sibling,f.renderingStartTime=B(),b.sibling=null,c=L.current,G(L,d?c&1|2:c&1),b;S(b);return null;case 22:case 23:return Hj(),d=null!==b.memoizedState,null!==a&&null!==a.memoizedState!==d&&(b.flags|=8192),d&&0!==(b.mode&1)?0!==(fj&1073741824)&&(S(b),b.subtreeFlags&6&&(b.flags|=8192)):S(b),null;case 24:return null;case 25:return null}throw Error(p(156,b.tag));}
    	function Ij(a,b){wg(b);switch(b.tag){case 1:return Zf(b.type)&&$f(),a=b.flags,a&65536?(b.flags=a&-65537|128,b):null;case 3:return zh(),E(Wf),E(H),Eh(),a=b.flags,0!==(a&65536)&&0===(a&128)?(b.flags=a&-65537|128,b):null;case 5:return Bh(b),null;case 13:E(L);a=b.memoizedState;if(null!==a&&null!==a.dehydrated){if(null===b.alternate)throw Error(p(340));Ig();}a=b.flags;return a&65536?(b.flags=a&-65537|128,b):null;case 19:return E(L),null;case 4:return zh(),null;case 10:return ah(b.type._context),null;case 22:case 23:return Hj(),
    	null;case 24:return null;default:return null}}var Jj=false,U=false,Kj="function"===typeof WeakSet?WeakSet:Set,V=null;function Lj(a,b){var c=a.ref;if(null!==c)if("function"===typeof c)try{c(null);}catch(d){W(a,b,d);}else c.current=null;}function Mj(a,b,c){try{c();}catch(d){W(a,b,d);}}var Nj=false;
    	function Oj(a,b){Cf=dd;a=Me();if(Ne(a)){if("selectionStart"in a)var c={start:a.selectionStart,end:a.selectionEnd};else a:{c=(c=a.ownerDocument)&&c.defaultView||window;var d=c.getSelection&&c.getSelection();if(d&&0!==d.rangeCount){c=d.anchorNode;var e=d.anchorOffset,f=d.focusNode;d=d.focusOffset;try{c.nodeType,f.nodeType;}catch(F){c=null;break a}var g=0,h=-1,k=-1,l=0,m=0,q=a,r=null;b:for(;;){for(var y;;){q!==c||0!==e&&3!==q.nodeType||(h=g+e);q!==f||0!==d&&3!==q.nodeType||(k=g+d);3===q.nodeType&&(g+=
    	q.nodeValue.length);if(null===(y=q.firstChild))break;r=q;q=y;}for(;;){if(q===a)break b;r===c&&++l===e&&(h=g);r===f&&++m===d&&(k=g);if(null!==(y=q.nextSibling))break;q=r;r=q.parentNode;}q=y;}c=-1===h||-1===k?null:{start:h,end:k};}else c=null;}c=c||{start:0,end:0};}else c=null;Df={focusedElem:a,selectionRange:c};dd=false;for(V=b;null!==V;)if(b=V,a=b.child,0!==(b.subtreeFlags&1028)&&null!==a)a.return=b,V=a;else for(;null!==V;){b=V;try{var n=b.alternate;if(0!==(b.flags&1024))switch(b.tag){case 0:case 11:case 15:break;
    	case 1:if(null!==n){var t=n.memoizedProps,J=n.memoizedState,x=b.stateNode,w=x.getSnapshotBeforeUpdate(b.elementType===b.type?t:Ci(b.type,t),J);x.__reactInternalSnapshotBeforeUpdate=w;}break;case 3:var u=b.stateNode.containerInfo;1===u.nodeType?u.textContent="":9===u.nodeType&&u.documentElement&&u.removeChild(u.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(p(163));}}catch(F){W(b,b.return,F);}a=b.sibling;if(null!==a){a.return=b.return;V=a;break}V=b.return;}n=Nj;Nj=false;return n}
    	function Pj(a,b,c){var d=b.updateQueue;d=null!==d?d.lastEffect:null;if(null!==d){var e=d=d.next;do{if((e.tag&a)===a){var f=e.destroy;e.destroy=void 0;void 0!==f&&Mj(b,c,f);}e=e.next;}while(e!==d)}}function Qj(a,b){b=b.updateQueue;b=null!==b?b.lastEffect:null;if(null!==b){var c=b=b.next;do{if((c.tag&a)===a){var d=c.create;c.destroy=d();}c=c.next;}while(c!==b)}}function Rj(a){var b=a.ref;if(null!==b){var c=a.stateNode;switch(a.tag){case 5:a=c;break;default:a=c;}"function"===typeof b?b(a):b.current=a;}}
    	function Sj(a){var b=a.alternate;null!==b&&(a.alternate=null,Sj(b));a.child=null;a.deletions=null;a.sibling=null;5===a.tag&&(b=a.stateNode,null!==b&&(delete b[Of],delete b[Pf],delete b[of],delete b[Qf],delete b[Rf]));a.stateNode=null;a.return=null;a.dependencies=null;a.memoizedProps=null;a.memoizedState=null;a.pendingProps=null;a.stateNode=null;a.updateQueue=null;}function Tj(a){return 5===a.tag||3===a.tag||4===a.tag}
    	function Uj(a){a:for(;;){for(;null===a.sibling;){if(null===a.return||Tj(a.return))return null;a=a.return;}a.sibling.return=a.return;for(a=a.sibling;5!==a.tag&&6!==a.tag&&18!==a.tag;){if(a.flags&2)continue a;if(null===a.child||4===a.tag)continue a;else a.child.return=a,a=a.child;}if(!(a.flags&2))return a.stateNode}}
    	function Vj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?8===c.nodeType?c.parentNode.insertBefore(a,b):c.insertBefore(a,b):(8===c.nodeType?(b=c.parentNode,b.insertBefore(a,c)):(b=c,b.appendChild(a)),c=c._reactRootContainer,null!==c&&void 0!==c||null!==b.onclick||(b.onclick=Bf));else if(4!==d&&(a=a.child,null!==a))for(Vj(a,b,c),a=a.sibling;null!==a;)Vj(a,b,c),a=a.sibling;}
    	function Wj(a,b,c){var d=a.tag;if(5===d||6===d)a=a.stateNode,b?c.insertBefore(a,b):c.appendChild(a);else if(4!==d&&(a=a.child,null!==a))for(Wj(a,b,c),a=a.sibling;null!==a;)Wj(a,b,c),a=a.sibling;}var X=null,Xj=false;function Yj(a,b,c){for(c=c.child;null!==c;)Zj(a,b,c),c=c.sibling;}
    	function Zj(a,b,c){if(lc&&"function"===typeof lc.onCommitFiberUnmount)try{lc.onCommitFiberUnmount(kc,c);}catch(h){}switch(c.tag){case 5:U||Lj(c,b);case 6:var d=X,e=Xj;X=null;Yj(a,b,c);X=d;Xj=e;null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?a.parentNode.removeChild(c):a.removeChild(c)):X.removeChild(c.stateNode));break;case 18:null!==X&&(Xj?(a=X,c=c.stateNode,8===a.nodeType?Kf(a.parentNode,c):1===a.nodeType&&Kf(a,c),bd(a)):Kf(X,c.stateNode));break;case 4:d=X;e=Xj;X=c.stateNode.containerInfo;Xj=true;
    	Yj(a,b,c);X=d;Xj=e;break;case 0:case 11:case 14:case 15:if(!U&&(d=c.updateQueue,null!==d&&(d=d.lastEffect,null!==d))){e=d=d.next;do{var f=e,g=f.destroy;f=f.tag;void 0!==g&&(0!==(f&2)?Mj(c,b,g):0!==(f&4)&&Mj(c,b,g));e=e.next;}while(e!==d)}Yj(a,b,c);break;case 1:if(!U&&(Lj(c,b),d=c.stateNode,"function"===typeof d.componentWillUnmount))try{d.props=c.memoizedProps,d.state=c.memoizedState,d.componentWillUnmount();}catch(h){W(c,b,h);}Yj(a,b,c);break;case 21:Yj(a,b,c);break;case 22:c.mode&1?(U=(d=U)||null!==
    	c.memoizedState,Yj(a,b,c),U=d):Yj(a,b,c);break;default:Yj(a,b,c);}}function ak(a){var b=a.updateQueue;if(null!==b){a.updateQueue=null;var c=a.stateNode;null===c&&(c=a.stateNode=new Kj);b.forEach(function(b){var d=bk.bind(null,a,b);c.has(b)||(c.add(b),b.then(d,d));});}}
    	function ck(a,b){var c=b.deletions;if(null!==c)for(var d=0;d<c.length;d++){var e=c[d];try{var f=a,g=b,h=g;a:for(;null!==h;){switch(h.tag){case 5:X=h.stateNode;Xj=!1;break a;case 3:X=h.stateNode.containerInfo;Xj=!0;break a;case 4:X=h.stateNode.containerInfo;Xj=!0;break a}h=h.return;}if(null===X)throw Error(p(160));Zj(f,g,e);X=null;Xj=!1;var k=e.alternate;null!==k&&(k.return=null);e.return=null;}catch(l){W(e,b,l);}}if(b.subtreeFlags&12854)for(b=b.child;null!==b;)dk(b,a),b=b.sibling;}
    	function dk(a,b){var c=a.alternate,d=a.flags;switch(a.tag){case 0:case 11:case 14:case 15:ck(b,a);ek(a);if(d&4){try{Pj(3,a,a.return),Qj(3,a);}catch(t){W(a,a.return,t);}try{Pj(5,a,a.return);}catch(t){W(a,a.return,t);}}break;case 1:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);break;case 5:ck(b,a);ek(a);d&512&&null!==c&&Lj(c,c.return);if(a.flags&32){var e=a.stateNode;try{ob(e,"");}catch(t){W(a,a.return,t);}}if(d&4&&(e=a.stateNode,null!=e)){var f=a.memoizedProps,g=null!==c?c.memoizedProps:f,h=a.type,k=a.updateQueue;
    	a.updateQueue=null;if(null!==k)try{"input"===h&&"radio"===f.type&&null!=f.name&&ab(e,f);vb(h,g);var l=vb(h,f);for(g=0;g<k.length;g+=2){var m=k[g],q=k[g+1];"style"===m?sb(e,q):"dangerouslySetInnerHTML"===m?nb(e,q):"children"===m?ob(e,q):ta(e,m,q,l);}switch(h){case "input":bb(e,f);break;case "textarea":ib(e,f);break;case "select":var r=e._wrapperState.wasMultiple;e._wrapperState.wasMultiple=!!f.multiple;var y=f.value;null!=y?fb(e,!!f.multiple,y,!1):r!==!!f.multiple&&(null!=f.defaultValue?fb(e,!!f.multiple,
    	f.defaultValue,!0):fb(e,!!f.multiple,f.multiple?[]:"",!1));}e[Pf]=f;}catch(t){W(a,a.return,t);}}break;case 6:ck(b,a);ek(a);if(d&4){if(null===a.stateNode)throw Error(p(162));e=a.stateNode;f=a.memoizedProps;try{e.nodeValue=f;}catch(t){W(a,a.return,t);}}break;case 3:ck(b,a);ek(a);if(d&4&&null!==c&&c.memoizedState.isDehydrated)try{bd(b.containerInfo);}catch(t){W(a,a.return,t);}break;case 4:ck(b,a);ek(a);break;case 13:ck(b,a);ek(a);e=a.child;e.flags&8192&&(f=null!==e.memoizedState,e.stateNode.isHidden=f,!f||
    	null!==e.alternate&&null!==e.alternate.memoizedState||(fk=B()));d&4&&ak(a);break;case 22:m=null!==c&&null!==c.memoizedState;a.mode&1?(U=(l=U)||m,ck(b,a),U=l):ck(b,a);ek(a);if(d&8192){l=null!==a.memoizedState;if((a.stateNode.isHidden=l)&&!m&&0!==(a.mode&1))for(V=a,m=a.child;null!==m;){for(q=V=m;null!==V;){r=V;y=r.child;switch(r.tag){case 0:case 11:case 14:case 15:Pj(4,r,r.return);break;case 1:Lj(r,r.return);var n=r.stateNode;if("function"===typeof n.componentWillUnmount){d=r;c=r.return;try{b=d,n.props=
    	b.memoizedProps,n.state=b.memoizedState,n.componentWillUnmount();}catch(t){W(d,c,t);}}break;case 5:Lj(r,r.return);break;case 22:if(null!==r.memoizedState){gk(q);continue}}null!==y?(y.return=r,V=y):gk(q);}m=m.sibling;}a:for(m=null,q=a;;){if(5===q.tag){if(null===m){m=q;try{e=q.stateNode,l?(f=e.style,"function"===typeof f.setProperty?f.setProperty("display","none","important"):f.display="none"):(h=q.stateNode,k=q.memoizedProps.style,g=void 0!==k&&null!==k&&k.hasOwnProperty("display")?k.display:null,h.style.display=
    	rb("display",g));}catch(t){W(a,a.return,t);}}}else if(6===q.tag){if(null===m)try{q.stateNode.nodeValue=l?"":q.memoizedProps;}catch(t){W(a,a.return,t);}}else if((22!==q.tag&&23!==q.tag||null===q.memoizedState||q===a)&&null!==q.child){q.child.return=q;q=q.child;continue}if(q===a)break a;for(;null===q.sibling;){if(null===q.return||q.return===a)break a;m===q&&(m=null);q=q.return;}m===q&&(m=null);q.sibling.return=q.return;q=q.sibling;}}break;case 19:ck(b,a);ek(a);d&4&&ak(a);break;case 21:break;default:ck(b,
    	a),ek(a);}}function ek(a){var b=a.flags;if(b&2){try{a:{for(var c=a.return;null!==c;){if(Tj(c)){var d=c;break a}c=c.return;}throw Error(p(160));}switch(d.tag){case 5:var e=d.stateNode;d.flags&32&&(ob(e,""),d.flags&=-33);var f=Uj(a);Wj(a,f,e);break;case 3:case 4:var g=d.stateNode.containerInfo,h=Uj(a);Vj(a,h,g);break;default:throw Error(p(161));}}catch(k){W(a,a.return,k);}a.flags&=-3;}b&4096&&(a.flags&=-4097);}function hk(a,b,c){V=a;ik(a);}
    	function ik(a,b,c){for(var d=0!==(a.mode&1);null!==V;){var e=V,f=e.child;if(22===e.tag&&d){var g=null!==e.memoizedState||Jj;if(!g){var h=e.alternate,k=null!==h&&null!==h.memoizedState||U;h=Jj;var l=U;Jj=g;if((U=k)&&!l)for(V=e;null!==V;)g=V,k=g.child,22===g.tag&&null!==g.memoizedState?jk(e):null!==k?(k.return=g,V=k):jk(e);for(;null!==f;)V=f,ik(f),f=f.sibling;V=e;Jj=h;U=l;}kk(a);}else 0!==(e.subtreeFlags&8772)&&null!==f?(f.return=e,V=f):kk(a);}}
    	function kk(a){for(;null!==V;){var b=V;if(0!==(b.flags&8772)){var c=b.alternate;try{if(0!==(b.flags&8772))switch(b.tag){case 0:case 11:case 15:U||Qj(5,b);break;case 1:var d=b.stateNode;if(b.flags&4&&!U)if(null===c)d.componentDidMount();else {var e=b.elementType===b.type?c.memoizedProps:Ci(b.type,c.memoizedProps);d.componentDidUpdate(e,c.memoizedState,d.__reactInternalSnapshotBeforeUpdate);}var f=b.updateQueue;null!==f&&sh(b,f,d);break;case 3:var g=b.updateQueue;if(null!==g){c=null;if(null!==b.child)switch(b.child.tag){case 5:c=
    	b.child.stateNode;break;case 1:c=b.child.stateNode;}sh(b,g,c);}break;case 5:var h=b.stateNode;if(null===c&&b.flags&4){c=h;var k=b.memoizedProps;switch(b.type){case "button":case "input":case "select":case "textarea":k.autoFocus&&c.focus();break;case "img":k.src&&(c.src=k.src);}}break;case 6:break;case 4:break;case 12:break;case 13:if(null===b.memoizedState){var l=b.alternate;if(null!==l){var m=l.memoizedState;if(null!==m){var q=m.dehydrated;null!==q&&bd(q);}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;
    	default:throw Error(p(163));}U||b.flags&512&&Rj(b);}catch(r){W(b,b.return,r);}}if(b===a){V=null;break}c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return;}}function gk(a){for(;null!==V;){var b=V;if(b===a){V=null;break}var c=b.sibling;if(null!==c){c.return=b.return;V=c;break}V=b.return;}}
    	function jk(a){for(;null!==V;){var b=V;try{switch(b.tag){case 0:case 11:case 15:var c=b.return;try{Qj(4,b);}catch(k){W(b,c,k);}break;case 1:var d=b.stateNode;if("function"===typeof d.componentDidMount){var e=b.return;try{d.componentDidMount();}catch(k){W(b,e,k);}}var f=b.return;try{Rj(b);}catch(k){W(b,f,k);}break;case 5:var g=b.return;try{Rj(b);}catch(k){W(b,g,k);}}}catch(k){W(b,b.return,k);}if(b===a){V=null;break}var h=b.sibling;if(null!==h){h.return=b.return;V=h;break}V=b.return;}}
    	var lk=Math.ceil,mk=ua.ReactCurrentDispatcher,nk=ua.ReactCurrentOwner,ok=ua.ReactCurrentBatchConfig,K=0,Q=null,Y=null,Z=0,fj=0,ej=Uf(0),T=0,pk=null,rh=0,qk=0,rk=0,sk=null,tk=null,fk=0,Gj=Infinity,uk=null,Oi=false,Pi=null,Ri=null,vk=false,wk=null,xk=0,yk=0,zk=null,Ak=-1,Bk=0;function R(){return 0!==(K&6)?B():-1!==Ak?Ak:Ak=B()}
    	function yi(a){if(0===(a.mode&1))return 1;if(0!==(K&2)&&0!==Z)return Z&-Z;if(null!==Kg.transition)return 0===Bk&&(Bk=yc()),Bk;a=C;if(0!==a)return a;a=window.event;a=void 0===a?16:jd(a.type);return a}function gi(a,b,c,d){if(50<yk)throw yk=0,zk=null,Error(p(185));Ac(a,c,d);if(0===(K&2)||a!==Q)a===Q&&(0===(K&2)&&(qk|=c),4===T&&Ck(a,Z)),Dk(a,d),1===c&&0===K&&0===(b.mode&1)&&(Gj=B()+500,fg&&jg());}
    	function Dk(a,b){var c=a.callbackNode;wc(a,b);var d=uc(a,a===Q?Z:0);if(0===d)null!==c&&bc(c),a.callbackNode=null,a.callbackPriority=0;else if(b=d&-d,a.callbackPriority!==b){null!=c&&bc(c);if(1===b)0===a.tag?ig(Ek.bind(null,a)):hg(Ek.bind(null,a)),Jf(function(){0===(K&6)&&jg();}),c=null;else {switch(Dc(d)){case 1:c=fc;break;case 4:c=gc;break;case 16:c=hc;break;case 536870912:c=jc;break;default:c=hc;}c=Fk(c,Gk.bind(null,a));}a.callbackPriority=b;a.callbackNode=c;}}
    	function Gk(a,b){Ak=-1;Bk=0;if(0!==(K&6))throw Error(p(327));var c=a.callbackNode;if(Hk()&&a.callbackNode!==c)return null;var d=uc(a,a===Q?Z:0);if(0===d)return null;if(0!==(d&30)||0!==(d&a.expiredLanes)||b)b=Ik(a,d);else {b=d;var e=K;K|=2;var f=Jk();if(Q!==a||Z!==b)uk=null,Gj=B()+500,Kk(a,b);do try{Lk();break}catch(h){Mk(a,h);}while(1);$g();mk.current=f;K=e;null!==Y?b=0:(Q=null,Z=0,b=T);}if(0!==b){2===b&&(e=xc(a),0!==e&&(d=e,b=Nk(a,e)));if(1===b)throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;if(6===b)Ck(a,d);
    	else {e=a.current.alternate;if(0===(d&30)&&!Ok(e)&&(b=Ik(a,d),2===b&&(f=xc(a),0!==f&&(d=f,b=Nk(a,f))),1===b))throw c=pk,Kk(a,0),Ck(a,d),Dk(a,B()),c;a.finishedWork=e;a.finishedLanes=d;switch(b){case 0:case 1:throw Error(p(345));case 2:Pk(a,tk,uk);break;case 3:Ck(a,d);if((d&130023424)===d&&(b=fk+500-B(),10<b)){if(0!==uc(a,0))break;e=a.suspendedLanes;if((e&d)!==d){R();a.pingedLanes|=a.suspendedLanes&e;break}a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),b);break}Pk(a,tk,uk);break;case 4:Ck(a,d);if((d&4194240)===
    	d)break;b=a.eventTimes;for(e=-1;0<d;){var g=31-oc(d);f=1<<g;g=b[g];g>e&&(e=g);d&=~f;}d=e;d=B()-d;d=(120>d?120:480>d?480:1080>d?1080:1920>d?1920:3E3>d?3E3:4320>d?4320:1960*lk(d/1960))-d;if(10<d){a.timeoutHandle=Ff(Pk.bind(null,a,tk,uk),d);break}Pk(a,tk,uk);break;case 5:Pk(a,tk,uk);break;default:throw Error(p(329));}}}Dk(a,B());return a.callbackNode===c?Gk.bind(null,a):null}
    	function Nk(a,b){var c=sk;a.current.memoizedState.isDehydrated&&(Kk(a,b).flags|=256);a=Ik(a,b);2!==a&&(b=tk,tk=c,null!==b&&Fj(b));return a}function Fj(a){null===tk?tk=a:tk.push.apply(tk,a);}
    	function Ok(a){for(var b=a;;){if(b.flags&16384){var c=b.updateQueue;if(null!==c&&(c=c.stores,null!==c))for(var d=0;d<c.length;d++){var e=c[d],f=e.getSnapshot;e=e.value;try{if(!He(f(),e))return !1}catch(g){return  false}}}c=b.child;if(b.subtreeFlags&16384&&null!==c)c.return=b,b=c;else {if(b===a)break;for(;null===b.sibling;){if(null===b.return||b.return===a)return  true;b=b.return;}b.sibling.return=b.return;b=b.sibling;}}return  true}
    	function Ck(a,b){b&=~rk;b&=~qk;a.suspendedLanes|=b;a.pingedLanes&=~b;for(a=a.expirationTimes;0<b;){var c=31-oc(b),d=1<<c;a[c]=-1;b&=~d;}}function Ek(a){if(0!==(K&6))throw Error(p(327));Hk();var b=uc(a,0);if(0===(b&1))return Dk(a,B()),null;var c=Ik(a,b);if(0!==a.tag&&2===c){var d=xc(a);0!==d&&(b=d,c=Nk(a,d));}if(1===c)throw c=pk,Kk(a,0),Ck(a,b),Dk(a,B()),c;if(6===c)throw Error(p(345));a.finishedWork=a.current.alternate;a.finishedLanes=b;Pk(a,tk,uk);Dk(a,B());return null}
    	function Qk(a,b){var c=K;K|=1;try{return a(b)}finally{K=c,0===K&&(Gj=B()+500,fg&&jg());}}function Rk(a){null!==wk&&0===wk.tag&&0===(K&6)&&Hk();var b=K;K|=1;var c=ok.transition,d=C;try{if(ok.transition=null,C=1,a)return a()}finally{C=d,ok.transition=c,K=b,0===(K&6)&&jg();}}function Hj(){fj=ej.current;E(ej);}
    	function Kk(a,b){a.finishedWork=null;a.finishedLanes=0;var c=a.timeoutHandle;-1!==c&&(a.timeoutHandle=-1,Gf(c));if(null!==Y)for(c=Y.return;null!==c;){var d=c;wg(d);switch(d.tag){case 1:d=d.type.childContextTypes;null!==d&&void 0!==d&&$f();break;case 3:zh();E(Wf);E(H);Eh();break;case 5:Bh(d);break;case 4:zh();break;case 13:E(L);break;case 19:E(L);break;case 10:ah(d.type._context);break;case 22:case 23:Hj();}c=c.return;}Q=a;Y=a=Pg(a.current,null);Z=fj=b;T=0;pk=null;rk=qk=rh=0;tk=sk=null;if(null!==fh){for(b=
    	0;b<fh.length;b++)if(c=fh[b],d=c.interleaved,null!==d){c.interleaved=null;var e=d.next,f=c.pending;if(null!==f){var g=f.next;f.next=e;d.next=g;}c.pending=d;}fh=null;}return a}
    	function Mk(a,b){do{var c=Y;try{$g();Fh.current=Rh;if(Ih){for(var d=M.memoizedState;null!==d;){var e=d.queue;null!==e&&(e.pending=null);d=d.next;}Ih=!1;}Hh=0;O=N=M=null;Jh=!1;Kh=0;nk.current=null;if(null===c||null===c.return){T=1;pk=b;Y=null;break}a:{var f=a,g=c.return,h=c,k=b;b=Z;h.flags|=32768;if(null!==k&&"object"===typeof k&&"function"===typeof k.then){var l=k,m=h,q=m.tag;if(0===(m.mode&1)&&(0===q||11===q||15===q)){var r=m.alternate;r?(m.updateQueue=r.updateQueue,m.memoizedState=r.memoizedState,
    	m.lanes=r.lanes):(m.updateQueue=null,m.memoizedState=null);}var y=Ui(g);if(null!==y){y.flags&=-257;Vi(y,g,h,f,b);y.mode&1&&Si(f,l,b);b=y;k=l;var n=b.updateQueue;if(null===n){var t=new Set;t.add(k);b.updateQueue=t;}else n.add(k);break a}else {if(0===(b&1)){Si(f,l,b);tj();break a}k=Error(p(426));}}else if(I&&h.mode&1){var J=Ui(g);if(null!==J){0===(J.flags&65536)&&(J.flags|=256);Vi(J,g,h,f,b);Jg(Ji(k,h));break a}}f=k=Ji(k,h);4!==T&&(T=2);null===sk?sk=[f]:sk.push(f);f=g;do{switch(f.tag){case 3:f.flags|=65536;
    	b&=-b;f.lanes|=b;var x=Ni(f,k,b);ph(f,x);break a;case 1:h=k;var w=f.type,u=f.stateNode;if(0===(f.flags&128)&&("function"===typeof w.getDerivedStateFromError||null!==u&&"function"===typeof u.componentDidCatch&&(null===Ri||!Ri.has(u)))){f.flags|=65536;b&=-b;f.lanes|=b;var F=Qi(f,h,b);ph(f,F);break a}}f=f.return;}while(null!==f)}Sk(c);}catch(na){b=na;Y===c&&null!==c&&(Y=c=c.return);continue}break}while(1)}function Jk(){var a=mk.current;mk.current=Rh;return null===a?Rh:a}
    	function tj(){if(0===T||3===T||2===T)T=4;null===Q||0===(rh&268435455)&&0===(qk&268435455)||Ck(Q,Z);}function Ik(a,b){var c=K;K|=2;var d=Jk();if(Q!==a||Z!==b)uk=null,Kk(a,b);do try{Tk();break}catch(e){Mk(a,e);}while(1);$g();K=c;mk.current=d;if(null!==Y)throw Error(p(261));Q=null;Z=0;return T}function Tk(){for(;null!==Y;)Uk(Y);}function Lk(){for(;null!==Y&&!cc();)Uk(Y);}function Uk(a){var b=Vk(a.alternate,a,fj);a.memoizedProps=a.pendingProps;null===b?Sk(a):Y=b;nk.current=null;}
    	function Sk(a){var b=a;do{var c=b.alternate;a=b.return;if(0===(b.flags&32768)){if(c=Ej(c,b,fj),null!==c){Y=c;return}}else {c=Ij(c,b);if(null!==c){c.flags&=32767;Y=c;return}if(null!==a)a.flags|=32768,a.subtreeFlags=0,a.deletions=null;else {T=6;Y=null;return}}b=b.sibling;if(null!==b){Y=b;return}Y=b=a;}while(null!==b);0===T&&(T=5);}function Pk(a,b,c){var d=C,e=ok.transition;try{ok.transition=null,C=1,Wk(a,b,c,d);}finally{ok.transition=e,C=d;}return null}
    	function Wk(a,b,c,d){do Hk();while(null!==wk);if(0!==(K&6))throw Error(p(327));c=a.finishedWork;var e=a.finishedLanes;if(null===c)return null;a.finishedWork=null;a.finishedLanes=0;if(c===a.current)throw Error(p(177));a.callbackNode=null;a.callbackPriority=0;var f=c.lanes|c.childLanes;Bc(a,f);a===Q&&(Y=Q=null,Z=0);0===(c.subtreeFlags&2064)&&0===(c.flags&2064)||vk||(vk=true,Fk(hc,function(){Hk();return null}));f=0!==(c.flags&15990);if(0!==(c.subtreeFlags&15990)||f){f=ok.transition;ok.transition=null;
    	var g=C;C=1;var h=K;K|=4;nk.current=null;Oj(a,c);dk(c,a);Oe(Df);dd=!!Cf;Df=Cf=null;a.current=c;hk(c);dc();K=h;C=g;ok.transition=f;}else a.current=c;vk&&(vk=false,wk=a,xk=e);f=a.pendingLanes;0===f&&(Ri=null);mc(c.stateNode);Dk(a,B());if(null!==b)for(d=a.onRecoverableError,c=0;c<b.length;c++)e=b[c],d(e.value,{componentStack:e.stack,digest:e.digest});if(Oi)throw Oi=false,a=Pi,Pi=null,a;0!==(xk&1)&&0!==a.tag&&Hk();f=a.pendingLanes;0!==(f&1)?a===zk?yk++:(yk=0,zk=a):yk=0;jg();return null}
    	function Hk(){if(null!==wk){var a=Dc(xk),b=ok.transition,c=C;try{ok.transition=null;C=16>a?16:a;if(null===wk)var d=!1;else {a=wk;wk=null;xk=0;if(0!==(K&6))throw Error(p(331));var e=K;K|=4;for(V=a.current;null!==V;){var f=V,g=f.child;if(0!==(V.flags&16)){var h=f.deletions;if(null!==h){for(var k=0;k<h.length;k++){var l=h[k];for(V=l;null!==V;){var m=V;switch(m.tag){case 0:case 11:case 15:Pj(8,m,f);}var q=m.child;if(null!==q)q.return=m,V=q;else for(;null!==V;){m=V;var r=m.sibling,y=m.return;Sj(m);if(m===
    	l){V=null;break}if(null!==r){r.return=y;V=r;break}V=y;}}}var n=f.alternate;if(null!==n){var t=n.child;if(null!==t){n.child=null;do{var J=t.sibling;t.sibling=null;t=J;}while(null!==t)}}V=f;}}if(0!==(f.subtreeFlags&2064)&&null!==g)g.return=f,V=g;else b:for(;null!==V;){f=V;if(0!==(f.flags&2048))switch(f.tag){case 0:case 11:case 15:Pj(9,f,f.return);}var x=f.sibling;if(null!==x){x.return=f.return;V=x;break b}V=f.return;}}var w=a.current;for(V=w;null!==V;){g=V;var u=g.child;if(0!==(g.subtreeFlags&2064)&&null!==
    	u)u.return=g,V=u;else b:for(g=w;null!==V;){h=V;if(0!==(h.flags&2048))try{switch(h.tag){case 0:case 11:case 15:Qj(9,h);}}catch(na){W(h,h.return,na);}if(h===g){V=null;break b}var F=h.sibling;if(null!==F){F.return=h.return;V=F;break b}V=h.return;}}K=e;jg();if(lc&&"function"===typeof lc.onPostCommitFiberRoot)try{lc.onPostCommitFiberRoot(kc,a);}catch(na){}d=!0;}return d}finally{C=c,ok.transition=b;}}return  false}function Xk(a,b,c){b=Ji(c,b);b=Ni(a,b,1);a=nh(a,b,1);b=R();null!==a&&(Ac(a,1,b),Dk(a,b));}
    	function W(a,b,c){if(3===a.tag)Xk(a,a,c);else for(;null!==b;){if(3===b.tag){Xk(b,a,c);break}else if(1===b.tag){var d=b.stateNode;if("function"===typeof b.type.getDerivedStateFromError||"function"===typeof d.componentDidCatch&&(null===Ri||!Ri.has(d))){a=Ji(c,a);a=Qi(b,a,1);b=nh(b,a,1);a=R();null!==b&&(Ac(b,1,a),Dk(b,a));break}}b=b.return;}}
    	function Ti(a,b,c){var d=a.pingCache;null!==d&&d.delete(b);b=R();a.pingedLanes|=a.suspendedLanes&c;Q===a&&(Z&c)===c&&(4===T||3===T&&(Z&130023424)===Z&&500>B()-fk?Kk(a,0):rk|=c);Dk(a,b);}function Yk(a,b){0===b&&(0===(a.mode&1)?b=1:(b=sc,sc<<=1,0===(sc&130023424)&&(sc=4194304)));var c=R();a=ih(a,b);null!==a&&(Ac(a,b,c),Dk(a,c));}function uj(a){var b=a.memoizedState,c=0;null!==b&&(c=b.retryLane);Yk(a,c);}
    	function bk(a,b){var c=0;switch(a.tag){case 13:var d=a.stateNode;var e=a.memoizedState;null!==e&&(c=e.retryLane);break;case 19:d=a.stateNode;break;default:throw Error(p(314));}null!==d&&d.delete(b);Yk(a,c);}var Vk;
    	Vk=function(a,b,c){if(null!==a)if(a.memoizedProps!==b.pendingProps||Wf.current)dh=true;else {if(0===(a.lanes&c)&&0===(b.flags&128))return dh=false,yj(a,b,c);dh=0!==(a.flags&131072)?true:false;}else dh=false,I&&0!==(b.flags&1048576)&&ug(b,ng,b.index);b.lanes=0;switch(b.tag){case 2:var d=b.type;ij(a,b);a=b.pendingProps;var e=Yf(b,H.current);ch(b,c);e=Nh(null,b,d,a,e,c);var f=Sh();b.flags|=1;"object"===typeof e&&null!==e&&"function"===typeof e.render&&void 0===e.$$typeof?(b.tag=1,b.memoizedState=null,b.updateQueue=
    	null,Zf(d)?(f=true,cg(b)):f=false,b.memoizedState=null!==e.state&&void 0!==e.state?e.state:null,kh(b),e.updater=Ei,b.stateNode=e,e._reactInternals=b,Ii(b,d,a,c),b=jj(null,b,d,true,f,c)):(b.tag=0,I&&f&&vg(b),Xi(null,b,e,c),b=b.child);return b;case 16:d=b.elementType;a:{ij(a,b);a=b.pendingProps;e=d._init;d=e(d._payload);b.type=d;e=b.tag=Zk(d);a=Ci(d,a);switch(e){case 0:b=cj(null,b,d,a,c);break a;case 1:b=hj(null,b,d,a,c);break a;case 11:b=Yi(null,b,d,a,c);break a;case 14:b=$i(null,b,d,Ci(d.type,a),c);break a}throw Error(p(306,
    	d,""));}return b;case 0:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),cj(a,b,d,e,c);case 1:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),hj(a,b,d,e,c);case 3:a:{kj(b);if(null===a)throw Error(p(387));d=b.pendingProps;f=b.memoizedState;e=f.element;lh(a,b);qh(b,d,null,c);var g=b.memoizedState;d=g.element;if(f.isDehydrated)if(f={element:d,isDehydrated:false,cache:g.cache,pendingSuspenseBoundaries:g.pendingSuspenseBoundaries,transitions:g.transitions},b.updateQueue.baseState=
    	f,b.memoizedState=f,b.flags&256){e=Ji(Error(p(423)),b);b=lj(a,b,d,c,e);break a}else if(d!==e){e=Ji(Error(p(424)),b);b=lj(a,b,d,c,e);break a}else for(yg=Lf(b.stateNode.containerInfo.firstChild),xg=b,I=true,zg=null,c=Vg(b,null,d,c),b.child=c;c;)c.flags=c.flags&-3|4096,c=c.sibling;else {Ig();if(d===e){b=Zi(a,b,c);break a}Xi(a,b,d,c);}b=b.child;}return b;case 5:return Ah(b),null===a&&Eg(b),d=b.type,e=b.pendingProps,f=null!==a?a.memoizedProps:null,g=e.children,Ef(d,e)?g=null:null!==f&&Ef(d,f)&&(b.flags|=32),
    	gj(a,b),Xi(a,b,g,c),b.child;case 6:return null===a&&Eg(b),null;case 13:return oj(a,b,c);case 4:return yh(b,b.stateNode.containerInfo),d=b.pendingProps,null===a?b.child=Ug(b,null,d,c):Xi(a,b,d,c),b.child;case 11:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),Yi(a,b,d,e,c);case 7:return Xi(a,b,b.pendingProps,c),b.child;case 8:return Xi(a,b,b.pendingProps.children,c),b.child;case 12:return Xi(a,b,b.pendingProps.children,c),b.child;case 10:a:{d=b.type._context;e=b.pendingProps;f=b.memoizedProps;
    	g=e.value;G(Wg,d._currentValue);d._currentValue=g;if(null!==f)if(He(f.value,g)){if(f.children===e.children&&!Wf.current){b=Zi(a,b,c);break a}}else for(f=b.child,null!==f&&(f.return=b);null!==f;){var h=f.dependencies;if(null!==h){g=f.child;for(var k=h.firstContext;null!==k;){if(k.context===d){if(1===f.tag){k=mh(-1,c&-c);k.tag=2;var l=f.updateQueue;if(null!==l){l=l.shared;var m=l.pending;null===m?k.next=k:(k.next=m.next,m.next=k);l.pending=k;}}f.lanes|=c;k=f.alternate;null!==k&&(k.lanes|=c);bh(f.return,
    	c,b);h.lanes|=c;break}k=k.next;}}else if(10===f.tag)g=f.type===b.type?null:f.child;else if(18===f.tag){g=f.return;if(null===g)throw Error(p(341));g.lanes|=c;h=g.alternate;null!==h&&(h.lanes|=c);bh(g,c,b);g=f.sibling;}else g=f.child;if(null!==g)g.return=f;else for(g=f;null!==g;){if(g===b){g=null;break}f=g.sibling;if(null!==f){f.return=g.return;g=f;break}g=g.return;}f=g;}Xi(a,b,e.children,c);b=b.child;}return b;case 9:return e=b.type,d=b.pendingProps.children,ch(b,c),e=eh(e),d=d(e),b.flags|=1,Xi(a,b,d,c),
    	b.child;case 14:return d=b.type,e=Ci(d,b.pendingProps),e=Ci(d.type,e),$i(a,b,d,e,c);case 15:return bj(a,b,b.type,b.pendingProps,c);case 17:return d=b.type,e=b.pendingProps,e=b.elementType===d?e:Ci(d,e),ij(a,b),b.tag=1,Zf(d)?(a=true,cg(b)):a=false,ch(b,c),Gi(b,d,e),Ii(b,d,e,c),jj(null,b,d,true,a,c);case 19:return xj(a,b,c);case 22:return dj(a,b,c)}throw Error(p(156,b.tag));};function Fk(a,b){return ac(a,b)}
    	function $k(a,b,c,d){this.tag=a;this.key=c;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=0;this.ref=null;this.pendingProps=b;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=d;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null;}function Bg(a,b,c,d){return new $k(a,b,c,d)}function aj(a){a=a.prototype;return !(!a||!a.isReactComponent)}
    	function Zk(a){if("function"===typeof a)return aj(a)?1:0;if(void 0!==a&&null!==a){a=a.$$typeof;if(a===Da)return 11;if(a===Ga)return 14}return 2}
    	function Pg(a,b){var c=a.alternate;null===c?(c=Bg(a.tag,b,a.key,a.mode),c.elementType=a.elementType,c.type=a.type,c.stateNode=a.stateNode,c.alternate=a,a.alternate=c):(c.pendingProps=b,c.type=a.type,c.flags=0,c.subtreeFlags=0,c.deletions=null);c.flags=a.flags&14680064;c.childLanes=a.childLanes;c.lanes=a.lanes;c.child=a.child;c.memoizedProps=a.memoizedProps;c.memoizedState=a.memoizedState;c.updateQueue=a.updateQueue;b=a.dependencies;c.dependencies=null===b?null:{lanes:b.lanes,firstContext:b.firstContext};
    	c.sibling=a.sibling;c.index=a.index;c.ref=a.ref;return c}
    	function Rg(a,b,c,d,e,f){var g=2;d=a;if("function"===typeof a)aj(a)&&(g=1);else if("string"===typeof a)g=5;else a:switch(a){case ya:return Tg(c.children,e,f,b);case za:g=8;e|=8;break;case Aa:return a=Bg(12,c,b,e|2),a.elementType=Aa,a.lanes=f,a;case Ea:return a=Bg(13,c,b,e),a.elementType=Ea,a.lanes=f,a;case Fa:return a=Bg(19,c,b,e),a.elementType=Fa,a.lanes=f,a;case Ia:return pj(c,e,f,b);default:if("object"===typeof a&&null!==a)switch(a.$$typeof){case Ba:g=10;break a;case Ca:g=9;break a;case Da:g=11;
    	break a;case Ga:g=14;break a;case Ha:g=16;d=null;break a}throw Error(p(130,null==a?a:typeof a,""));}b=Bg(g,c,b,e);b.elementType=a;b.type=d;b.lanes=f;return b}function Tg(a,b,c,d){a=Bg(7,a,d,b);a.lanes=c;return a}function pj(a,b,c,d){a=Bg(22,a,d,b);a.elementType=Ia;a.lanes=c;a.stateNode={isHidden:false};return a}function Qg(a,b,c){a=Bg(6,a,null,b);a.lanes=c;return a}
    	function Sg(a,b,c){b=Bg(4,null!==a.children?a.children:[],a.key,b);b.lanes=c;b.stateNode={containerInfo:a.containerInfo,pendingChildren:null,implementation:a.implementation};return b}
    	function al(a,b,c,d,e){this.tag=b;this.containerInfo=a;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=-1;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=zc(0);this.expirationTimes=zc(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=zc(0);this.identifierPrefix=d;this.onRecoverableError=e;this.mutableSourceEagerHydrationData=
    	null;}function bl(a,b,c,d,e,f,g,h,k){a=new al(a,b,c,h,k);1===b?(b=1,true===f&&(b|=8)):b=0;f=Bg(3,null,null,b);a.current=f;f.stateNode=a;f.memoizedState={element:d,isDehydrated:c,cache:null,transitions:null,pendingSuspenseBoundaries:null};kh(f);return a}function cl(a,b,c){var d=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return {$$typeof:wa,key:null==d?null:""+d,children:a,containerInfo:b,implementation:c}}
    	function dl(a){if(!a)return Vf;a=a._reactInternals;a:{if(Vb(a)!==a||1!==a.tag)throw Error(p(170));var b=a;do{switch(b.tag){case 3:b=b.stateNode.context;break a;case 1:if(Zf(b.type)){b=b.stateNode.__reactInternalMemoizedMergedChildContext;break a}}b=b.return;}while(null!==b);throw Error(p(171));}if(1===a.tag){var c=a.type;if(Zf(c))return bg(a,c,b)}return b}
    	function el(a,b,c,d,e,f,g,h,k){a=bl(c,d,true,a,e,f,g,h,k);a.context=dl(null);c=a.current;d=R();e=yi(c);f=mh(d,e);f.callback=void 0!==b&&null!==b?b:null;nh(c,f,e);a.current.lanes=e;Ac(a,e,d);Dk(a,d);return a}function fl(a,b,c,d){var e=b.current,f=R(),g=yi(e);c=dl(c);null===b.context?b.context=c:b.pendingContext=c;b=mh(f,g);b.payload={element:a};d=void 0===d?null:d;null!==d&&(b.callback=d);a=nh(e,b,g);null!==a&&(gi(a,e,g,f),oh(a,e,g));return g}
    	function gl(a){a=a.current;if(!a.child)return null;switch(a.child.tag){case 5:return a.child.stateNode;default:return a.child.stateNode}}function hl(a,b){a=a.memoizedState;if(null!==a&&null!==a.dehydrated){var c=a.retryLane;a.retryLane=0!==c&&c<b?c:b;}}function il(a,b){hl(a,b);(a=a.alternate)&&hl(a,b);}function jl(){return null}var kl="function"===typeof reportError?reportError:function(a){console.error(a);};function ll(a){this._internalRoot=a;}
    	ml.prototype.render=ll.prototype.render=function(a){var b=this._internalRoot;if(null===b)throw Error(p(409));fl(a,b,null,null);};ml.prototype.unmount=ll.prototype.unmount=function(){var a=this._internalRoot;if(null!==a){this._internalRoot=null;var b=a.containerInfo;Rk(function(){fl(null,a,null,null);});b[uf]=null;}};function ml(a){this._internalRoot=a;}
    	ml.prototype.unstable_scheduleHydration=function(a){if(a){var b=Hc();a={blockedOn:null,target:a,priority:b};for(var c=0;c<Qc.length&&0!==b&&b<Qc[c].priority;c++);Qc.splice(c,0,a);0===c&&Vc(a);}};function nl(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType)}function ol(a){return !(!a||1!==a.nodeType&&9!==a.nodeType&&11!==a.nodeType&&(8!==a.nodeType||" react-mount-point-unstable "!==a.nodeValue))}function pl(){}
    	function ql(a,b,c,d,e){if(e){if("function"===typeof d){var f=d;d=function(){var a=gl(g);f.call(a);};}var g=el(b,d,a,0,null,false,false,"",pl);a._reactRootContainer=g;a[uf]=g.current;sf(8===a.nodeType?a.parentNode:a);Rk();return g}for(;e=a.lastChild;)a.removeChild(e);if("function"===typeof d){var h=d;d=function(){var a=gl(k);h.call(a);};}var k=bl(a,0,false,null,null,false,false,"",pl);a._reactRootContainer=k;a[uf]=k.current;sf(8===a.nodeType?a.parentNode:a);Rk(function(){fl(b,k,c,d);});return k}
    	function rl(a,b,c,d,e){var f=c._reactRootContainer;if(f){var g=f;if("function"===typeof e){var h=e;e=function(){var a=gl(g);h.call(a);};}fl(b,g,a,e);}else g=ql(c,b,a,e,d);return gl(g)}Ec=function(a){switch(a.tag){case 3:var b=a.stateNode;if(b.current.memoizedState.isDehydrated){var c=tc(b.pendingLanes);0!==c&&(Cc(b,c|1),Dk(b,B()),0===(K&6)&&(Gj=B()+500,jg()));}break;case 13:Rk(function(){var b=ih(a,1);if(null!==b){var c=R();gi(b,a,1,c);}}),il(a,1);}};
    	Fc=function(a){if(13===a.tag){var b=ih(a,134217728);if(null!==b){var c=R();gi(b,a,134217728,c);}il(a,134217728);}};Gc=function(a){if(13===a.tag){var b=yi(a),c=ih(a,b);if(null!==c){var d=R();gi(c,a,b,d);}il(a,b);}};Hc=function(){return C};Ic=function(a,b){var c=C;try{return C=a,b()}finally{C=c;}};
    	yb=function(a,b,c){switch(b){case "input":bb(a,c);b=c.name;if("radio"===c.type&&null!=b){for(c=a;c.parentNode;)c=c.parentNode;c=c.querySelectorAll("input[name="+JSON.stringify(""+b)+'][type="radio"]');for(b=0;b<c.length;b++){var d=c[b];if(d!==a&&d.form===a.form){var e=Db(d);if(!e)throw Error(p(90));Wa(d);bb(d,e);}}}break;case "textarea":ib(a,c);break;case "select":b=c.value,null!=b&&fb(a,!!c.multiple,b,false);}};Gb=Qk;Hb=Rk;
    	var sl={usingClientEntryPoint:false,Events:[Cb,ue,Db,Eb,Fb,Qk]},tl={findFiberByHostInstance:Wc,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"};
    	var ul={bundleType:tl.bundleType,version:tl.version,rendererPackageName:tl.rendererPackageName,rendererConfig:tl.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ua.ReactCurrentDispatcher,findHostInstanceByFiber:function(a){a=Zb(a);return null===a?null:a.stateNode},findFiberByHostInstance:tl.findFiberByHostInstance||
    	jl,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var vl=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!vl.isDisabled&&vl.supportsFiber)try{kc=vl.inject(ul),lc=vl;}catch(a){}}reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=sl;
    	reactDom_production_min.createPortal=function(a,b){var c=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!nl(b))throw Error(p(200));return cl(a,b,null,c)};reactDom_production_min.createRoot=function(a,b){if(!nl(a))throw Error(p(299));var c=false,d="",e=kl;null!==b&&void 0!==b&&(true===b.unstable_strictMode&&(c=true),void 0!==b.identifierPrefix&&(d=b.identifierPrefix),void 0!==b.onRecoverableError&&(e=b.onRecoverableError));b=bl(a,1,false,null,null,c,false,d,e);a[uf]=b.current;sf(8===a.nodeType?a.parentNode:a);return new ll(b)};
    	reactDom_production_min.findDOMNode=function(a){if(null==a)return null;if(1===a.nodeType)return a;var b=a._reactInternals;if(void 0===b){if("function"===typeof a.render)throw Error(p(188));a=Object.keys(a).join(",");throw Error(p(268,a));}a=Zb(b);a=null===a?null:a.stateNode;return a};reactDom_production_min.flushSync=function(a){return Rk(a)};reactDom_production_min.hydrate=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,true,c)};
    	reactDom_production_min.hydrateRoot=function(a,b,c){if(!nl(a))throw Error(p(405));var d=null!=c&&c.hydratedSources||null,e=false,f="",g=kl;null!==c&&void 0!==c&&(true===c.unstable_strictMode&&(e=true),void 0!==c.identifierPrefix&&(f=c.identifierPrefix),void 0!==c.onRecoverableError&&(g=c.onRecoverableError));b=el(b,null,a,1,null!=c?c:null,e,false,f,g);a[uf]=b.current;sf(a);if(d)for(a=0;a<d.length;a++)c=d[a],e=c._getVersion,e=e(c._source),null==b.mutableSourceEagerHydrationData?b.mutableSourceEagerHydrationData=[c,e]:b.mutableSourceEagerHydrationData.push(c,
    	e);return new ml(b)};reactDom_production_min.render=function(a,b,c){if(!ol(b))throw Error(p(200));return rl(null,a,b,false,c)};reactDom_production_min.unmountComponentAtNode=function(a){if(!ol(a))throw Error(p(40));return a._reactRootContainer?(Rk(function(){rl(null,null,a,!1,function(){a._reactRootContainer=null;a[uf]=null;});}),true):false};reactDom_production_min.unstable_batchedUpdates=Qk;
    	reactDom_production_min.unstable_renderSubtreeIntoContainer=function(a,b,c,d){if(!ol(c))throw Error(p(200));if(null==a||void 0===a._reactInternals)throw Error(p(38));return rl(a,b,c,false,d)};reactDom_production_min.version="18.3.1-next-f1338f8080-20240426";
    	return reactDom_production_min;
    }

    var hasRequiredReactDom;

    function requireReactDom () {
    	if (hasRequiredReactDom) return reactDom.exports;
    	hasRequiredReactDom = 1;

    	function checkDCE() {
    	  /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */
    	  if (
    	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === 'undefined' ||
    	    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== 'function'
    	  ) {
    	    return;
    	  }
    	  try {
    	    // Verify that the code above has been dead code eliminated (DCE'd).
    	    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
    	  } catch (err) {
    	    // DevTools shouldn't crash React, no matter what.
    	    // We should still report in case we break this code.
    	    console.error(err);
    	  }
    	}

    	{
    	  // DCE check should happen before ReactDOM bundle executes so that
    	  // DevTools can report bad minification during injection.
    	  checkDCE();
    	  reactDom.exports = requireReactDom_production_min();
    	}
    	return reactDom.exports;
    }

    var hasRequiredClient;

    function requireClient () {
    	if (hasRequiredClient) return client;
    	hasRequiredClient = 1;

    	var m = requireReactDom();
    	{
    	  client.createRoot = m.createRoot;
    	  client.hydrateRoot = m.hydrateRoot;
    	}
    	return client;
    }

    var clientExports = requireClient();

    var classnames = {exports: {}};

    /*!
    	Copyright (c) 2018 Jed Watson.
    	Licensed under the MIT License (MIT), see
    	http://jedwatson.github.io/classnames
    */

    var hasRequiredClassnames;

    function requireClassnames () {
    	if (hasRequiredClassnames) return classnames.exports;
    	hasRequiredClassnames = 1;
    	(function (module) {
    		/* global define */

    		(function () {

    			var hasOwn = {}.hasOwnProperty;

    			function classNames () {
    				var classes = '';

    				for (var i = 0; i < arguments.length; i++) {
    					var arg = arguments[i];
    					if (arg) {
    						classes = appendClass(classes, parseValue(arg));
    					}
    				}

    				return classes;
    			}

    			function parseValue (arg) {
    				if (typeof arg === 'string' || typeof arg === 'number') {
    					return arg;
    				}

    				if (typeof arg !== 'object') {
    					return '';
    				}

    				if (Array.isArray(arg)) {
    					return classNames.apply(null, arg);
    				}

    				if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes('[native code]')) {
    					return arg.toString();
    				}

    				var classes = '';

    				for (var key in arg) {
    					if (hasOwn.call(arg, key) && arg[key]) {
    						classes = appendClass(classes, key);
    					}
    				}

    				return classes;
    			}

    			function appendClass (value, newClass) {
    				if (!newClass) {
    					return value;
    				}
    			
    				if (value) {
    					return value + ' ' + newClass;
    				}
    			
    				return value + newClass;
    			}

    			if (module.exports) {
    				classNames.default = classNames;
    				module.exports = classNames;
    			} else {
    				window.classNames = classNames;
    			}
    		}()); 
    	} (classnames));
    	return classnames.exports;
    }

    var classnamesExports = requireClassnames();
    var classNames = /*@__PURE__*/getDefaultExportFromCjs(classnamesExports);

    function _extends() {
      return _extends = Object.assign ? Object.assign.bind() : function (n) {
        for (var e = 1; e < arguments.length; e++) {
          var t = arguments[e];
          for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
        }
        return n;
      }, _extends.apply(null, arguments);
    }

    function _typeof(o) {
      "@babel/helpers - typeof";

      return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
        return typeof o;
      } : function (o) {
        return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
      }, _typeof(o);
    }

    var REACT_ELEMENT_TYPE_18 = Symbol.for('react.element');
    var REACT_ELEMENT_TYPE_19 = Symbol.for('react.transitional.element');
    var REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');

    /**
     * Compatible with React 18 or 19 to check if node is a Fragment.
     */
    function isFragment$1(object) {
      return (
        // Base object type
        object && _typeof(object) === 'object' && (
        // React Element type
        object.$$typeof === REACT_ELEMENT_TYPE_18 || object.$$typeof === REACT_ELEMENT_TYPE_19) &&
        // React Fragment type
        object.type === REACT_FRAGMENT_TYPE
      );
    }

    function toArray$2(children) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ret = [];
      React.Children.forEach(children, function (child) {
        if ((child === undefined || child === null) && !option.keepEmpty) {
          return;
        }
        if (Array.isArray(child)) {
          ret = ret.concat(toArray$2(child));
        } else if (isFragment$1(child) && child.props) {
          ret = ret.concat(toArray$2(child.props.children, option));
        } else {
          ret.push(child);
        }
      });
      return ret;
    }

    /* eslint-disable no-console */
    var warned = {};

    /**
     * Pre warning enable you to parse content before console.error.
     * Modify to null will prevent warning.
     */
    var preMessage = function preMessage(fn) {
    };

    /**
     * Warning if condition not match.
     * @param valid Condition
     * @param message Warning message
     * @example
     * ```js
     * warning(false, 'some error'); // print some error
     * warning(true, 'some error'); // print nothing
     * warning(1 === 2, 'some error'); // print some error
     * ```
     */
    function warning$2(valid, message) {
    }

    /** @see Similar to {@link warning} */
    function note(valid, message) {
    }
    function resetWarned() {
      warned = {};
    }
    function call(method, valid, message) {
      if (!valid && !warned[message]) {
        method(false, message);
        warned[message] = true;
      }
    }

    /** @see Same as {@link warning}, but only warn once for the same message */
    function warningOnce(valid, message) {
      call(warning$2, valid, message);
    }

    /** @see Same as {@link warning}, but only warn once for the same message */
    function noteOnce(valid, message) {
      call(note, valid, message);
    }
    warningOnce.preMessage = preMessage;
    warningOnce.resetWarned = resetWarned;
    warningOnce.noteOnce = noteOnce;

    function toPrimitive(t, r) {
      if ("object" != _typeof(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r);
        if ("object" != _typeof(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }

    function toPropertyKey(t) {
      var i = toPrimitive(t, "string");
      return "symbol" == _typeof(i) ? i : i + "";
    }

    function _defineProperty(e, r, t) {
      return (r = toPropertyKey(r)) in e ? Object.defineProperty(e, r, {
        value: t,
        enumerable: true,
        configurable: true,
        writable: true
      }) : e[r] = t, e;
    }

    function ownKeys(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function (r) {
          return Object.getOwnPropertyDescriptor(e, r).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys(Object(t), true).forEach(function (r) {
          _defineProperty(e, r, t[r]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function (r) {
          Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(t, r));
        });
      }
      return e;
    }

    var reactDomExports = requireReactDom();
    var ReactDOM = /*@__PURE__*/getDefaultExportFromCjs(reactDomExports);

    var ReactDOM$1 = /*#__PURE__*/_mergeNamespaces({
        __proto__: null,
        default: ReactDOM
    }, [reactDomExports]);

    function isDOM(node) {
      // https://developer.mozilla.org/en-US/docs/Web/API/Element
      // Since XULElement is also subclass of Element, we only need HTMLElement and SVGElement
      return node instanceof HTMLElement || node instanceof SVGElement;
    }

    /**
     * Retrieves a DOM node via a ref, and does not invoke `findDOMNode`.
     */
    function getDOM(node) {
      if (node && _typeof(node) === 'object' && isDOM(node.nativeElement)) {
        return node.nativeElement;
      }
      if (isDOM(node)) {
        return node;
      }
      return null;
    }

    /**
     * Return if a node is a DOM node. Else will return by `findDOMNode`
     */
    function findDOMNode(node) {
      var domNode = getDOM(node);
      if (domNode) {
        return domNode;
      }
      if (node instanceof React.Component) {
        var _ReactDOM$findDOMNode;
        return (_ReactDOM$findDOMNode = ReactDOM.findDOMNode) === null || _ReactDOM$findDOMNode === void 0 ? void 0 : _ReactDOM$findDOMNode.call(ReactDOM, node);
      }
      return null;
    }

    var reactIs = {exports: {}};

    var reactIs_production_min = {};

    /**
     * @license React
     * react-is.production.min.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */

    var hasRequiredReactIs_production_min;

    function requireReactIs_production_min () {
    	if (hasRequiredReactIs_production_min) return reactIs_production_min;
    	hasRequiredReactIs_production_min = 1;
    var b=Symbol.for("react.element"),c=Symbol.for("react.portal"),d=Symbol.for("react.fragment"),e=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),g=Symbol.for("react.provider"),h=Symbol.for("react.context"),k=Symbol.for("react.server_context"),l=Symbol.for("react.forward_ref"),m=Symbol.for("react.suspense"),n=Symbol.for("react.suspense_list"),p=Symbol.for("react.memo"),q=Symbol.for("react.lazy"),t=Symbol.for("react.offscreen"),u;u=Symbol.for("react.module.reference");
    	function v(a){if("object"===typeof a&&null!==a){var r=a.$$typeof;switch(r){case b:switch(a=a.type,a){case d:case f:case e:case m:case n:return a;default:switch(a=a&&a.$$typeof,a){case k:case h:case l:case q:case p:case g:return a;default:return r}}case c:return r}}}reactIs_production_min.ContextConsumer=h;reactIs_production_min.ContextProvider=g;reactIs_production_min.Element=b;reactIs_production_min.ForwardRef=l;reactIs_production_min.Fragment=d;reactIs_production_min.Lazy=q;reactIs_production_min.Memo=p;reactIs_production_min.Portal=c;reactIs_production_min.Profiler=f;reactIs_production_min.StrictMode=e;reactIs_production_min.Suspense=m;
    	reactIs_production_min.SuspenseList=n;reactIs_production_min.isAsyncMode=function(){return  false};reactIs_production_min.isConcurrentMode=function(){return  false};reactIs_production_min.isContextConsumer=function(a){return v(a)===h};reactIs_production_min.isContextProvider=function(a){return v(a)===g};reactIs_production_min.isElement=function(a){return "object"===typeof a&&null!==a&&a.$$typeof===b};reactIs_production_min.isForwardRef=function(a){return v(a)===l};reactIs_production_min.isFragment=function(a){return v(a)===d};reactIs_production_min.isLazy=function(a){return v(a)===q};reactIs_production_min.isMemo=function(a){return v(a)===p};
    	reactIs_production_min.isPortal=function(a){return v(a)===c};reactIs_production_min.isProfiler=function(a){return v(a)===f};reactIs_production_min.isStrictMode=function(a){return v(a)===e};reactIs_production_min.isSuspense=function(a){return v(a)===m};reactIs_production_min.isSuspenseList=function(a){return v(a)===n};
    	reactIs_production_min.isValidElementType=function(a){return "string"===typeof a||"function"===typeof a||a===d||a===f||a===e||a===m||a===n||a===t||"object"===typeof a&&null!==a&&(a.$$typeof===q||a.$$typeof===p||a.$$typeof===g||a.$$typeof===h||a.$$typeof===l||a.$$typeof===u||void 0!==a.getModuleId)?true:false};reactIs_production_min.typeOf=v;
    	return reactIs_production_min;
    }

    var hasRequiredReactIs;

    function requireReactIs () {
    	if (hasRequiredReactIs) return reactIs.exports;
    	hasRequiredReactIs = 1;

    	{
    	  reactIs.exports = requireReactIs_production_min();
    	}
    	return reactIs.exports;
    }

    var reactIsExports = requireReactIs();

    function useMemo(getValue, condition, shouldUpdate) {
      var cacheRef = reactExports.useRef({});
      if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
        cacheRef.current.value = getValue();
        cacheRef.current.condition = condition;
      }
      return cacheRef.current.value;
    }

    var fillRef = function fillRef(ref, node) {
      if (typeof ref === 'function') {
        ref(node);
      } else if (_typeof(ref) === 'object' && ref && 'current' in ref) {
        ref.current = node;
      }
    };

    /**
     * Merge refs into one ref function to support ref passing.
     */
    var composeRef = function composeRef() {
      for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
        refs[_key] = arguments[_key];
      }
      var refList = refs.filter(Boolean);
      if (refList.length <= 1) {
        return refList[0];
      }
      return function (node) {
        refs.forEach(function (ref) {
          fillRef(ref, node);
        });
      };
    };
    var useComposeRef = function useComposeRef() {
      for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        refs[_key2] = arguments[_key2];
      }
      return useMemo(function () {
        return composeRef.apply(void 0, refs);
      }, refs, function (prev, next) {
        return prev.length !== next.length || prev.every(function (ref, i) {
          return ref !== next[i];
        });
      });
    };
    var supportRef = function supportRef(nodeOrComponent) {
      var _type$prototype, _nodeOrComponent$prot;
      if (!nodeOrComponent) {
        return false;
      }

      // React 19 no need `forwardRef` anymore. So just pass if is a React element.
      if (isReactElement(nodeOrComponent) && nodeOrComponent.props.propertyIsEnumerable('ref')) {
        return true;
      }
      var type = reactIsExports.isMemo(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type;

      // Function component node
      if (typeof type === 'function' && !((_type$prototype = type.prototype) !== null && _type$prototype !== void 0 && _type$prototype.render) && type.$$typeof !== reactIsExports.ForwardRef) {
        return false;
      }

      // Class component
      if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) !== null && _nodeOrComponent$prot !== void 0 && _nodeOrComponent$prot.render) && nodeOrComponent.$$typeof !== reactIsExports.ForwardRef) {
        return false;
      }
      return true;
    };
    function isReactElement(node) {
      return /*#__PURE__*/reactExports.isValidElement(node) && !isFragment$1(node);
    }

    /**
     * In React 19. `ref` is not a property from node.
     * But a property from `props.ref`.
     * To check if `props.ref` exist or fallback to `ref`.
     */
    var getNodeRef = function getNodeRef(node) {
      if (node && isReactElement(node)) {
        var ele = node;

        // Source from:
        // https://github.com/mui/material-ui/blob/master/packages/mui-utils/src/getReactNodeRef/getReactNodeRef.ts
        return ele.props.propertyIsEnumerable('ref') ? ele.props.ref : ele.ref;
      }
      return null;
    };

    var CollectionContext = /*#__PURE__*/reactExports.createContext(null);
    /**
     * Collect all the resize event from children ResizeObserver
     */
    function Collection(_ref) {
      var children = _ref.children,
        onBatchResize = _ref.onBatchResize;
      var resizeIdRef = reactExports.useRef(0);
      var resizeInfosRef = reactExports.useRef([]);
      var onCollectionResize = reactExports.useContext(CollectionContext);
      var onResize = reactExports.useCallback(function (size, element, data) {
        resizeIdRef.current += 1;
        var currentId = resizeIdRef.current;
        resizeInfosRef.current.push({
          size: size,
          element: element,
          data: data
        });
        Promise.resolve().then(function () {
          if (currentId === resizeIdRef.current) {
            onBatchResize === null || onBatchResize === void 0 || onBatchResize(resizeInfosRef.current);
            resizeInfosRef.current = [];
          }
        });

        // Continue bubbling if parent exist
        onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(size, element, data);
      }, [onBatchResize, onCollectionResize]);
      return /*#__PURE__*/reactExports.createElement(CollectionContext.Provider, {
        value: onResize
      }, children);
    }

    /**
     * A collection of shims that provide minimal functionality of the ES6 collections.
     *
     * These implementations are not meant to be used outside of the ResizeObserver
     * modules as they cover only a limited range of use cases.
     */
    /* eslint-disable require-jsdoc, valid-jsdoc */
    var MapShim = (function () {
        if (typeof Map !== 'undefined') {
            return Map;
        }
        /**
         * Returns index in provided array that matches the specified key.
         *
         * @param {Array<Array>} arr
         * @param {*} key
         * @returns {number}
         */
        function getIndex(arr, key) {
            var result = -1;
            arr.some(function (entry, index) {
                if (entry[0] === key) {
                    result = index;
                    return true;
                }
                return false;
            });
            return result;
        }
        return /** @class */ (function () {
            function class_1() {
                this.__entries__ = [];
            }
            Object.defineProperty(class_1.prototype, "size", {
                /**
                 * @returns {boolean}
                 */
                get: function () {
                    return this.__entries__.length;
                },
                enumerable: true,
                configurable: true
            });
            /**
             * @param {*} key
             * @returns {*}
             */
            class_1.prototype.get = function (key) {
                var index = getIndex(this.__entries__, key);
                var entry = this.__entries__[index];
                return entry && entry[1];
            };
            /**
             * @param {*} key
             * @param {*} value
             * @returns {void}
             */
            class_1.prototype.set = function (key, value) {
                var index = getIndex(this.__entries__, key);
                if (~index) {
                    this.__entries__[index][1] = value;
                }
                else {
                    this.__entries__.push([key, value]);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.delete = function (key) {
                var entries = this.__entries__;
                var index = getIndex(entries, key);
                if (~index) {
                    entries.splice(index, 1);
                }
            };
            /**
             * @param {*} key
             * @returns {void}
             */
            class_1.prototype.has = function (key) {
                return !!~getIndex(this.__entries__, key);
            };
            /**
             * @returns {void}
             */
            class_1.prototype.clear = function () {
                this.__entries__.splice(0);
            };
            /**
             * @param {Function} callback
             * @param {*} [ctx=null]
             * @returns {void}
             */
            class_1.prototype.forEach = function (callback, ctx) {
                if (ctx === void 0) { ctx = null; }
                for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                    var entry = _a[_i];
                    callback.call(ctx, entry[1], entry[0]);
                }
            };
            return class_1;
        }());
    })();

    /**
     * Detects whether window and document objects are available in current environment.
     */
    var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

    // Returns global object of a current environment.
    var global$1 = (function () {
        if (typeof global !== 'undefined' && global.Math === Math) {
            return global;
        }
        if (typeof self !== 'undefined' && self.Math === Math) {
            return self;
        }
        if (typeof window !== 'undefined' && window.Math === Math) {
            return window;
        }
        // eslint-disable-next-line no-new-func
        return Function('return this')();
    })();

    /**
     * A shim for the requestAnimationFrame which falls back to the setTimeout if
     * first one is not supported.
     *
     * @returns {number} Requests' identifier.
     */
    var requestAnimationFrame$1 = (function () {
        if (typeof requestAnimationFrame === 'function') {
            // It's required to use a bounded function because IE sometimes throws
            // an "Invalid calling object" error if rAF is invoked without the global
            // object on the left hand side.
            return requestAnimationFrame.bind(global$1);
        }
        return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
    })();

    // Defines minimum timeout before adding a trailing call.
    var trailingTimeout = 2;
    /**
     * Creates a wrapper function which ensures that provided callback will be
     * invoked only once during the specified delay period.
     *
     * @param {Function} callback - Function to be invoked after the delay period.
     * @param {number} delay - Delay after which to invoke callback.
     * @returns {Function}
     */
    function throttle$1 (callback, delay) {
        var leadingCall = false, trailingCall = false, lastCallTime = 0;
        /**
         * Invokes the original callback function and schedules new invocation if
         * the "proxy" was called during current request.
         *
         * @returns {void}
         */
        function resolvePending() {
            if (leadingCall) {
                leadingCall = false;
                callback();
            }
            if (trailingCall) {
                proxy();
            }
        }
        /**
         * Callback invoked after the specified delay. It will further postpone
         * invocation of the original function delegating it to the
         * requestAnimationFrame.
         *
         * @returns {void}
         */
        function timeoutCallback() {
            requestAnimationFrame$1(resolvePending);
        }
        /**
         * Schedules invocation of the original function.
         *
         * @returns {void}
         */
        function proxy() {
            var timeStamp = Date.now();
            if (leadingCall) {
                // Reject immediately following calls.
                if (timeStamp - lastCallTime < trailingTimeout) {
                    return;
                }
                // Schedule new call to be in invoked when the pending one is resolved.
                // This is important for "transitions" which never actually start
                // immediately so there is a chance that we might miss one if change
                // happens amids the pending invocation.
                trailingCall = true;
            }
            else {
                leadingCall = true;
                trailingCall = false;
                setTimeout(timeoutCallback, delay);
            }
            lastCallTime = timeStamp;
        }
        return proxy;
    }

    // Minimum delay before invoking the update of observers.
    var REFRESH_DELAY = 20;
    // A list of substrings of CSS properties used to find transition events that
    // might affect dimensions of observed elements.
    var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
    // Check if MutationObserver is available.
    var mutationObserverSupported = typeof MutationObserver !== 'undefined';
    /**
     * Singleton controller class which handles updates of ResizeObserver instances.
     */
    var ResizeObserverController = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserverController.
         *
         * @private
         */
        function ResizeObserverController() {
            /**
             * Indicates whether DOM listeners have been added.
             *
             * @private {boolean}
             */
            this.connected_ = false;
            /**
             * Tells that controller has subscribed for Mutation Events.
             *
             * @private {boolean}
             */
            this.mutationEventsAdded_ = false;
            /**
             * Keeps reference to the instance of MutationObserver.
             *
             * @private {MutationObserver}
             */
            this.mutationsObserver_ = null;
            /**
             * A list of connected observers.
             *
             * @private {Array<ResizeObserverSPI>}
             */
            this.observers_ = [];
            this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
            this.refresh = throttle$1(this.refresh.bind(this), REFRESH_DELAY);
        }
        /**
         * Adds observer to observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be added.
         * @returns {void}
         */
        ResizeObserverController.prototype.addObserver = function (observer) {
            if (!~this.observers_.indexOf(observer)) {
                this.observers_.push(observer);
            }
            // Add listeners if they haven't been added yet.
            if (!this.connected_) {
                this.connect_();
            }
        };
        /**
         * Removes observer from observers list.
         *
         * @param {ResizeObserverSPI} observer - Observer to be removed.
         * @returns {void}
         */
        ResizeObserverController.prototype.removeObserver = function (observer) {
            var observers = this.observers_;
            var index = observers.indexOf(observer);
            // Remove observer if it's present in registry.
            if (~index) {
                observers.splice(index, 1);
            }
            // Remove listeners if controller has no connected observers.
            if (!observers.length && this.connected_) {
                this.disconnect_();
            }
        };
        /**
         * Invokes the update of observers. It will continue running updates insofar
         * it detects changes.
         *
         * @returns {void}
         */
        ResizeObserverController.prototype.refresh = function () {
            var changesDetected = this.updateObservers_();
            // Continue running updates if changes have been detected as there might
            // be future ones caused by CSS transitions.
            if (changesDetected) {
                this.refresh();
            }
        };
        /**
         * Updates every observer from observers list and notifies them of queued
         * entries.
         *
         * @private
         * @returns {boolean} Returns "true" if any observer has detected changes in
         *      dimensions of it's elements.
         */
        ResizeObserverController.prototype.updateObservers_ = function () {
            // Collect observers that have active observations.
            var activeObservers = this.observers_.filter(function (observer) {
                return observer.gatherActive(), observer.hasActive();
            });
            // Deliver notifications in a separate cycle in order to avoid any
            // collisions between observers, e.g. when multiple instances of
            // ResizeObserver are tracking the same element and the callback of one
            // of them changes content dimensions of the observed target. Sometimes
            // this may result in notifications being blocked for the rest of observers.
            activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
            return activeObservers.length > 0;
        };
        /**
         * Initializes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.connect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already added.
            if (!isBrowser || this.connected_) {
                return;
            }
            // Subscription to the "Transitionend" event is used as a workaround for
            // delayed transitions. This way it's possible to capture at least the
            // final state of an element.
            document.addEventListener('transitionend', this.onTransitionEnd_);
            window.addEventListener('resize', this.refresh);
            if (mutationObserverSupported) {
                this.mutationsObserver_ = new MutationObserver(this.refresh);
                this.mutationsObserver_.observe(document, {
                    attributes: true,
                    childList: true,
                    characterData: true,
                    subtree: true
                });
            }
            else {
                document.addEventListener('DOMSubtreeModified', this.refresh);
                this.mutationEventsAdded_ = true;
            }
            this.connected_ = true;
        };
        /**
         * Removes DOM listeners.
         *
         * @private
         * @returns {void}
         */
        ResizeObserverController.prototype.disconnect_ = function () {
            // Do nothing if running in a non-browser environment or if listeners
            // have been already removed.
            if (!isBrowser || !this.connected_) {
                return;
            }
            document.removeEventListener('transitionend', this.onTransitionEnd_);
            window.removeEventListener('resize', this.refresh);
            if (this.mutationsObserver_) {
                this.mutationsObserver_.disconnect();
            }
            if (this.mutationEventsAdded_) {
                document.removeEventListener('DOMSubtreeModified', this.refresh);
            }
            this.mutationsObserver_ = null;
            this.mutationEventsAdded_ = false;
            this.connected_ = false;
        };
        /**
         * "Transitionend" event handler.
         *
         * @private
         * @param {TransitionEvent} event
         * @returns {void}
         */
        ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
            var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
            // Detect whether transition may affect dimensions of an element.
            var isReflowProperty = transitionKeys.some(function (key) {
                return !!~propertyName.indexOf(key);
            });
            if (isReflowProperty) {
                this.refresh();
            }
        };
        /**
         * Returns instance of the ResizeObserverController.
         *
         * @returns {ResizeObserverController}
         */
        ResizeObserverController.getInstance = function () {
            if (!this.instance_) {
                this.instance_ = new ResizeObserverController();
            }
            return this.instance_;
        };
        /**
         * Holds reference to the controller's instance.
         *
         * @private {ResizeObserverController}
         */
        ResizeObserverController.instance_ = null;
        return ResizeObserverController;
    }());

    /**
     * Defines non-writable/enumerable properties of the provided target object.
     *
     * @param {Object} target - Object for which to define properties.
     * @param {Object} props - Properties to be defined.
     * @returns {Object} Target object.
     */
    var defineConfigurable = (function (target, props) {
        for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
            var key = _a[_i];
            Object.defineProperty(target, key, {
                value: props[key],
                enumerable: false,
                writable: false,
                configurable: true
            });
        }
        return target;
    });

    /**
     * Returns the global object associated with provided element.
     *
     * @param {Object} target
     * @returns {Object}
     */
    var getWindowOf = (function (target) {
        // Assume that the element is an instance of Node, which means that it
        // has the "ownerDocument" property from which we can retrieve a
        // corresponding global object.
        var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
        // Return the local global object if it's not possible extract one from
        // provided element.
        return ownerGlobal || global$1;
    });

    // Placeholder of an empty content rectangle.
    var emptyRect = createRectInit(0, 0, 0, 0);
    /**
     * Converts provided string to a number.
     *
     * @param {number|string} value
     * @returns {number}
     */
    function toFloat(value) {
        return parseFloat(value) || 0;
    }
    /**
     * Extracts borders size from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @param {...string} positions - Borders positions (top, right, ...)
     * @returns {number}
     */
    function getBordersSize(styles) {
        var positions = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            positions[_i - 1] = arguments[_i];
        }
        return positions.reduce(function (size, position) {
            var value = styles['border-' + position + '-width'];
            return size + toFloat(value);
        }, 0);
    }
    /**
     * Extracts paddings sizes from provided styles.
     *
     * @param {CSSStyleDeclaration} styles
     * @returns {Object} Paddings box.
     */
    function getPaddings(styles) {
        var positions = ['top', 'right', 'bottom', 'left'];
        var paddings = {};
        for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
            var position = positions_1[_i];
            var value = styles['padding-' + position];
            paddings[position] = toFloat(value);
        }
        return paddings;
    }
    /**
     * Calculates content rectangle of provided SVG element.
     *
     * @param {SVGGraphicsElement} target - Element content rectangle of which needs
     *      to be calculated.
     * @returns {DOMRectInit}
     */
    function getSVGContentRect(target) {
        var bbox = target.getBBox();
        return createRectInit(0, 0, bbox.width, bbox.height);
    }
    /**
     * Calculates content rectangle of provided HTMLElement.
     *
     * @param {HTMLElement} target - Element for which to calculate the content rectangle.
     * @returns {DOMRectInit}
     */
    function getHTMLElementContentRect(target) {
        // Client width & height properties can't be
        // used exclusively as they provide rounded values.
        var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
        // By this condition we can catch all non-replaced inline, hidden and
        // detached elements. Though elements with width & height properties less
        // than 0.5 will be discarded as well.
        //
        // Without it we would need to implement separate methods for each of
        // those cases and it's not possible to perform a precise and performance
        // effective test for hidden elements. E.g. even jQuery's ':visible' filter
        // gives wrong results for elements with width & height less than 0.5.
        if (!clientWidth && !clientHeight) {
            return emptyRect;
        }
        var styles = getWindowOf(target).getComputedStyle(target);
        var paddings = getPaddings(styles);
        var horizPad = paddings.left + paddings.right;
        var vertPad = paddings.top + paddings.bottom;
        // Computed styles of width & height are being used because they are the
        // only dimensions available to JS that contain non-rounded values. It could
        // be possible to utilize the getBoundingClientRect if only it's data wasn't
        // affected by CSS transformations let alone paddings, borders and scroll bars.
        var width = toFloat(styles.width), height = toFloat(styles.height);
        // Width & height include paddings and borders when the 'border-box' box
        // model is applied (except for IE).
        if (styles.boxSizing === 'border-box') {
            // Following conditions are required to handle Internet Explorer which
            // doesn't include paddings and borders to computed CSS dimensions.
            //
            // We can say that if CSS dimensions + paddings are equal to the "client"
            // properties then it's either IE, and thus we don't need to subtract
            // anything, or an element merely doesn't have paddings/borders styles.
            if (Math.round(width + horizPad) !== clientWidth) {
                width -= getBordersSize(styles, 'left', 'right') + horizPad;
            }
            if (Math.round(height + vertPad) !== clientHeight) {
                height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
            }
        }
        // Following steps can't be applied to the document's root element as its
        // client[Width/Height] properties represent viewport area of the window.
        // Besides, it's as well not necessary as the <html> itself neither has
        // rendered scroll bars nor it can be clipped.
        if (!isDocumentElement(target)) {
            // In some browsers (only in Firefox, actually) CSS width & height
            // include scroll bars size which can be removed at this step as scroll
            // bars are the only difference between rounded dimensions + paddings
            // and "client" properties, though that is not always true in Chrome.
            var vertScrollbar = Math.round(width + horizPad) - clientWidth;
            var horizScrollbar = Math.round(height + vertPad) - clientHeight;
            // Chrome has a rather weird rounding of "client" properties.
            // E.g. for an element with content width of 314.2px it sometimes gives
            // the client width of 315px and for the width of 314.7px it may give
            // 314px. And it doesn't happen all the time. So just ignore this delta
            // as a non-relevant.
            if (Math.abs(vertScrollbar) !== 1) {
                width -= vertScrollbar;
            }
            if (Math.abs(horizScrollbar) !== 1) {
                height -= horizScrollbar;
            }
        }
        return createRectInit(paddings.left, paddings.top, width, height);
    }
    /**
     * Checks whether provided element is an instance of the SVGGraphicsElement.
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    var isSVGGraphicsElement = (function () {
        // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
        // interface.
        if (typeof SVGGraphicsElement !== 'undefined') {
            return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
        }
        // If it's so, then check that element is at least an instance of the
        // SVGElement and that it has the "getBBox" method.
        // eslint-disable-next-line no-extra-parens
        return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
            typeof target.getBBox === 'function'); };
    })();
    /**
     * Checks whether provided element is a document element (<html>).
     *
     * @param {Element} target - Element to be checked.
     * @returns {boolean}
     */
    function isDocumentElement(target) {
        return target === getWindowOf(target).document.documentElement;
    }
    /**
     * Calculates an appropriate content rectangle for provided html or svg element.
     *
     * @param {Element} target - Element content rectangle of which needs to be calculated.
     * @returns {DOMRectInit}
     */
    function getContentRect(target) {
        if (!isBrowser) {
            return emptyRect;
        }
        if (isSVGGraphicsElement(target)) {
            return getSVGContentRect(target);
        }
        return getHTMLElementContentRect(target);
    }
    /**
     * Creates rectangle with an interface of the DOMRectReadOnly.
     * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
     *
     * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
     * @returns {DOMRectReadOnly}
     */
    function createReadOnlyRect(_a) {
        var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        // If DOMRectReadOnly is available use it as a prototype for the rectangle.
        var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
        var rect = Object.create(Constr.prototype);
        // Rectangle's properties are not writable and non-enumerable.
        defineConfigurable(rect, {
            x: x, y: y, width: width, height: height,
            top: y,
            right: x + width,
            bottom: height + y,
            left: x
        });
        return rect;
    }
    /**
     * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
     * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
     *
     * @param {number} x - X coordinate.
     * @param {number} y - Y coordinate.
     * @param {number} width - Rectangle's width.
     * @param {number} height - Rectangle's height.
     * @returns {DOMRectInit}
     */
    function createRectInit(x, y, width, height) {
        return { x: x, y: y, width: width, height: height };
    }

    /**
     * Class that is responsible for computations of the content rectangle of
     * provided DOM element and for keeping track of it's changes.
     */
    var ResizeObservation = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObservation.
         *
         * @param {Element} target - Element to be observed.
         */
        function ResizeObservation(target) {
            /**
             * Broadcasted width of content rectangle.
             *
             * @type {number}
             */
            this.broadcastWidth = 0;
            /**
             * Broadcasted height of content rectangle.
             *
             * @type {number}
             */
            this.broadcastHeight = 0;
            /**
             * Reference to the last observed content rectangle.
             *
             * @private {DOMRectInit}
             */
            this.contentRect_ = createRectInit(0, 0, 0, 0);
            this.target = target;
        }
        /**
         * Updates content rectangle and tells whether it's width or height properties
         * have changed since the last broadcast.
         *
         * @returns {boolean}
         */
        ResizeObservation.prototype.isActive = function () {
            var rect = getContentRect(this.target);
            this.contentRect_ = rect;
            return (rect.width !== this.broadcastWidth ||
                rect.height !== this.broadcastHeight);
        };
        /**
         * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
         * from the corresponding properties of the last observed content rectangle.
         *
         * @returns {DOMRectInit} Last observed content rectangle.
         */
        ResizeObservation.prototype.broadcastRect = function () {
            var rect = this.contentRect_;
            this.broadcastWidth = rect.width;
            this.broadcastHeight = rect.height;
            return rect;
        };
        return ResizeObservation;
    }());

    var ResizeObserverEntry = /** @class */ (function () {
        /**
         * Creates an instance of ResizeObserverEntry.
         *
         * @param {Element} target - Element that is being observed.
         * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
         */
        function ResizeObserverEntry(target, rectInit) {
            var contentRect = createReadOnlyRect(rectInit);
            // According to the specification following properties are not writable
            // and are also not enumerable in the native implementation.
            //
            // Property accessors are not being used as they'd require to define a
            // private WeakMap storage which may cause memory leaks in browsers that
            // don't support this type of collections.
            defineConfigurable(this, { target: target, contentRect: contentRect });
        }
        return ResizeObserverEntry;
    }());

    var ResizeObserverSPI = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback function that is invoked
         *      when one of the observed elements changes it's content dimensions.
         * @param {ResizeObserverController} controller - Controller instance which
         *      is responsible for the updates of observer.
         * @param {ResizeObserver} callbackCtx - Reference to the public
         *      ResizeObserver instance which will be passed to callback function.
         */
        function ResizeObserverSPI(callback, controller, callbackCtx) {
            /**
             * Collection of resize observations that have detected changes in dimensions
             * of elements.
             *
             * @private {Array<ResizeObservation>}
             */
            this.activeObservations_ = [];
            /**
             * Registry of the ResizeObservation instances.
             *
             * @private {Map<Element, ResizeObservation>}
             */
            this.observations_ = new MapShim();
            if (typeof callback !== 'function') {
                throw new TypeError('The callback provided as parameter 1 is not a function.');
            }
            this.callback_ = callback;
            this.controller_ = controller;
            this.callbackCtx_ = callbackCtx;
        }
        /**
         * Starts observing provided element.
         *
         * @param {Element} target - Element to be observed.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.observe = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is already being observed.
            if (observations.has(target)) {
                return;
            }
            observations.set(target, new ResizeObservation(target));
            this.controller_.addObserver(this);
            // Force the update of observations.
            this.controller_.refresh();
        };
        /**
         * Stops observing provided element.
         *
         * @param {Element} target - Element to stop observing.
         * @returns {void}
         */
        ResizeObserverSPI.prototype.unobserve = function (target) {
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            // Do nothing if current environment doesn't have the Element interface.
            if (typeof Element === 'undefined' || !(Element instanceof Object)) {
                return;
            }
            if (!(target instanceof getWindowOf(target).Element)) {
                throw new TypeError('parameter 1 is not of type "Element".');
            }
            var observations = this.observations_;
            // Do nothing if element is not being observed.
            if (!observations.has(target)) {
                return;
            }
            observations.delete(target);
            if (!observations.size) {
                this.controller_.removeObserver(this);
            }
        };
        /**
         * Stops observing all elements.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.disconnect = function () {
            this.clearActive();
            this.observations_.clear();
            this.controller_.removeObserver(this);
        };
        /**
         * Collects observation instances the associated element of which has changed
         * it's content rectangle.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.gatherActive = function () {
            var _this = this;
            this.clearActive();
            this.observations_.forEach(function (observation) {
                if (observation.isActive()) {
                    _this.activeObservations_.push(observation);
                }
            });
        };
        /**
         * Invokes initial callback function with a list of ResizeObserverEntry
         * instances collected from active resize observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.broadcastActive = function () {
            // Do nothing if observer doesn't have active observations.
            if (!this.hasActive()) {
                return;
            }
            var ctx = this.callbackCtx_;
            // Create ResizeObserverEntry instance for every active observation.
            var entries = this.activeObservations_.map(function (observation) {
                return new ResizeObserverEntry(observation.target, observation.broadcastRect());
            });
            this.callback_.call(ctx, entries, ctx);
            this.clearActive();
        };
        /**
         * Clears the collection of active observations.
         *
         * @returns {void}
         */
        ResizeObserverSPI.prototype.clearActive = function () {
            this.activeObservations_.splice(0);
        };
        /**
         * Tells whether observer has active observations.
         *
         * @returns {boolean}
         */
        ResizeObserverSPI.prototype.hasActive = function () {
            return this.activeObservations_.length > 0;
        };
        return ResizeObserverSPI;
    }());

    // Registry of internal observers. If WeakMap is not available use current shim
    // for the Map collection as it has all required methods and because WeakMap
    // can't be fully polyfilled anyway.
    var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
    /**
     * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
     * exposing only those methods and properties that are defined in the spec.
     */
    var ResizeObserver$2 = /** @class */ (function () {
        /**
         * Creates a new instance of ResizeObserver.
         *
         * @param {ResizeObserverCallback} callback - Callback that is invoked when
         *      dimensions of the observed elements change.
         */
        function ResizeObserver(callback) {
            if (!(this instanceof ResizeObserver)) {
                throw new TypeError('Cannot call a class as a function.');
            }
            if (!arguments.length) {
                throw new TypeError('1 argument required, but only 0 present.');
            }
            var controller = ResizeObserverController.getInstance();
            var observer = new ResizeObserverSPI(callback, controller, this);
            observers.set(this, observer);
        }
        return ResizeObserver;
    }());
    // Expose public methods of ResizeObserver.
    [
        'observe',
        'unobserve',
        'disconnect'
    ].forEach(function (method) {
        ResizeObserver$2.prototype[method] = function () {
            var _a;
            return (_a = observers.get(this))[method].apply(_a, arguments);
        };
    });

    var index = (function () {
        // Export existing implementation if available.
        if (typeof global$1.ResizeObserver !== 'undefined') {
            return global$1.ResizeObserver;
        }
        return ResizeObserver$2;
    })();

    // =============================== Const ===============================
    var elementListeners = new Map();
    function onResize(entities) {
      entities.forEach(function (entity) {
        var _elementListeners$get;
        var target = entity.target;
        (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 || _elementListeners$get.forEach(function (listener) {
          return listener(target);
        });
      });
    }

    // Note: ResizeObserver polyfill not support option to measure border-box resize
    var resizeObserver = new index(onResize);

    // ============================== Observe ==============================
    function observe(element, callback) {
      if (!elementListeners.has(element)) {
        elementListeners.set(element, new Set());
        resizeObserver.observe(element);
      }
      elementListeners.get(element).add(callback);
    }
    function unobserve(element, callback) {
      if (elementListeners.has(element)) {
        elementListeners.get(element).delete(callback);
        if (!elementListeners.get(element).size) {
          resizeObserver.unobserve(element);
          elementListeners.delete(element);
        }
      }
    }

    function _classCallCheck(a, n) {
      if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
    }

    function _defineProperties(e, r) {
      for (var t = 0; t < r.length; t++) {
        var o = r[t];
        o.enumerable = o.enumerable || false, o.configurable = true, "value" in o && (o.writable = true), Object.defineProperty(e, toPropertyKey(o.key), o);
      }
    }
    function _createClass(e, r, t) {
      return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
        writable: false
      }), e;
    }

    function _setPrototypeOf(t, e) {
      return _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
        return t.__proto__ = e, t;
      }, _setPrototypeOf(t, e);
    }

    function _inherits(t, e) {
      if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
      t.prototype = Object.create(e && e.prototype, {
        constructor: {
          value: t,
          writable: true,
          configurable: true
        }
      }), Object.defineProperty(t, "prototype", {
        writable: false
      }), e && _setPrototypeOf(t, e);
    }

    function _getPrototypeOf(t) {
      return _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
        return t.__proto__ || Object.getPrototypeOf(t);
      }, _getPrototypeOf(t);
    }

    function _isNativeReflectConstruct() {
      try {
        var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
      } catch (t) {}
      return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
        return !!t;
      })();
    }

    function _assertThisInitialized(e) {
      if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
      return e;
    }

    function _possibleConstructorReturn(t, e) {
      if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
      if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
      return _assertThisInitialized(t);
    }

    function _createSuper(t) {
      var r = _isNativeReflectConstruct();
      return function () {
        var e,
          o = _getPrototypeOf(t);
        if (r) {
          var s = _getPrototypeOf(this).constructor;
          e = Reflect.construct(o, arguments, s);
        } else e = o.apply(this, arguments);
        return _possibleConstructorReturn(this, e);
      };
    }

    /**
     * Fallback to findDOMNode if origin ref do not provide any dom element
     */
    var DomWrapper$1 = /*#__PURE__*/function (_React$Component) {
      _inherits(DomWrapper, _React$Component);
      var _super = _createSuper(DomWrapper);
      function DomWrapper() {
        _classCallCheck(this, DomWrapper);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper, [{
        key: "render",
        value: function render() {
          return this.props.children;
        }
      }]);
      return DomWrapper;
    }(reactExports.Component);

    function SingleObserver(props, ref) {
      var children = props.children,
        disabled = props.disabled;
      var elementRef = reactExports.useRef(null);
      var wrapperRef = reactExports.useRef(null);
      var onCollectionResize = reactExports.useContext(CollectionContext);

      // =========================== Children ===========================
      var isRenderProps = typeof children === 'function';
      var mergedChildren = isRenderProps ? children(elementRef) : children;

      // ============================= Size =============================
      var sizeRef = reactExports.useRef({
        width: -1,
        height: -1,
        offsetWidth: -1,
        offsetHeight: -1
      });

      // ============================= Ref ==============================
      var canRef = !isRenderProps && /*#__PURE__*/reactExports.isValidElement(mergedChildren) && supportRef(mergedChildren);
      var originRef = canRef ? getNodeRef(mergedChildren) : null;
      var mergedRef = useComposeRef(originRef, elementRef);
      var getDom = function getDom() {
        var _elementRef$current;
        return findDOMNode(elementRef.current) || (
        // Support `nativeElement` format
        elementRef.current && _typeof(elementRef.current) === 'object' ? findDOMNode((_elementRef$current = elementRef.current) === null || _elementRef$current === void 0 ? void 0 : _elementRef$current.nativeElement) : null) || findDOMNode(wrapperRef.current);
      };
      reactExports.useImperativeHandle(ref, function () {
        return getDom();
      });

      // =========================== Observe ============================
      var propsRef = reactExports.useRef(props);
      propsRef.current = props;

      // Handler
      var onInternalResize = reactExports.useCallback(function (target) {
        var _propsRef$current = propsRef.current,
          onResize = _propsRef$current.onResize,
          data = _propsRef$current.data;
        var _target$getBoundingCl = target.getBoundingClientRect(),
          width = _target$getBoundingCl.width,
          height = _target$getBoundingCl.height;
        var offsetWidth = target.offsetWidth,
          offsetHeight = target.offsetHeight;

        /**
         * Resize observer trigger when content size changed.
         * In most case we just care about element size,
         * let's use `boundary` instead of `contentRect` here to avoid shaking.
         */
        var fixedWidth = Math.floor(width);
        var fixedHeight = Math.floor(height);
        if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
          var size = {
            width: fixedWidth,
            height: fixedHeight,
            offsetWidth: offsetWidth,
            offsetHeight: offsetHeight
          };
          sizeRef.current = size;

          // IE is strange, right?
          var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
          var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;
          var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
            offsetWidth: mergedOffsetWidth,
            offsetHeight: mergedOffsetHeight
          });

          // Let collection know what happened
          onCollectionResize === null || onCollectionResize === void 0 || onCollectionResize(sizeInfo, target, data);
          if (onResize) {
            // defer the callback but not defer to next frame
            Promise.resolve().then(function () {
              onResize(sizeInfo, target);
            });
          }
        }
      }, []);

      // Dynamic observe
      reactExports.useEffect(function () {
        var currentElement = getDom();
        if (currentElement && !disabled) {
          observe(currentElement, onInternalResize);
        }
        return function () {
          return unobserve(currentElement, onInternalResize);
        };
      }, [elementRef.current, disabled]);

      // ============================ Render ============================
      return /*#__PURE__*/reactExports.createElement(DomWrapper$1, {
        ref: wrapperRef
      }, canRef ? /*#__PURE__*/reactExports.cloneElement(mergedChildren, {
        ref: mergedRef
      }) : mergedChildren);
    }
    var RefSingleObserver = /*#__PURE__*/reactExports.forwardRef(SingleObserver);

    var INTERNAL_PREFIX_KEY = 'rc-observer-key';
    function ResizeObserver$1(props, ref) {
      var children = props.children;
      var childNodes = typeof children === 'function' ? [children] : toArray$2(children);
      return childNodes.map(function (child, index) {
        var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index);
        return /*#__PURE__*/reactExports.createElement(RefSingleObserver, _extends({}, props, {
          key: key,
          ref: index === 0 ? ref : undefined
        }), child);
      });
    }
    var RefResizeObserver = /*#__PURE__*/reactExports.forwardRef(ResizeObserver$1);
    RefResizeObserver.Collection = Collection;

    function omit(obj, fields) {
      var clone = Object.assign({}, obj);
      if (Array.isArray(fields)) {
        fields.forEach(function (key) {
          delete clone[key];
        });
      }
      return clone;
    }

    function _arrayLikeToArray(r, a) {
      (null == a || a > r.length) && (a = r.length);
      for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
      return n;
    }

    function _arrayWithoutHoles(r) {
      if (Array.isArray(r)) return _arrayLikeToArray(r);
    }

    function _iterableToArray(r) {
      if ("undefined" != typeof Symbol && null != r[Symbol.iterator] || null != r["@@iterator"]) return Array.from(r);
    }

    function _unsupportedIterableToArray(r, a) {
      if (r) {
        if ("string" == typeof r) return _arrayLikeToArray(r, a);
        var t = {}.toString.call(r).slice(8, -1);
        return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
      }
    }

    function _nonIterableSpread() {
      throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _toConsumableArray(r) {
      return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread();
    }

    var raf = function raf(callback) {
      return +setTimeout(callback, 16);
    };
    var caf = function caf(num) {
      return clearTimeout(num);
    };
    if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
      raf = function raf(callback) {
        return window.requestAnimationFrame(callback);
      };
      caf = function caf(handle) {
        return window.cancelAnimationFrame(handle);
      };
    }
    var rafUUID = 0;
    var rafIds = new Map();
    function cleanup(id) {
      rafIds.delete(id);
    }
    var wrapperRaf = function wrapperRaf(callback) {
      var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      rafUUID += 1;
      var id = rafUUID;
      function callRef(leftTimes) {
        if (leftTimes === 0) {
          // Clean up
          cleanup(id);

          // Trigger
          callback();
        } else {
          // Next raf
          var realId = raf(function () {
            callRef(leftTimes - 1);
          });

          // Bind real raf id
          rafIds.set(id, realId);
        }
      }
      callRef(times);
      return id;
    };
    wrapperRaf.cancel = function (id) {
      var realId = rafIds.get(id);
      cleanup(id);
      return caf(realId);
    };

    function _arrayWithHoles(r) {
      if (Array.isArray(r)) return r;
    }

    function _iterableToArrayLimit(r, l) {
      var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
      if (null != t) {
        var e,
          n,
          i,
          u,
          a = [],
          f = true,
          o = false;
        try {
          if (i = (t = t.call(r)).next, 0 === l) {
            if (Object(t) !== t) return;
            f = !1;
          } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
        } catch (r) {
          o = true, n = r;
        } finally {
          try {
            if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
          } finally {
            if (o) throw n;
          }
        }
        return a;
      }
    }

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    function _slicedToArray(r, e) {
      return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
    }

    /* eslint-disable */
    // Inspired by https://github.com/garycourt/murmurhash-js
    // Ported from https://github.com/aappleby/smhasher/blob/61a0530f28277f2e850bfc39600ce61d02b518de/src/MurmurHash2.cpp#L37-L86
    function murmur2(str) {
      // 'm' and 'r' are mixing constants generated offline.
      // They're not really 'magic', they just happen to work well.
      // const m = 0x5bd1e995;
      // const r = 24;
      // Initialize the hash
      var h = 0; // Mix 4 bytes at a time into the hash

      var k,
          i = 0,
          len = str.length;

      for (; len >= 4; ++i, len -= 4) {
        k = str.charCodeAt(i) & 0xff | (str.charCodeAt(++i) & 0xff) << 8 | (str.charCodeAt(++i) & 0xff) << 16 | (str.charCodeAt(++i) & 0xff) << 24;
        k =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16);
        k ^=
        /* k >>> r: */
        k >>> 24;
        h =
        /* Math.imul(k, m): */
        (k & 0xffff) * 0x5bd1e995 + ((k >>> 16) * 0xe995 << 16) ^
        /* Math.imul(h, m): */
        (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Handle the last few bytes of the input array


      switch (len) {
        case 3:
          h ^= (str.charCodeAt(i + 2) & 0xff) << 16;

        case 2:
          h ^= (str.charCodeAt(i + 1) & 0xff) << 8;

        case 1:
          h ^= str.charCodeAt(i) & 0xff;
          h =
          /* Math.imul(h, m): */
          (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      } // Do a few final mixes of the hash to ensure the last few
      // bytes are well-incorporated.


      h ^= h >>> 13;
      h =
      /* Math.imul(h, m): */
      (h & 0xffff) * 0x5bd1e995 + ((h >>> 16) * 0xe995 << 16);
      return ((h ^ h >>> 15) >>> 0).toString(36);
    }

    function canUseDom() {
      return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
    }

    function contains(root, n) {
      if (!root) {
        return false;
      }

      // Use native if support
      if (root.contains) {
        return root.contains(n);
      }

      // `document.contains` not support with IE11
      var node = n;
      while (node) {
        if (node === root) {
          return true;
        }
        node = node.parentNode;
      }
      return false;
    }

    var APPEND_ORDER = 'data-rc-order';
    var APPEND_PRIORITY = 'data-rc-priority';
    var MARK_KEY = "rc-util-key";
    var containerCache = new Map();
    function getMark() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        mark = _ref.mark;
      if (mark) {
        return mark.startsWith('data-') ? mark : "data-".concat(mark);
      }
      return MARK_KEY;
    }
    function getContainer(option) {
      if (option.attachTo) {
        return option.attachTo;
      }
      var head = document.querySelector('head');
      return head || document.body;
    }
    function getOrder(prepend) {
      if (prepend === 'queue') {
        return 'prependQueue';
      }
      return prepend ? 'prepend' : 'append';
    }

    /**
     * Find style which inject by rc-util
     */
    function findStyles(container) {
      return Array.from((containerCache.get(container) || container).children).filter(function (node) {
        return node.tagName === 'STYLE';
      });
    }
    function injectCSS(css) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      if (!canUseDom()) {
        return null;
      }
      var csp = option.csp,
        prepend = option.prepend,
        _option$priority = option.priority,
        priority = _option$priority === void 0 ? 0 : _option$priority;
      var mergedOrder = getOrder(prepend);
      var isPrependQueue = mergedOrder === 'prependQueue';
      var styleNode = document.createElement('style');
      styleNode.setAttribute(APPEND_ORDER, mergedOrder);
      if (isPrependQueue && priority) {
        styleNode.setAttribute(APPEND_PRIORITY, "".concat(priority));
      }
      if (csp !== null && csp !== void 0 && csp.nonce) {
        styleNode.nonce = csp === null || csp === void 0 ? void 0 : csp.nonce;
      }
      styleNode.innerHTML = css;
      var container = getContainer(option);
      var firstChild = container.firstChild;
      if (prepend) {
        // If is queue `prepend`, it will prepend first style and then append rest style
        if (isPrependQueue) {
          var existStyle = (option.styles || findStyles(container)).filter(function (node) {
            // Ignore style which not injected by rc-util with prepend
            if (!['prepend', 'prependQueue'].includes(node.getAttribute(APPEND_ORDER))) {
              return false;
            }

            // Ignore style which priority less then new style
            var nodePriority = Number(node.getAttribute(APPEND_PRIORITY) || 0);
            return priority >= nodePriority;
          });
          if (existStyle.length) {
            container.insertBefore(styleNode, existStyle[existStyle.length - 1].nextSibling);
            return styleNode;
          }
        }

        // Use `insertBefore` as `prepend`
        container.insertBefore(styleNode, firstChild);
      } else {
        container.appendChild(styleNode);
      }
      return styleNode;
    }
    function findExistNode(key) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var container = getContainer(option);
      return (option.styles || findStyles(container)).find(function (node) {
        return node.getAttribute(getMark(option)) === key;
      });
    }
    function removeCSS(key) {
      var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var existNode = findExistNode(key, option);
      if (existNode) {
        var container = getContainer(option);
        container.removeChild(existNode);
      }
    }

    /**
     * qiankun will inject `appendChild` to insert into other
     */
    function syncRealContainer(container, option) {
      var cachedRealContainer = containerCache.get(container);

      // Find real container when not cached or cached container removed
      if (!cachedRealContainer || !contains(document, cachedRealContainer)) {
        var placeholderStyle = injectCSS('', option);
        var parentNode = placeholderStyle.parentNode;
        containerCache.set(container, parentNode);
        container.removeChild(placeholderStyle);
      }
    }
    function updateCSS(css, key) {
      var originOption = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var container = getContainer(originOption);
      var styles = findStyles(container);
      var option = _objectSpread2(_objectSpread2({}, originOption), {}, {
        styles: styles
      });

      // Sync real parent
      syncRealContainer(container, option);
      var existNode = findExistNode(key, option);
      if (existNode) {
        var _option$csp, _option$csp2;
        if ((_option$csp = option.csp) !== null && _option$csp !== void 0 && _option$csp.nonce && existNode.nonce !== ((_option$csp2 = option.csp) === null || _option$csp2 === void 0 ? void 0 : _option$csp2.nonce)) {
          var _option$csp3;
          existNode.nonce = (_option$csp3 = option.csp) === null || _option$csp3 === void 0 ? void 0 : _option$csp3.nonce;
        }
        if (existNode.innerHTML !== css) {
          existNode.innerHTML = css;
        }
        return existNode;
      }
      var newNode = injectCSS(css, option);
      newNode.setAttribute(getMark(option), key);
      return newNode;
    }

    function _objectWithoutPropertiesLoose(r, e) {
      if (null == r) return {};
      var t = {};
      for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
        if (e.includes(n)) continue;
        t[n] = r[n];
      }
      return t;
    }

    function _objectWithoutProperties(e, t) {
      if (null == e) return {};
      var o,
        r,
        i = _objectWithoutPropertiesLoose(e, t);
      if (Object.getOwnPropertySymbols) {
        var s = Object.getOwnPropertySymbols(e);
        for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
      }
      return i;
    }

    /**
     * Deeply compares two object literals.
     * @param obj1 object 1
     * @param obj2 object 2
     * @param shallow shallow compare
     * @returns
     */
    function isEqual(obj1, obj2) {
      var shallow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      // https://github.com/mapbox/mapbox-gl-js/pull/5979/files#diff-fde7145050c47cc3a306856efd5f9c3016e86e859de9afbd02c879be5067e58f
      var refSet = new Set();
      function deepEqual(a, b) {
        var level = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
        var circular = refSet.has(a);
        warningOnce(!circular, 'Warning: There may be circular references');
        if (circular) {
          return false;
        }
        if (a === b) {
          return true;
        }
        if (shallow && level > 1) {
          return false;
        }
        refSet.add(a);
        var newLevel = level + 1;
        if (Array.isArray(a)) {
          if (!Array.isArray(b) || a.length !== b.length) {
            return false;
          }
          for (var i = 0; i < a.length; i++) {
            if (!deepEqual(a[i], b[i], newLevel)) {
              return false;
            }
          }
          return true;
        }
        if (a && b && _typeof(a) === 'object' && _typeof(b) === 'object') {
          var keys = Object.keys(a);
          if (keys.length !== Object.keys(b).length) {
            return false;
          }
          return keys.every(function (key) {
            return deepEqual(a[key], b[key], newLevel);
          });
        }
        // other
        return false;
      }
      return deepEqual(obj1, obj2);
    }

    // [times, realValue]

    var SPLIT$1 = '%';

    /** Connect key with `SPLIT` */
    function pathKey(keys) {
      return keys.join(SPLIT$1);
    }
    var Entity = /*#__PURE__*/function () {
      function Entity(instanceId) {
        _classCallCheck(this, Entity);
        _defineProperty(this, "instanceId", void 0);
        /** @private Internal cache map. Do not access this directly */
        _defineProperty(this, "cache", new Map());
        this.instanceId = instanceId;
      }
      _createClass(Entity, [{
        key: "get",
        value: function get(keys) {
          return this.opGet(pathKey(keys));
        }

        /** A fast get cache with `get` concat. */
      }, {
        key: "opGet",
        value: function opGet(keyPathStr) {
          return this.cache.get(keyPathStr) || null;
        }
      }, {
        key: "update",
        value: function update(keys, valueFn) {
          return this.opUpdate(pathKey(keys), valueFn);
        }

        /** A fast get cache with `get` concat. */
      }, {
        key: "opUpdate",
        value: function opUpdate(keyPathStr, valueFn) {
          var prevValue = this.cache.get(keyPathStr);
          var nextValue = valueFn(prevValue);
          if (nextValue === null) {
            this.cache.delete(keyPathStr);
          } else {
            this.cache.set(keyPathStr, nextValue);
          }
        }
      }]);
      return Entity;
    }();

    var ATTR_TOKEN = 'data-token-hash';
    var ATTR_MARK = 'data-css-hash';

    // Mark css-in-js instance in style element
    var CSS_IN_JS_INSTANCE = '__cssinjs_instance__';
    function createCache() {
      var cssinjsInstanceId = Math.random().toString(12).slice(2);

      // Tricky SSR: Move all inline style to the head.
      // PS: We do not recommend tricky mode.
      if (typeof document !== 'undefined' && document.head && document.body) {
        var styles = document.body.querySelectorAll("style[".concat(ATTR_MARK, "]")) || [];
        var firstChild = document.head.firstChild;
        Array.from(styles).forEach(function (style) {
          style[CSS_IN_JS_INSTANCE] = style[CSS_IN_JS_INSTANCE] || cssinjsInstanceId;

          // Not force move if no head
          if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
            document.head.insertBefore(style, firstChild);
          }
        });

        // Deduplicate of moved styles
        var styleHash = {};
        Array.from(document.querySelectorAll("style[".concat(ATTR_MARK, "]"))).forEach(function (style) {
          var hash = style.getAttribute(ATTR_MARK);
          if (styleHash[hash]) {
            if (style[CSS_IN_JS_INSTANCE] === cssinjsInstanceId) {
              var _style$parentNode;
              (_style$parentNode = style.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style);
            }
          } else {
            styleHash[hash] = true;
          }
        });
      }
      return new Entity(cssinjsInstanceId);
    }
    var StyleContext = /*#__PURE__*/reactExports.createContext({
      hashPriority: 'low',
      cache: createCache(),
      defaultCache: true
    });

    // ================================== Cache ==================================

    function sameDerivativeOption(left, right) {
      if (left.length !== right.length) {
        return false;
      }
      for (var i = 0; i < left.length; i++) {
        if (left[i] !== right[i]) {
          return false;
        }
      }
      return true;
    }
    var ThemeCache = /*#__PURE__*/function () {
      function ThemeCache() {
        _classCallCheck(this, ThemeCache);
        _defineProperty(this, "cache", void 0);
        _defineProperty(this, "keys", void 0);
        _defineProperty(this, "cacheCallTimes", void 0);
        this.cache = new Map();
        this.keys = [];
        this.cacheCallTimes = 0;
      }
      _createClass(ThemeCache, [{
        key: "size",
        value: function size() {
          return this.keys.length;
        }
      }, {
        key: "internalGet",
        value: function internalGet(derivativeOption) {
          var _cache2, _cache3;
          var updateCallTimes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
          var cache = {
            map: this.cache
          };
          derivativeOption.forEach(function (derivative) {
            if (!cache) {
              cache = undefined;
            } else {
              var _cache;
              cache = (_cache = cache) === null || _cache === void 0 || (_cache = _cache.map) === null || _cache === void 0 ? void 0 : _cache.get(derivative);
            }
          });
          if ((_cache2 = cache) !== null && _cache2 !== void 0 && _cache2.value && updateCallTimes) {
            cache.value[1] = this.cacheCallTimes++;
          }
          return (_cache3 = cache) === null || _cache3 === void 0 ? void 0 : _cache3.value;
        }
      }, {
        key: "get",
        value: function get(derivativeOption) {
          var _this$internalGet;
          return (_this$internalGet = this.internalGet(derivativeOption, true)) === null || _this$internalGet === void 0 ? void 0 : _this$internalGet[0];
        }
      }, {
        key: "has",
        value: function has(derivativeOption) {
          return !!this.internalGet(derivativeOption);
        }
      }, {
        key: "set",
        value: function set(derivativeOption, value) {
          var _this = this;
          // New cache
          if (!this.has(derivativeOption)) {
            if (this.size() + 1 > ThemeCache.MAX_CACHE_SIZE + ThemeCache.MAX_CACHE_OFFSET) {
              var _this$keys$reduce = this.keys.reduce(function (result, key) {
                  var _result = _slicedToArray(result, 2),
                    callTimes = _result[1];
                  if (_this.internalGet(key)[1] < callTimes) {
                    return [key, _this.internalGet(key)[1]];
                  }
                  return result;
                }, [this.keys[0], this.cacheCallTimes]),
                _this$keys$reduce2 = _slicedToArray(_this$keys$reduce, 1),
                targetKey = _this$keys$reduce2[0];
              this.delete(targetKey);
            }
            this.keys.push(derivativeOption);
          }
          var cache = this.cache;
          derivativeOption.forEach(function (derivative, index) {
            if (index === derivativeOption.length - 1) {
              cache.set(derivative, {
                value: [value, _this.cacheCallTimes++]
              });
            } else {
              var cacheValue = cache.get(derivative);
              if (!cacheValue) {
                cache.set(derivative, {
                  map: new Map()
                });
              } else if (!cacheValue.map) {
                cacheValue.map = new Map();
              }
              cache = cache.get(derivative).map;
            }
          });
        }
      }, {
        key: "deleteByPath",
        value: function deleteByPath(currentCache, derivatives) {
          var cache = currentCache.get(derivatives[0]);
          if (derivatives.length === 1) {
            var _cache$value;
            if (!cache.map) {
              currentCache.delete(derivatives[0]);
            } else {
              currentCache.set(derivatives[0], {
                map: cache.map
              });
            }
            return (_cache$value = cache.value) === null || _cache$value === void 0 ? void 0 : _cache$value[0];
          }
          var result = this.deleteByPath(cache.map, derivatives.slice(1));
          if ((!cache.map || cache.map.size === 0) && !cache.value) {
            currentCache.delete(derivatives[0]);
          }
          return result;
        }
      }, {
        key: "delete",
        value: function _delete(derivativeOption) {
          // If cache exists
          if (this.has(derivativeOption)) {
            this.keys = this.keys.filter(function (item) {
              return !sameDerivativeOption(item, derivativeOption);
            });
            return this.deleteByPath(this.cache, derivativeOption);
          }
          return undefined;
        }
      }]);
      return ThemeCache;
    }();
    _defineProperty(ThemeCache, "MAX_CACHE_SIZE", 20);
    _defineProperty(ThemeCache, "MAX_CACHE_OFFSET", 5);

    var uuid = 0;

    /**
     * Theme with algorithms to derive tokens from design tokens.
     * Use `createTheme` first which will help to manage the theme instance cache.
     */
    var Theme = /*#__PURE__*/function () {
      function Theme(derivatives) {
        _classCallCheck(this, Theme);
        _defineProperty(this, "derivatives", void 0);
        _defineProperty(this, "id", void 0);
        this.derivatives = Array.isArray(derivatives) ? derivatives : [derivatives];
        this.id = uuid;
        if (derivatives.length === 0) {
          warning$2(derivatives.length > 0);
        }
        uuid += 1;
      }
      _createClass(Theme, [{
        key: "getDerivativeToken",
        value: function getDerivativeToken(token) {
          return this.derivatives.reduce(function (result, derivative) {
            return derivative(token, result);
          }, undefined);
        }
      }]);
      return Theme;
    }();

    var cacheThemes = new ThemeCache();

    /**
     * Same as new Theme, but will always return same one if `derivative` not changed.
     */
    function createTheme(derivatives) {
      var derivativeArr = Array.isArray(derivatives) ? derivatives : [derivatives];
      // Create new theme if not exist
      if (!cacheThemes.has(derivativeArr)) {
        cacheThemes.set(derivativeArr, new Theme(derivativeArr));
      }

      // Get theme from cache and return
      return cacheThemes.get(derivativeArr);
    }

    // Create a cache for memo concat

    var resultCache = new WeakMap();
    var RESULT_VALUE = {};
    function memoResult(callback, deps) {
      var current = resultCache;
      for (var i = 0; i < deps.length; i += 1) {
        var dep = deps[i];
        if (!current.has(dep)) {
          current.set(dep, new WeakMap());
        }
        current = current.get(dep);
      }
      if (!current.has(RESULT_VALUE)) {
        current.set(RESULT_VALUE, callback());
      }
      return current.get(RESULT_VALUE);
    }

    // Create a cache here to avoid always loop generate
    var flattenTokenCache = new WeakMap();

    /**
     * Flatten token to string, this will auto cache the result when token not change
     */
    function flattenToken(token) {
      var str = flattenTokenCache.get(token) || '';
      if (!str) {
        Object.keys(token).forEach(function (key) {
          var value = token[key];
          str += key;
          if (value instanceof Theme) {
            str += value.id;
          } else if (value && _typeof(value) === 'object') {
            str += flattenToken(value);
          } else {
            str += value;
          }
        });

        // https://github.com/ant-design/ant-design/issues/48386
        // Should hash the string to avoid style tag name too long
        str = murmur2(str);

        // Put in cache
        flattenTokenCache.set(token, str);
      }
      return str;
    }

    /**
     * Convert derivative token to key string
     */
    function token2key(token, salt) {
      return murmur2("".concat(salt, "_").concat(flattenToken(token)));
    }
    var isClientSide = canUseDom();
    function unit$1(num) {
      if (typeof num === 'number') {
        return "".concat(num, "px");
      }
      return num;
    }
    function toStyleStr(style, tokenKey, styleId) {
      var _objectSpread2$1;
      var customizeAttrs = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
      var plain = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;
      if (plain) {
        return style;
      }
      var attrs = _objectSpread2(_objectSpread2({}, customizeAttrs), {}, (_objectSpread2$1 = {}, _defineProperty(_objectSpread2$1, ATTR_TOKEN, tokenKey), _defineProperty(_objectSpread2$1, ATTR_MARK, styleId), _objectSpread2$1));
      var attrStr = Object.keys(attrs).map(function (attr) {
        var val = attrs[attr];
        return val ? "".concat(attr, "=\"").concat(val, "\"") : null;
      }).filter(function (v) {
        return v;
      }).join(' ');
      return "<style ".concat(attrStr, ">").concat(style, "</style>");
    }

    var token2CSSVar = function token2CSSVar(token) {
      var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      return "--".concat(prefix ? "".concat(prefix, "-") : '').concat(token).replace(/([a-z0-9])([A-Z])/g, '$1-$2').replace(/([A-Z]+)([A-Z][a-z0-9]+)/g, '$1-$2').replace(/([a-z])([A-Z0-9])/g, '$1-$2').toLowerCase();
    };
    var serializeCSSVar = function serializeCSSVar(cssVars, hashId, options) {
      if (!Object.keys(cssVars).length) {
        return '';
      }
      return ".".concat(hashId).concat(options !== null && options !== void 0 && options.scope ? ".".concat(options.scope) : '', "{").concat(Object.entries(cssVars).map(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
          key = _ref2[0],
          value = _ref2[1];
        return "".concat(key, ":").concat(value, ";");
      }).join(''), "}");
    };
    var transformToken = function transformToken(token, themeKey, config) {
      var cssVars = {};
      var result = {};
      Object.entries(token).forEach(function (_ref3) {
        var _config$preserve, _config$ignore;
        var _ref4 = _slicedToArray(_ref3, 2),
          key = _ref4[0],
          value = _ref4[1];
        if (config !== null && config !== void 0 && (_config$preserve = config.preserve) !== null && _config$preserve !== void 0 && _config$preserve[key]) {
          result[key] = value;
        } else if ((typeof value === 'string' || typeof value === 'number') && !(config !== null && config !== void 0 && (_config$ignore = config.ignore) !== null && _config$ignore !== void 0 && _config$ignore[key])) {
          var _config$unitless;
          var cssVar = token2CSSVar(key, config === null || config === void 0 ? void 0 : config.prefix);
          cssVars[cssVar] = typeof value === 'number' && !(config !== null && config !== void 0 && (_config$unitless = config.unitless) !== null && _config$unitless !== void 0 && _config$unitless[key]) ? "".concat(value, "px") : String(value);
          result[key] = "var(".concat(cssVar, ")");
        }
      });
      return [result, serializeCSSVar(cssVars, themeKey, {
        scope: config === null || config === void 0 ? void 0 : config.scope
      })];
    };

    /**
     * Wrap `React.useLayoutEffect` which will not throw warning message in test env
     */
    var useInternalLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;
    var useLayoutEffect = function useLayoutEffect(callback, deps) {
      var firstMountRef = reactExports.useRef(true);
      useInternalLayoutEffect(function () {
        return callback(firstMountRef.current);
      }, deps);

      // We tell react that first mount has passed
      useInternalLayoutEffect(function () {
        firstMountRef.current = false;
        return function () {
          firstMountRef.current = true;
        };
      }, []);
    };
    var useLayoutUpdateEffect = function useLayoutUpdateEffect(callback, deps) {
      useLayoutEffect(function (firstMount) {
        if (!firstMount) {
          return callback();
        }
      }, deps);
    };

    // We need fully clone React function here
    // to avoid webpack warning React 17 do not export `useId`
    var fullClone$3 = _objectSpread2({}, React$1);
    var useInsertionEffect$1 = fullClone$3.useInsertionEffect;
    /**
     * Polyfill `useInsertionEffect` for React < 18
     * @param renderEffect will be executed in `useMemo`, and do not have callback
     * @param effect will be executed in `useLayoutEffect`
     * @param deps
     */
    var useInsertionEffectPolyfill = function useInsertionEffectPolyfill(renderEffect, effect, deps) {
      reactExports.useMemo(renderEffect, deps);
      useLayoutEffect(function () {
        return effect(true);
      }, deps);
    };

    /**
     * Compatible `useInsertionEffect`
     * will use `useInsertionEffect` if React version >= 18,
     * otherwise use `useInsertionEffectPolyfill`.
     */
    var useCompatibleInsertionEffect = useInsertionEffect$1 ? function (renderEffect, effect, deps) {
      return useInsertionEffect$1(function () {
        renderEffect();
        return effect();
      }, deps);
    } : useInsertionEffectPolyfill;

    var fullClone$2 = _objectSpread2({}, React$1);
    var useInsertionEffect = fullClone$2.useInsertionEffect;

    // DO NOT register functions in useEffect cleanup function, or functions that registered will never be called.
    var useCleanupRegister = function useCleanupRegister(deps) {
      var effectCleanups = [];
      var cleanupFlag = false;
      function register(fn) {
        if (cleanupFlag) {
          return;
        }
        effectCleanups.push(fn);
      }
      reactExports.useEffect(function () {
        // Compatible with strict mode
        cleanupFlag = false;
        return function () {
          cleanupFlag = true;
          if (effectCleanups.length) {
            effectCleanups.forEach(function (fn) {
              return fn();
            });
          }
        };
      }, deps);
      return register;
    };
    var useRun = function useRun() {
      return function (fn) {
        fn();
      };
    };

    // Only enable register in React 18
    var useEffectCleanupRegister = typeof useInsertionEffect !== 'undefined' ? useCleanupRegister : useRun;

    function useGlobalCache(prefix, keyPath, cacheFn, onCacheRemove,
    // Add additional effect trigger by `useInsertionEffect`
    onCacheEffect) {
      var _React$useContext = reactExports.useContext(StyleContext),
        globalCache = _React$useContext.cache;
      var fullPath = [prefix].concat(_toConsumableArray(keyPath));
      var fullPathStr = pathKey(fullPath);
      var register = useEffectCleanupRegister([fullPathStr]);
      var buildCache = function buildCache(updater) {
        globalCache.opUpdate(fullPathStr, function (prevCache) {
          var _ref = prevCache || [undefined, undefined],
            _ref2 = _slicedToArray(_ref, 2),
            _ref2$ = _ref2[0],
            times = _ref2$ === void 0 ? 0 : _ref2$,
            cache = _ref2[1];

          // HMR should always ignore cache since developer may change it
          var tmpCache = cache;
          var mergedCache = tmpCache || cacheFn();
          var data = [times, mergedCache];

          // Call updater if need additional logic
          return updater ? updater(data) : data;
        });
      };

      // Create cache
      reactExports.useMemo(function () {
        buildCache();
      }, /* eslint-disable react-hooks/exhaustive-deps */
      [fullPathStr]
      /* eslint-enable */);

      var cacheEntity = globalCache.opGet(fullPathStr);
      var cacheContent = cacheEntity[1];

      // Remove if no need anymore
      useCompatibleInsertionEffect(function () {
        onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
      }, function (polyfill) {
        // It's bad to call build again in effect.
        // But we have to do this since StrictMode will call effect twice
        // which will clear cache on the first time.
        buildCache(function (_ref3) {
          var _ref4 = _slicedToArray(_ref3, 2),
            times = _ref4[0],
            cache = _ref4[1];
          if (polyfill && times === 0) {
            onCacheEffect === null || onCacheEffect === void 0 || onCacheEffect(cacheContent);
          }
          return [times + 1, cache];
        });
        return function () {
          globalCache.opUpdate(fullPathStr, function (prevCache) {
            var _ref5 = prevCache || [],
              _ref6 = _slicedToArray(_ref5, 2),
              _ref6$ = _ref6[0],
              times = _ref6$ === void 0 ? 0 : _ref6$,
              cache = _ref6[1];
            var nextCount = times - 1;
            if (nextCount === 0) {
              // Always remove styles in useEffect callback
              register(function () {
                // With polyfill, registered callback will always be called synchronously
                // But without polyfill, it will be called in effect clean up,
                // And by that time this cache is cleaned up.
                if (polyfill || !globalCache.opGet(fullPathStr)) {
                  onCacheRemove === null || onCacheRemove === void 0 || onCacheRemove(cache, false);
                }
              });
              return null;
            }
            return [times - 1, cache];
          });
        };
      }, [fullPathStr]);
      return cacheContent;
    }

    var EMPTY_OVERRIDE = {};

    // Generate different prefix to make user selector break in production env.
    // This helps developer not to do style override directly on the hash id.
    var hashPrefix = 'css';
    var tokenKeys = new Map();
    function recordCleanToken(tokenKey) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) + 1);
    }
    function removeStyleTags(key, instanceId) {
      if (typeof document !== 'undefined') {
        var styles = document.querySelectorAll("style[".concat(ATTR_TOKEN, "=\"").concat(key, "\"]"));
        styles.forEach(function (style) {
          if (style[CSS_IN_JS_INSTANCE] === instanceId) {
            var _style$parentNode;
            (_style$parentNode = style.parentNode) === null || _style$parentNode === void 0 || _style$parentNode.removeChild(style);
          }
        });
      }
    }
    var TOKEN_THRESHOLD = 0;

    // Remove will check current keys first
    function cleanTokenStyle(tokenKey, instanceId) {
      tokenKeys.set(tokenKey, (tokenKeys.get(tokenKey) || 0) - 1);
      var tokenKeyList = Array.from(tokenKeys.keys());
      var cleanableKeyList = tokenKeyList.filter(function (key) {
        var count = tokenKeys.get(key) || 0;
        return count <= 0;
      });

      // Should keep tokens under threshold for not to insert style too often
      if (tokenKeyList.length - cleanableKeyList.length > TOKEN_THRESHOLD) {
        cleanableKeyList.forEach(function (key) {
          removeStyleTags(key, instanceId);
          tokenKeys.delete(key);
        });
      }
    }
    var getComputedToken$1 = function getComputedToken(originToken, overrideToken, theme, format) {
      var derivativeToken = theme.getDerivativeToken(originToken);

      // Merge with override
      var mergedDerivativeToken = _objectSpread2(_objectSpread2({}, derivativeToken), overrideToken);

      // Format if needed
      if (format) {
        mergedDerivativeToken = format(mergedDerivativeToken);
      }
      return mergedDerivativeToken;
    };
    var TOKEN_PREFIX = 'token';
    /**
     * Cache theme derivative token as global shared one
     * @param theme Theme entity
     * @param tokens List of tokens, used for cache. Please do not dynamic generate object directly
     * @param option Additional config
     * @returns Call Theme.getDerivativeToken(tokenObject) to get token
     */
    function useCacheToken(theme, tokens) {
      var option = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var _useContext = reactExports.useContext(StyleContext),
        instanceId = _useContext.cache.instanceId,
        container = _useContext.container;
      var _option$salt = option.salt,
        salt = _option$salt === void 0 ? '' : _option$salt,
        _option$override = option.override,
        override = _option$override === void 0 ? EMPTY_OVERRIDE : _option$override,
        formatToken = option.formatToken,
        compute = option.getComputedToken,
        cssVar = option.cssVar;

      // Basic - We do basic cache here
      var mergedToken = memoResult(function () {
        return Object.assign.apply(Object, [{}].concat(_toConsumableArray(tokens)));
      }, tokens);
      var tokenStr = flattenToken(mergedToken);
      var overrideTokenStr = flattenToken(override);
      var cssVarStr = cssVar ? flattenToken(cssVar) : '';
      var cachedToken = useGlobalCache(TOKEN_PREFIX, [salt, theme.id, tokenStr, overrideTokenStr, cssVarStr], function () {
        var _cssVar$key;
        var mergedDerivativeToken = compute ? compute(mergedToken, override, theme) : getComputedToken$1(mergedToken, override, theme, formatToken);

        // Replace token value with css variables
        var actualToken = _objectSpread2({}, mergedDerivativeToken);
        var cssVarsStr = '';
        if (!!cssVar) {
          var _transformToken = transformToken(mergedDerivativeToken, cssVar.key, {
            prefix: cssVar.prefix,
            ignore: cssVar.ignore,
            unitless: cssVar.unitless,
            preserve: cssVar.preserve
          });
          var _transformToken2 = _slicedToArray(_transformToken, 2);
          mergedDerivativeToken = _transformToken2[0];
          cssVarsStr = _transformToken2[1];
        }

        // Optimize for `useStyleRegister` performance
        var tokenKey = token2key(mergedDerivativeToken, salt);
        mergedDerivativeToken._tokenKey = tokenKey;
        actualToken._tokenKey = token2key(actualToken, salt);
        var themeKey = (_cssVar$key = cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) !== null && _cssVar$key !== void 0 ? _cssVar$key : tokenKey;
        mergedDerivativeToken._themeKey = themeKey;
        recordCleanToken(themeKey);
        var hashId = "".concat(hashPrefix, "-").concat(murmur2(tokenKey));
        mergedDerivativeToken._hashId = hashId; // Not used

        return [mergedDerivativeToken, hashId, actualToken, cssVarsStr, (cssVar === null || cssVar === void 0 ? void 0 : cssVar.key) || ''];
      }, function (cache) {
        // Remove token will remove all related style
        cleanTokenStyle(cache[0]._themeKey, instanceId);
      }, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 4),
          token = _ref2[0],
          cssVarsStr = _ref2[3];
        if (cssVar && cssVarsStr) {
          var style = updateCSS(cssVarsStr, murmur2("css-variables-".concat(token._themeKey)), {
            mark: ATTR_MARK,
            prepend: 'queue',
            attachTo: container,
            priority: -999
          });
          style[CSS_IN_JS_INSTANCE] = instanceId;

          // Used for `useCacheToken` to remove on batch when token removed
          style.setAttribute(ATTR_TOKEN, token._themeKey);
        }
      });
      return cachedToken;
    }
    var extract$2 = function extract(cache, effectStyles, options) {
      var _cache = _slicedToArray(cache, 5),
        realToken = _cache[2],
        styleStr = _cache[3],
        cssVarKey = _cache[4];
      var _ref3 = options || {},
        plain = _ref3.plain;
      if (!styleStr) {
        return null;
      }
      var styleId = realToken._tokenKey;
      var order = -999;

      // ====================== Style ======================
      // Used for rc-util
      var sharedAttrs = {
        'data-rc-order': 'prependQueue',
        'data-rc-priority': "".concat(order)
      };
      var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
      return [order, styleId, styleText];
    };

    var unitlessKeys = {
      animationIterationCount: 1,
      borderImageOutset: 1,
      borderImageSlice: 1,
      borderImageWidth: 1,
      boxFlex: 1,
      boxFlexGroup: 1,
      boxOrdinalGroup: 1,
      columnCount: 1,
      columns: 1,
      flex: 1,
      flexGrow: 1,
      flexPositive: 1,
      flexShrink: 1,
      flexNegative: 1,
      flexOrder: 1,
      gridRow: 1,
      gridRowEnd: 1,
      gridRowSpan: 1,
      gridRowStart: 1,
      gridColumn: 1,
      gridColumnEnd: 1,
      gridColumnSpan: 1,
      gridColumnStart: 1,
      msGridRow: 1,
      msGridRowSpan: 1,
      msGridColumn: 1,
      msGridColumnSpan: 1,
      fontWeight: 1,
      lineHeight: 1,
      opacity: 1,
      order: 1,
      orphans: 1,
      tabSize: 1,
      widows: 1,
      zIndex: 1,
      zoom: 1,
      WebkitLineClamp: 1,
      // SVG-related properties
      fillOpacity: 1,
      floodOpacity: 1,
      stopOpacity: 1,
      strokeDasharray: 1,
      strokeDashoffset: 1,
      strokeMiterlimit: 1,
      strokeOpacity: 1,
      strokeWidth: 1
    };

    var COMMENT = 'comm';
    var RULESET = 'rule';
    var DECLARATION = 'decl';
    var IMPORT = '@import';
    var KEYFRAMES = '@keyframes';
    var LAYER = '@layer';

    /**
     * @param {number}
     * @return {number}
     */
    var abs = Math.abs;

    /**
     * @param {number}
     * @return {string}
     */
    var from = String.fromCharCode;

    /**
     * @param {string} value
     * @return {string}
     */
    function trim$1 (value) {
    	return value.trim()
    }

    /**
     * @param {string} value
     * @param {(string|RegExp)} pattern
     * @param {string} replacement
     * @return {string}
     */
    function replace (value, pattern, replacement) {
    	return value.replace(pattern, replacement)
    }

    /**
     * @param {string} value
     * @param {string} search
     * @param {number} position
     * @return {number}
     */
    function indexof (value, search, position) {
    	return value.indexOf(search, position)
    }

    /**
     * @param {string} value
     * @param {number} index
     * @return {number}
     */
    function charat (value, index) {
    	return value.charCodeAt(index) | 0
    }

    /**
     * @param {string} value
     * @param {number} begin
     * @param {number} end
     * @return {string}
     */
    function substr (value, begin, end) {
    	return value.slice(begin, end)
    }

    /**
     * @param {string} value
     * @return {number}
     */
    function strlen (value) {
    	return value.length
    }

    /**
     * @param {any[]} value
     * @return {number}
     */
    function sizeof (value) {
    	return value.length
    }

    /**
     * @param {any} value
     * @param {any[]} array
     * @return {any}
     */
    function append (value, array) {
    	return array.push(value), value
    }

    var line = 1;
    var column = 1;
    var length = 0;
    var position = 0;
    var character = 0;
    var characters = '';

    /**
     * @param {string} value
     * @param {object | null} root
     * @param {object | null} parent
     * @param {string} type
     * @param {string[] | string} props
     * @param {object[] | string} children
     * @param {object[]} siblings
     * @param {number} length
     */
    function node (value, root, parent, type, props, children, length, siblings) {
    	return {value: value, root: root, parent: parent, type: type, props: props, children: children, line: line, column: column, length: length, return: '', siblings: siblings}
    }

    /**
     * @return {number}
     */
    function char () {
    	return character
    }

    /**
     * @return {number}
     */
    function prev () {
    	character = position > 0 ? charat(characters, --position) : 0;

    	if (column--, character === 10)
    		column = 1, line--;

    	return character
    }

    /**
     * @return {number}
     */
    function next () {
    	character = position < length ? charat(characters, position++) : 0;

    	if (column++, character === 10)
    		column = 1, line++;

    	return character
    }

    /**
     * @return {number}
     */
    function peek () {
    	return charat(characters, position)
    }

    /**
     * @return {number}
     */
    function caret () {
    	return position
    }

    /**
     * @param {number} begin
     * @param {number} end
     * @return {string}
     */
    function slice (begin, end) {
    	return substr(characters, begin, end)
    }

    /**
     * @param {number} type
     * @return {number}
     */
    function token (type) {
    	switch (type) {
    		// \0 \t \n \r \s whitespace token
    		case 0: case 9: case 10: case 13: case 32:
    			return 5
    		// ! + , / > @ ~ isolate token
    		case 33: case 43: case 44: case 47: case 62: case 64: case 126:
    		// ; { } breakpoint token
    		case 59: case 123: case 125:
    			return 4
    		// : accompanied token
    		case 58:
    			return 3
    		// " ' ( [ opening delimit token
    		case 34: case 39: case 40: case 91:
    			return 2
    		// ) ] closing delimit token
    		case 41: case 93:
    			return 1
    	}

    	return 0
    }

    /**
     * @param {string} value
     * @return {any[]}
     */
    function alloc (value) {
    	return line = column = 1, length = strlen(characters = value), position = 0, []
    }

    /**
     * @param {any} value
     * @return {any}
     */
    function dealloc (value) {
    	return characters = '', value
    }

    /**
     * @param {number} type
     * @return {string}
     */
    function delimit (type) {
    	return trim$1(slice(position - 1, delimiter(type === 91 ? type + 2 : type === 40 ? type + 1 : type)))
    }

    /**
     * @param {number} type
     * @return {string}
     */
    function whitespace$1 (type) {
    	while (character = peek())
    		if (character < 33)
    			next();
    		else
    			break

    	return token(type) > 2 || token(character) > 3 ? '' : ' '
    }

    /**
     * @param {number} index
     * @param {number} count
     * @return {string}
     */
    function escaping (index, count) {
    	while (--count && next())
    		// not 0-9 A-F a-f
    		if (character < 48 || character > 102 || (character > 57 && character < 65) || (character > 70 && character < 97))
    			break

    	return slice(index, caret() + (count < 6 && peek() == 32 && next() == 32))
    }

    /**
     * @param {number} type
     * @return {number}
     */
    function delimiter (type) {
    	while (next())
    		switch (character) {
    			// ] ) " '
    			case type:
    				return position
    			// " '
    			case 34: case 39:
    				if (type !== 34 && type !== 39)
    					delimiter(character);
    				break
    			// (
    			case 40:
    				if (type === 41)
    					delimiter(type);
    				break
    			// \
    			case 92:
    				next();
    				break
    		}

    	return position
    }

    /**
     * @param {number} type
     * @param {number} index
     * @return {number}
     */
    function commenter (type, index) {
    	while (next())
    		// //
    		if (type + character === 47 + 10)
    			break
    		// /*
    		else if (type + character === 42 + 42 && peek() === 47)
    			break

    	return '/*' + slice(index, position - 1) + '*' + from(type === 47 ? type : next())
    }

    /**
     * @param {number} index
     * @return {string}
     */
    function identifier (index) {
    	while (!token(peek()))
    		next();

    	return slice(index, position)
    }

    /**
     * @param {string} value
     * @return {object[]}
     */
    function compile (value) {
    	return dealloc(parse('', null, null, null, [''], value = alloc(value), 0, [0], value))
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {string[]} rule
     * @param {string[]} rules
     * @param {string[]} rulesets
     * @param {number[]} pseudo
     * @param {number[]} points
     * @param {string[]} declarations
     * @return {object}
     */
    function parse (value, root, parent, rule, rules, rulesets, pseudo, points, declarations) {
    	var index = 0;
    	var offset = 0;
    	var length = pseudo;
    	var atrule = 0;
    	var property = 0;
    	var previous = 0;
    	var variable = 1;
    	var scanning = 1;
    	var ampersand = 1;
    	var character = 0;
    	var type = '';
    	var props = rules;
    	var children = rulesets;
    	var reference = rule;
    	var characters = type;

    	while (scanning)
    		switch (previous = character, character = next()) {
    			// (
    			case 40:
    				if (previous != 108 && charat(characters, length - 1) == 58) {
    					if (indexof(characters += replace(delimit(character), '&', '&\f'), '&\f', abs(index ? points[index - 1] : 0)) != -1)
    						ampersand = -1;
    					break
    				}
    			// " ' [
    			case 34: case 39: case 91:
    				characters += delimit(character);
    				break
    			// \t \n \r \s
    			case 9: case 10: case 13: case 32:
    				characters += whitespace$1(previous);
    				break
    			// \
    			case 92:
    				characters += escaping(caret() - 1, 7);
    				continue
    			// /
    			case 47:
    				switch (peek()) {
    					case 42: case 47:
    						append(comment(commenter(next(), caret()), root, parent, declarations), declarations);
    						if ((token(previous || 1) == 5 || token(peek() || 1) == 5) && strlen(characters) && substr(characters, -1, void 0) !== ' ') characters += ' ';
    						break
    					default:
    						characters += '/';
    				}
    				break
    			// {
    			case 123 * variable:
    				points[index++] = strlen(characters) * ampersand;
    			// } ; \0
    			case 125 * variable: case 59: case 0:
    				switch (character) {
    					// \0 }
    					case 0: case 125: scanning = 0;
    					// ;
    					case 59 + offset: if (ampersand == -1) characters = replace(characters, /\f/g, '');
    						if (property > 0 && (strlen(characters) - length || (variable === 0 && previous === 47)))
    							append(property > 32 ? declaration(characters + ';', rule, parent, length - 1, declarations) : declaration(replace(characters, ' ', '') + ';', rule, parent, length - 2, declarations), declarations);
    						break
    					// @ ;
    					case 59: characters += ';';
    					// { rule/at-rule
    					default:
    						append(reference = ruleset(characters, root, parent, index, offset, rules, points, type, props = [], children = [], length, rulesets), rulesets);

    						if (character === 123)
    							if (offset === 0)
    								parse(characters, root, reference, reference, props, rulesets, length, points, children);
    							else {
    								switch (atrule) {
    									// c(ontainer)
    									case 99:
    										if (charat(characters, 3) === 110) break
    									// l(ayer)
    									case 108:
    										if (charat(characters, 2) === 97) break
    									default:
    										offset = 0;
    									// d(ocument) m(edia) s(upports)
    									case 100: case 109: case 115:
    								}
    								if (offset) parse(value, reference, reference, rule && append(ruleset(value, reference, reference, 0, 0, rules, points, type, rules, props = [], length, children), children), rules, children, length, points, rule ? props : children);
    								else parse(characters, reference, reference, reference, [''], children, 0, points, children);
    							}
    				}

    				index = offset = property = 0, variable = ampersand = 1, type = characters = '', length = pseudo;
    				break
    			// :
    			case 58:
    				length = 1 + strlen(characters), property = previous;
    			default:
    				if (variable < 1)
    					if (character == 123)
    						--variable;
    					else if (character == 125 && variable++ == 0 && prev() == 125)
    						continue

    				switch (characters += from(character), character * variable) {
    					// &
    					case 38:
    						ampersand = offset > 0 ? 1 : (characters += '\f', -1);
    						break
    					// ,
    					case 44:
    						points[index++] = (strlen(characters) - 1) * ampersand, ampersand = 1;
    						break
    					// @
    					case 64:
    						// -
    						if (peek() === 45)
    							characters += delimit(next());

    						atrule = peek(), offset = length = strlen(type = characters += identifier(caret())), character++;
    						break
    					// -
    					case 45:
    						if (previous === 45 && strlen(characters) == 2)
    							variable = 0;
    				}
    		}

    	return rulesets
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {number} index
     * @param {number} offset
     * @param {string[]} rules
     * @param {number[]} points
     * @param {string} type
     * @param {string[]} props
     * @param {string[]} children
     * @param {number} length
     * @param {object[]} siblings
     * @return {object}
     */
    function ruleset (value, root, parent, index, offset, rules, points, type, props, children, length, siblings) {
    	var post = offset - 1;
    	var rule = offset === 0 ? rules : [''];
    	var size = sizeof(rule);

    	for (var i = 0, j = 0, k = 0; i < index; ++i)
    		for (var x = 0, y = substr(value, post + 1, post = abs(j = points[i])), z = value; x < size; ++x)
    			if (z = trim$1(j > 0 ? rule[x] + ' ' + y : replace(y, /&\f/g, rule[x])))
    				props[k++] = z;

    	return node(value, root, parent, offset === 0 ? RULESET : type, props, children, length, siblings)
    }

    /**
     * @param {number} value
     * @param {object} root
     * @param {object?} parent
     * @param {object[]} siblings
     * @return {object}
     */
    function comment (value, root, parent, siblings) {
    	return node(value, root, parent, COMMENT, from(char()), substr(value, 2, -2), 0, siblings)
    }

    /**
     * @param {string} value
     * @param {object} root
     * @param {object?} parent
     * @param {number} length
     * @param {object[]} siblings
     * @return {object}
     */
    function declaration (value, root, parent, length, siblings) {
    	return node(value, root, parent, DECLARATION, substr(value, 0, length), substr(value, length + 1, -1), length, siblings)
    }

    /**
     * @param {object[]} children
     * @param {function} callback
     * @return {string}
     */
    function serialize (children, callback) {
    	var output = '';

    	for (var i = 0; i < children.length; i++)
    		output += callback(children[i], i, children, callback) || '';

    	return output
    }

    /**
     * @param {object} element
     * @param {number} index
     * @param {object[]} children
     * @param {function} callback
     * @return {string}
     */
    function stringify$1 (element, index, children, callback) {
    	switch (element.type) {
    		case LAYER: if (element.children.length) break
    		case IMPORT: case DECLARATION: return element.return = element.return || element.value
    		case COMMENT: return ''
    		case KEYFRAMES: return element.return = element.value + '{' + serialize(element.children, callback) + '}'
    		case RULESET: if (!strlen(element.value = element.props.join(','))) return ''
    	}

    	return strlen(children = serialize(element.children, callback)) ? element.return = element.value + '{' + children + '}' : ''
    }

    var ATTR_CACHE_MAP = 'data-ant-cssinjs-cache-path';

    /**
     * This marks style from the css file.
     * Which means not exist in `<style />` tag.
     */
    var CSS_FILE_STYLE = '_FILE_STYLE__';
    var cachePathMap;
    var fromCSSFile = true;
    function prepare() {
      if (!cachePathMap) {
        cachePathMap = {};
        if (canUseDom()) {
          var div = document.createElement('div');
          div.className = ATTR_CACHE_MAP;
          div.style.position = 'fixed';
          div.style.visibility = 'hidden';
          div.style.top = '-9999px';
          document.body.appendChild(div);
          var content = getComputedStyle(div).content || '';
          content = content.replace(/^"/, '').replace(/"$/, '');

          // Fill data
          content.split(';').forEach(function (item) {
            var _item$split = item.split(':'),
              _item$split2 = _slicedToArray(_item$split, 2),
              path = _item$split2[0],
              hash = _item$split2[1];
            cachePathMap[path] = hash;
          });

          // Remove inline record style
          var inlineMapStyle = document.querySelector("style[".concat(ATTR_CACHE_MAP, "]"));
          if (inlineMapStyle) {
            var _inlineMapStyle$paren;
            fromCSSFile = false;
            (_inlineMapStyle$paren = inlineMapStyle.parentNode) === null || _inlineMapStyle$paren === void 0 || _inlineMapStyle$paren.removeChild(inlineMapStyle);
          }
          document.body.removeChild(div);
        }
      }
    }
    function existPath(path) {
      prepare();
      return !!cachePathMap[path];
    }
    function getStyleAndHash(path) {
      var hash = cachePathMap[path];
      var styleStr = null;
      if (hash && canUseDom()) {
        if (fromCSSFile) {
          styleStr = CSS_FILE_STYLE;
        } else {
          var _style = document.querySelector("style[".concat(ATTR_MARK, "=\"").concat(cachePathMap[path], "\"]"));
          if (_style) {
            styleStr = _style.innerHTML;
          } else {
            // Clean up since not exist anymore
            delete cachePathMap[path];
          }
        }
      }
      return [styleStr, hash];
    }

    var SKIP_CHECK = '_skip_check_';
    var MULTI_VALUE = '_multi_value_';
    // ============================================================================
    // ==                                 Parser                                 ==
    // ============================================================================
    // Preprocessor style content to browser support one
    function normalizeStyle(styleStr) {
      var serialized = serialize(compile(styleStr), stringify$1);
      return serialized.replace(/\{%%%\:[^;];}/g, ';');
    }
    function isCompoundCSSProperty(value) {
      return _typeof(value) === 'object' && value && (SKIP_CHECK in value || MULTI_VALUE in value);
    }

    //  hash 
    function injectSelectorHash(key, hashId, hashPriority) {
      if (!hashId) {
        return key;
      }
      var hashClassName = ".".concat(hashId);
      var hashSelector = hashPriority === 'low' ? ":where(".concat(hashClassName, ")") : hashClassName;

      //  hashId
      var keys = key.split(',').map(function (k) {
        var _firstPath$match;
        var fullPath = k.trim().split(/\s+/);

        //  Selector  HTML Element
        var firstPath = fullPath[0] || '';
        var htmlElement = ((_firstPath$match = firstPath.match(/^\w+/)) === null || _firstPath$match === void 0 ? void 0 : _firstPath$match[0]) || '';
        firstPath = "".concat(htmlElement).concat(hashSelector).concat(firstPath.slice(htmlElement.length));
        return [firstPath].concat(_toConsumableArray(fullPath.slice(1))).join(' ');
      });
      return keys.join(',');
    }
    // Parse CSSObject to style content
    var parseStyle = function parseStyle(interpolation) {
      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {
          root: true,
          parentSelectors: []
        },
        root = _ref.root,
        injectHash = _ref.injectHash,
        parentSelectors = _ref.parentSelectors;
      var hashId = config.hashId,
        layer = config.layer;
        config.path;
        var hashPriority = config.hashPriority,
        _config$transformers = config.transformers,
        transformers = _config$transformers === void 0 ? [] : _config$transformers;
        config.linters;
      var styleStr = '';
      var effectStyle = {};
      function parseKeyframes(keyframes) {
        var animationName = keyframes.getName(hashId);
        if (!effectStyle[animationName]) {
          var _parseStyle = parseStyle(keyframes.style, config, {
              root: false,
              parentSelectors: parentSelectors
            }),
            _parseStyle2 = _slicedToArray(_parseStyle, 1),
            _parsedStr = _parseStyle2[0];
          effectStyle[animationName] = "@keyframes ".concat(keyframes.getName(hashId)).concat(_parsedStr);
        }
      }
      function flattenList(list) {
        var fullList = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
        list.forEach(function (item) {
          if (Array.isArray(item)) {
            flattenList(item, fullList);
          } else if (item) {
            fullList.push(item);
          }
        });
        return fullList;
      }
      var flattenStyleList = flattenList(Array.isArray(interpolation) ? interpolation : [interpolation]);
      flattenStyleList.forEach(function (originStyle) {
        // Only root level can use raw string
        var style = typeof originStyle === 'string' && !root ? {} : originStyle;
        if (typeof style === 'string') {
          styleStr += "".concat(style, "\n");
        } else if (style._keyframe) {
          // Keyframe
          parseKeyframes(style);
        } else {
          var mergedStyle = transformers.reduce(function (prev, trans) {
            var _trans$visit;
            return (trans === null || trans === void 0 || (_trans$visit = trans.visit) === null || _trans$visit === void 0 ? void 0 : _trans$visit.call(trans, prev)) || prev;
          }, style);

          // Normal CSSObject
          Object.keys(mergedStyle).forEach(function (key) {
            var value = mergedStyle[key];
            if (_typeof(value) === 'object' && value && (key !== 'animationName' || !value._keyframe) && !isCompoundCSSProperty(value)) {
              var subInjectHash = false;

              // 
              var mergedKey = key.trim();
              // Whether treat child as root. In most case it is false.
              var nextRoot = false;

              // 
              if ((root || injectHash) && hashId) {
                if (mergedKey.startsWith('@')) {
                  //  hashId
                  subInjectHash = true;
                } else if (mergedKey === '&') {
                  //  root selector  &
                  mergedKey = injectSelectorHash('', hashId, hashPriority);
                } else {
                  //  hashId
                  mergedKey = injectSelectorHash(key, hashId, hashPriority);
                }
              } else if (root && !hashId && (mergedKey === '&' || mergedKey === '')) {
                // In case of `{ '&': { a: { color: 'red' } } }` or `{ '': { a: { color: 'red' } } }` without hashId,
                // we will get `&{a:{color:red;}}` or `{a:{color:red;}}` string for stylis to compile.
                // But it does not conform to stylis syntax,
                // and finally we will get `{color:red;}` as css, which is wrong.
                // So we need to remove key in root, and treat child `{ a: { color: 'red' } }` as root.
                mergedKey = '';
                nextRoot = true;
              }
              var _parseStyle3 = parseStyle(value, config, {
                  root: nextRoot,
                  injectHash: subInjectHash,
                  parentSelectors: [].concat(_toConsumableArray(parentSelectors), [mergedKey])
                }),
                _parseStyle4 = _slicedToArray(_parseStyle3, 2),
                _parsedStr2 = _parseStyle4[0],
                childEffectStyle = _parseStyle4[1];
              effectStyle = _objectSpread2(_objectSpread2({}, effectStyle), childEffectStyle);
              styleStr += "".concat(mergedKey).concat(_parsedStr2);
            } else {
              var _value;
              function appendStyle(cssKey, cssValue) {

                // 
                var styleName = cssKey.replace(/[A-Z]/g, function (match) {
                  return "-".concat(match.toLowerCase());
                });

                // Auto suffix with px
                var formatValue = cssValue;
                if (!unitlessKeys[cssKey] && typeof formatValue === 'number' && formatValue !== 0) {
                  formatValue = "".concat(formatValue, "px");
                }

                // handle animationName & Keyframe value
                if (cssKey === 'animationName' && cssValue !== null && cssValue !== void 0 && cssValue._keyframe) {
                  parseKeyframes(cssValue);
                  formatValue = cssValue.getName(hashId);
                }
                styleStr += "".concat(styleName, ":").concat(formatValue, ";");
              }
              var actualValue = (_value = value === null || value === void 0 ? void 0 : value.value) !== null && _value !== void 0 ? _value : value;
              if (_typeof(value) === 'object' && value !== null && value !== void 0 && value[MULTI_VALUE] && Array.isArray(actualValue)) {
                actualValue.forEach(function (item) {
                  appendStyle(key, item);
                });
              } else {
                appendStyle(key, actualValue);
              }
            }
          });
        }
      });
      if (!root) {
        styleStr = "{".concat(styleStr, "}");
      } else if (layer) {
        // fixme: https://github.com/thysultan/stylis/pull/339
        if (styleStr) {
          styleStr = "@layer ".concat(layer.name, " {").concat(styleStr, "}");
        }
        if (layer.dependencies) {
          effectStyle["@layer ".concat(layer.name)] = layer.dependencies.map(function (deps) {
            return "@layer ".concat(deps, ", ").concat(layer.name, ";");
          }).join('\n');
        }
      }
      return [styleStr, effectStyle];
    };

    // ============================================================================
    // ==                                Register                                ==
    // ============================================================================
    function uniqueHash(path, styleStr) {
      return murmur2("".concat(path.join('%')).concat(styleStr));
    }
    function Empty() {
      return null;
    }
    var STYLE_PREFIX = 'style';
    /**
     * Register a style to the global style sheet.
     */
    function useStyleRegister(info, styleFn) {
      var token = info.token,
        path = info.path,
        hashId = info.hashId,
        layer = info.layer,
        nonce = info.nonce,
        clientOnly = info.clientOnly,
        _info$order = info.order,
        order = _info$order === void 0 ? 0 : _info$order;
      var _React$useContext = reactExports.useContext(StyleContext),
        autoClear = _React$useContext.autoClear;
        _React$useContext.mock;
        var defaultCache = _React$useContext.defaultCache,
        hashPriority = _React$useContext.hashPriority,
        container = _React$useContext.container,
        ssrInline = _React$useContext.ssrInline,
        transformers = _React$useContext.transformers,
        linters = _React$useContext.linters,
        cache = _React$useContext.cache,
        enableLayer = _React$useContext.layer;
      var tokenKey = token._tokenKey;
      var fullPath = [tokenKey];
      if (enableLayer) {
        fullPath.push('layer');
      }
      fullPath.push.apply(fullPath, _toConsumableArray(path));

      // Check if need insert style
      var isMergedClientSide = isClientSide;
      var _useGlobalCache = useGlobalCache(STYLE_PREFIX, fullPath,
        // Create cache if needed
        function () {
          var cachePath = fullPath.join('|');

          // Get style from SSR inline style directly
          if (existPath(cachePath)) {
            var _getStyleAndHash = getStyleAndHash(cachePath),
              _getStyleAndHash2 = _slicedToArray(_getStyleAndHash, 2),
              inlineCacheStyleStr = _getStyleAndHash2[0],
              styleHash = _getStyleAndHash2[1];
            if (inlineCacheStyleStr) {
              return [inlineCacheStyleStr, tokenKey, styleHash, {}, clientOnly, order];
            }
          }

          // Generate style
          var styleObj = styleFn();
          var _parseStyle5 = parseStyle(styleObj, {
              hashId: hashId,
              hashPriority: hashPriority,
              layer: enableLayer ? layer : undefined,
              path: path.join('-'),
              transformers: transformers,
              linters: linters
            }),
            _parseStyle6 = _slicedToArray(_parseStyle5, 2),
            parsedStyle = _parseStyle6[0],
            effectStyle = _parseStyle6[1];
          var styleStr = normalizeStyle(parsedStyle);
          var styleId = uniqueHash(fullPath, styleStr);
          return [styleStr, tokenKey, styleId, effectStyle, clientOnly, order];
        },
        // Remove cache if no need
        function (_ref2, fromHMR) {
          var _ref3 = _slicedToArray(_ref2, 3),
            styleId = _ref3[2];
          if ((fromHMR || autoClear) && isClientSide) {
            removeCSS(styleId, {
              mark: ATTR_MARK
            });
          }
        },
        // Effect: Inject style here
        function (_ref4) {
          var _ref5 = _slicedToArray(_ref4, 4),
            styleStr = _ref5[0];
            _ref5[1];
            var styleId = _ref5[2],
            effectStyle = _ref5[3];
          if (isMergedClientSide && styleStr !== CSS_FILE_STYLE) {
            var mergedCSSConfig = {
              mark: ATTR_MARK,
              prepend: enableLayer ? false : 'queue',
              attachTo: container,
              priority: order
            };
            var nonceStr = typeof nonce === 'function' ? nonce() : nonce;
            if (nonceStr) {
              mergedCSSConfig.csp = {
                nonce: nonceStr
              };
            }

            // ================= Split Effect Style =================
            // We will split effectStyle here since @layer should be at the top level
            var effectLayerKeys = [];
            var effectRestKeys = [];
            Object.keys(effectStyle).forEach(function (key) {
              if (key.startsWith('@layer')) {
                effectLayerKeys.push(key);
              } else {
                effectRestKeys.push(key);
              }
            });

            // ================= Inject Layer Style =================
            // Inject layer style
            effectLayerKeys.forEach(function (effectKey) {
              updateCSS(normalizeStyle(effectStyle[effectKey]), "_layer-".concat(effectKey), _objectSpread2(_objectSpread2({}, mergedCSSConfig), {}, {
                prepend: true
              }));
            });

            // ==================== Inject Style ====================
            // Inject style
            var style = updateCSS(styleStr, styleId, mergedCSSConfig);
            style[CSS_IN_JS_INSTANCE] = cache.instanceId;

            // Used for `useCacheToken` to remove on batch when token removed
            style.setAttribute(ATTR_TOKEN, tokenKey);

            // ================ Inject Effect Style =================
            // Inject client side effect style
            effectRestKeys.forEach(function (effectKey) {
              updateCSS(normalizeStyle(effectStyle[effectKey]), "_effect-".concat(effectKey), mergedCSSConfig);
            });
          }
        }),
        _useGlobalCache2 = _slicedToArray(_useGlobalCache, 3),
        cachedStyleStr = _useGlobalCache2[0],
        cachedTokenKey = _useGlobalCache2[1],
        cachedStyleId = _useGlobalCache2[2];
      return function (node) {
        var styleNode;
        if (!ssrInline || isMergedClientSide || !defaultCache) {
          styleNode = /*#__PURE__*/reactExports.createElement(Empty, null);
        } else {
          var _ref6;
          styleNode = /*#__PURE__*/reactExports.createElement("style", _extends({}, (_ref6 = {}, _defineProperty(_ref6, ATTR_TOKEN, cachedTokenKey), _defineProperty(_ref6, ATTR_MARK, cachedStyleId), _ref6), {
            dangerouslySetInnerHTML: {
              __html: cachedStyleStr
            }
          }));
        }
        return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, styleNode, node);
      };
    }
    var extract$1 = function extract(cache, effectStyles, options) {
      var _cache = _slicedToArray(cache, 6),
        styleStr = _cache[0],
        tokenKey = _cache[1],
        styleId = _cache[2],
        effectStyle = _cache[3],
        clientOnly = _cache[4],
        order = _cache[5];
      var _ref7 = options || {},
        plain = _ref7.plain;

      // Skip client only style
      if (clientOnly) {
        return null;
      }
      var keyStyleText = styleStr;

      // ====================== Share ======================
      // Used for rc-util
      var sharedAttrs = {
        'data-rc-order': 'prependQueue',
        'data-rc-priority': "".concat(order)
      };

      // ====================== Style ======================
      keyStyleText = toStyleStr(styleStr, tokenKey, styleId, sharedAttrs, plain);

      // =============== Create effect style ===============
      if (effectStyle) {
        Object.keys(effectStyle).forEach(function (effectKey) {
          // Effect style can be reused
          if (!effectStyles[effectKey]) {
            effectStyles[effectKey] = true;
            var effectStyleStr = normalizeStyle(effectStyle[effectKey]);
            var effectStyleHTML = toStyleStr(effectStyleStr, tokenKey, "_effect-".concat(effectKey), sharedAttrs, plain);
            if (effectKey.startsWith('@layer')) {
              keyStyleText = effectStyleHTML + keyStyleText;
            } else {
              keyStyleText += effectStyleHTML;
            }
          }
        });
      }
      return [order, styleId, keyStyleText];
    };

    var CSS_VAR_PREFIX = 'cssVar';
    var useCSSVarRegister = function useCSSVarRegister(config, fn) {
      var key = config.key,
        prefix = config.prefix,
        unitless = config.unitless,
        ignore = config.ignore,
        token = config.token,
        _config$scope = config.scope,
        scope = _config$scope === void 0 ? '' : _config$scope;
      var _useContext = reactExports.useContext(StyleContext),
        instanceId = _useContext.cache.instanceId,
        container = _useContext.container;
      var tokenKey = token._tokenKey;
      var stylePath = [].concat(_toConsumableArray(config.path), [key, scope, tokenKey]);
      var cache = useGlobalCache(CSS_VAR_PREFIX, stylePath, function () {
        var originToken = fn();
        var _transformToken = transformToken(originToken, key, {
            prefix: prefix,
            unitless: unitless,
            ignore: ignore,
            scope: scope
          }),
          _transformToken2 = _slicedToArray(_transformToken, 2),
          mergedToken = _transformToken2[0],
          cssVarsStr = _transformToken2[1];
        var styleId = uniqueHash(stylePath, cssVarsStr);
        return [mergedToken, cssVarsStr, styleId, key];
      }, function (_ref) {
        var _ref2 = _slicedToArray(_ref, 3),
          styleId = _ref2[2];
        if (isClientSide) {
          removeCSS(styleId, {
            mark: ATTR_MARK
          });
        }
      }, function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 3),
          cssVarsStr = _ref4[1],
          styleId = _ref4[2];
        if (!cssVarsStr) {
          return;
        }
        var style = updateCSS(cssVarsStr, styleId, {
          mark: ATTR_MARK,
          prepend: 'queue',
          attachTo: container,
          priority: -999
        });
        style[CSS_IN_JS_INSTANCE] = instanceId;

        // Used for `useCacheToken` to remove on batch when token removed
        style.setAttribute(ATTR_TOKEN, key);
      });
      return cache;
    };
    var extract = function extract(cache, effectStyles, options) {
      var _cache = _slicedToArray(cache, 4),
        styleStr = _cache[1],
        styleId = _cache[2],
        cssVarKey = _cache[3];
      var _ref5 = options || {},
        plain = _ref5.plain;
      if (!styleStr) {
        return null;
      }
      var order = -999;

      // ====================== Style ======================
      // Used for rc-util
      var sharedAttrs = {
        'data-rc-order': 'prependQueue',
        'data-rc-priority': "".concat(order)
      };
      var styleText = toStyleStr(styleStr, cssVarKey, styleId, sharedAttrs, plain);
      return [order, styleId, styleText];
    };

    var _ExtractStyleFns;
    (_ExtractStyleFns = {}, _defineProperty(_ExtractStyleFns, STYLE_PREFIX, extract$1), _defineProperty(_ExtractStyleFns, TOKEN_PREFIX, extract$2), _defineProperty(_ExtractStyleFns, CSS_VAR_PREFIX, extract), _ExtractStyleFns);

    var Keyframe = /*#__PURE__*/function () {
      function Keyframe(name, style) {
        _classCallCheck(this, Keyframe);
        _defineProperty(this, "name", void 0);
        _defineProperty(this, "style", void 0);
        _defineProperty(this, "_keyframe", true);
        this.name = name;
        this.style = style;
      }
      _createClass(Keyframe, [{
        key: "getName",
        value: function getName() {
          var hashId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          return hashId ? "".concat(hashId, "-").concat(this.name) : this.name;
        }
      }]);
      return Keyframe;
    }();

    function noSplit(list) {
      list.notSplit = true;
      return list;
    }
    ({
      // Border
      borderBlock: noSplit(['borderTop', 'borderBottom']),
      borderBlockStart: noSplit(['borderTop']),
      borderBlockEnd: noSplit(['borderBottom']),
      borderInline: noSplit(['borderLeft', 'borderRight']),
      borderInlineStart: noSplit(['borderLeft']),
      borderInlineEnd: noSplit(['borderRight'])});

    var IconContext = /*#__PURE__*/reactExports.createContext({});

    function _toArray(r) {
      return _arrayWithHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableRest();
    }

    function get(entity, path) {
      var current = entity;
      for (var i = 0; i < path.length; i += 1) {
        if (current === null || current === undefined) {
          return undefined;
        }
        current = current[path[i]];
      }
      return current;
    }

    function internalSet(entity, paths, value, removeIfUndefined) {
      if (!paths.length) {
        return value;
      }
      var _paths = _toArray(paths),
        path = _paths[0],
        restPath = _paths.slice(1);
      var clone;
      if (!entity && typeof path === 'number') {
        clone = [];
      } else if (Array.isArray(entity)) {
        clone = _toConsumableArray(entity);
      } else {
        clone = _objectSpread2({}, entity);
      }

      // Delete prop if `removeIfUndefined` and value is undefined
      if (removeIfUndefined && value === undefined && restPath.length === 1) {
        delete clone[path][restPath[0]];
      } else {
        clone[path] = internalSet(clone[path], restPath, value, removeIfUndefined);
      }
      return clone;
    }
    function set(entity, paths, value) {
      var removeIfUndefined = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      // Do nothing if `removeIfUndefined` and parent object not exist
      if (paths.length && removeIfUndefined && value === undefined && !get(entity, paths.slice(0, -1))) {
        return entity;
      }
      return internalSet(entity, paths, value, removeIfUndefined);
    }
    function isObject$1(obj) {
      return _typeof(obj) === 'object' && obj !== null && Object.getPrototypeOf(obj) === Object.prototype;
    }
    function createEmpty(source) {
      return Array.isArray(source) ? [] : {};
    }
    var keys = typeof Reflect === 'undefined' ? Object.keys : Reflect.ownKeys;

    /**
     * Merge objects which will create
     */
    function merge$2() {
      for (var _len = arguments.length, sources = new Array(_len), _key = 0; _key < _len; _key++) {
        sources[_key] = arguments[_key];
      }
      var clone = createEmpty(sources[0]);
      sources.forEach(function (src) {
        function internalMerge(path, parentLoopSet) {
          var loopSet = new Set(parentLoopSet);
          var value = get(src, path);
          var isArr = Array.isArray(value);
          if (isArr || isObject$1(value)) {
            // Only add not loop obj
            if (!loopSet.has(value)) {
              loopSet.add(value);
              var originValue = get(clone, path);
              if (isArr) {
                // Array will always be override
                clone = set(clone, path, []);
              } else if (!originValue || _typeof(originValue) !== 'object') {
                // Init container if not exist
                clone = set(clone, path, createEmpty(value));
              }
              keys(value).forEach(function (key) {
                internalMerge([].concat(_toConsumableArray(path), [key]), loopSet);
              });
            }
          } else {
            clone = set(clone, path, value);
          }
        }
        internalMerge([]);
      });
      return clone;
    }

    const WarningContext = /*#__PURE__*/reactExports.createContext({});

    // ZombieJ: We export single file here since
    // ConfigProvider use this which will make loop deps
    // to import whole `rc-field-form`
    var ValidateMessagesContext = /*#__PURE__*/reactExports.createContext(undefined);

    const typeTemplate$1 = '${label} is not a valid ${type}';
    const localeValues = {
      Modal: {
        okText: 'OK',
        cancelText: 'Cancel',
        justOkText: 'OK'
      },
      Form: {
        optional: '(optional)',
        defaultValidateMessages: {
          default: 'Field validation error for ${label}',
          required: 'Please enter ${label}',
          enum: '${label} must be one of [${enum}]',
          whitespace: '${label} cannot be a blank character',
          date: {
            format: '${label} date format is invalid',
            parse: '${label} cannot be converted to a date',
            invalid: '${label} is an invalid date'
          },
          types: {
            string: typeTemplate$1,
            method: typeTemplate$1,
            array: typeTemplate$1,
            object: typeTemplate$1,
            number: typeTemplate$1,
            date: typeTemplate$1,
            boolean: typeTemplate$1,
            integer: typeTemplate$1,
            float: typeTemplate$1,
            regexp: typeTemplate$1,
            email: typeTemplate$1,
            url: typeTemplate$1,
            hex: typeTemplate$1
          },
          string: {
            len: '${label} must be ${len} characters',
            min: '${label} must be at least ${min} characters',
            max: '${label} must be up to ${max} characters',
            range: '${label} must be between ${min}-${max} characters'
          },
          number: {
            len: '${label} must be equal to ${len}',
            min: '${label} must be minimum ${min}',
            max: '${label} must be maximum ${max}',
            range: '${label} must be between ${min}-${max}'
          },
          array: {
            len: 'Must be ${len} ${label}',
            min: 'At least ${min} ${label}',
            max: 'At most ${max} ${label}',
            range: 'The amount of ${label} must be between ${min}-${max}'
          },
          pattern: {
            mismatch: '${label} does not match the pattern ${pattern}'
          }
        }
      }};

    Object.assign({}, localeValues.Modal);
    let localeList = [];
    const generateLocale = () => localeList.reduce((merged, locale) => Object.assign(Object.assign({}, merged), locale), localeValues.Modal);
    function changeConfirmLocale(newLocale) {
      if (newLocale) {
        const cloneLocale = Object.assign({}, newLocale);
        localeList.push(cloneLocale);
        generateLocale();
        return () => {
          localeList = localeList.filter(locale => locale !== cloneLocale);
          generateLocale();
        };
      }
      Object.assign({}, localeValues.Modal);
    }

    const LocaleContext = /*#__PURE__*/reactExports.createContext(undefined);

    const ANT_MARK = 'internalMark';
    const LocaleProvider = props => {
      const {
        locale = {},
        children,
        _ANT_MARK__
      } = props;
      reactExports.useEffect(() => {
        const clearLocale = changeConfirmLocale(locale === null || locale === void 0 ? void 0 : locale.Modal);
        return clearLocale;
      }, [locale]);
      const getMemoizedContextValue = reactExports.useMemo(() => Object.assign(Object.assign({}, locale), {
        exist: true
      }), [locale]);
      return /*#__PURE__*/reactExports.createElement(LocaleContext.Provider, {
        value: getMemoizedContextValue
      }, children);
    };

    const round = Math.round;

    /**
     * Support format, alpha unit will check the % mark:
     * - rgba(102, 204, 255, .5)      -> [102, 204, 255, 0.5]
     * - rgb(102 204 255 / .5)        -> [102, 204, 255, 0.5]
     * - rgb(100%, 50%, 0% / 50%)     -> [255, 128, 0, 0.5]
     * - hsl(270, 60, 40, .5)         -> [270, 60, 40, 0.5]
     * - hsl(270deg 60% 40% / 50%)   -> [270, 60, 40, 0.5]
     *
     * When `base` is provided, the percentage value will be divided by `base`.
     */
    function splitColorStr(str, parseNum) {
      const match = str
      // Remove str before `(`
      .replace(/^[^(]*\((.*)/, '$1')
      // Remove str after `)`
      .replace(/\).*/, '').match(/\d*\.?\d+%?/g) || [];
      const numList = match.map(item => parseFloat(item));
      for (let i = 0; i < 3; i += 1) {
        numList[i] = parseNum(numList[i] || 0, match[i] || '', i);
      }

      // For alpha. 50% should be 0.5
      if (match[3]) {
        numList[3] = match[3].includes('%') ? numList[3] / 100 : numList[3];
      } else {
        // By default, alpha is 1
        numList[3] = 1;
      }
      return numList;
    }
    const parseHSVorHSL = (num, _, index) => index === 0 ? num : num / 100;

    /** round and limit number to integer between 0-255 */
    function limitRange(value, max) {
      const mergedMax = max || 255;
      if (value > mergedMax) {
        return mergedMax;
      }
      if (value < 0) {
        return 0;
      }
      return value;
    }
    class FastColor {
      constructor(input) {
        /**
         * All FastColor objects are valid. So isValid is always true. This property is kept to be compatible with TinyColor.
         */
        _defineProperty(this, "isValid", true);
        /**
         * Red, R in RGB
         */
        _defineProperty(this, "r", 0);
        /**
         * Green, G in RGB
         */
        _defineProperty(this, "g", 0);
        /**
         * Blue, B in RGB
         */
        _defineProperty(this, "b", 0);
        /**
         * Alpha/Opacity, A in RGBA/HSLA
         */
        _defineProperty(this, "a", 1);
        // HSV privates
        _defineProperty(this, "_h", void 0);
        _defineProperty(this, "_s", void 0);
        _defineProperty(this, "_l", void 0);
        _defineProperty(this, "_v", void 0);
        // intermediate variables to calculate HSL/HSV
        _defineProperty(this, "_max", void 0);
        _defineProperty(this, "_min", void 0);
        _defineProperty(this, "_brightness", void 0);
        /**
         * Always check 3 char in the object to determine the format.
         * We not use function in check to save bundle size.
         * e.g. 'rgb' -> { r: 0, g: 0, b: 0 }.
         */
        function matchFormat(str) {
          return str[0] in input && str[1] in input && str[2] in input;
        }
        if (!input) ; else if (typeof input === 'string') {
          const trimStr = input.trim();
          function matchPrefix(prefix) {
            return trimStr.startsWith(prefix);
          }
          if (/^#?[A-F\d]{3,8}$/i.test(trimStr)) {
            this.fromHexString(trimStr);
          } else if (matchPrefix('rgb')) {
            this.fromRgbString(trimStr);
          } else if (matchPrefix('hsl')) {
            this.fromHslString(trimStr);
          } else if (matchPrefix('hsv') || matchPrefix('hsb')) {
            this.fromHsvString(trimStr);
          }
        } else if (input instanceof FastColor) {
          this.r = input.r;
          this.g = input.g;
          this.b = input.b;
          this.a = input.a;
          this._h = input._h;
          this._s = input._s;
          this._l = input._l;
          this._v = input._v;
        } else if (matchFormat('rgb')) {
          this.r = limitRange(input.r);
          this.g = limitRange(input.g);
          this.b = limitRange(input.b);
          this.a = typeof input.a === 'number' ? limitRange(input.a, 1) : 1;
        } else if (matchFormat('hsl')) {
          this.fromHsl(input);
        } else if (matchFormat('hsv')) {
          this.fromHsv(input);
        } else {
          throw new Error('@ant-design/fast-color: unsupported input ' + JSON.stringify(input));
        }
      }

      // ======================= Setter =======================

      setR(value) {
        return this._sc('r', value);
      }
      setG(value) {
        return this._sc('g', value);
      }
      setB(value) {
        return this._sc('b', value);
      }
      setA(value) {
        return this._sc('a', value, 1);
      }
      setHue(value) {
        const hsv = this.toHsv();
        hsv.h = value;
        return this._c(hsv);
      }

      // ======================= Getter =======================
      /**
       * Returns the perceived luminance of a color, from 0-1.
       * @see http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef
       */
      getLuminance() {
        function adjustGamma(raw) {
          const val = raw / 255;
          return val <= 0.03928 ? val / 12.92 : Math.pow((val + 0.055) / 1.055, 2.4);
        }
        const R = adjustGamma(this.r);
        const G = adjustGamma(this.g);
        const B = adjustGamma(this.b);
        return 0.2126 * R + 0.7152 * G + 0.0722 * B;
      }
      getHue() {
        if (typeof this._h === 'undefined') {
          const delta = this.getMax() - this.getMin();
          if (delta === 0) {
            this._h = 0;
          } else {
            this._h = round(60 * (this.r === this.getMax() ? (this.g - this.b) / delta + (this.g < this.b ? 6 : 0) : this.g === this.getMax() ? (this.b - this.r) / delta + 2 : (this.r - this.g) / delta + 4));
          }
        }
        return this._h;
      }
      getSaturation() {
        if (typeof this._s === 'undefined') {
          const delta = this.getMax() - this.getMin();
          if (delta === 0) {
            this._s = 0;
          } else {
            this._s = delta / this.getMax();
          }
        }
        return this._s;
      }
      getLightness() {
        if (typeof this._l === 'undefined') {
          this._l = (this.getMax() + this.getMin()) / 510;
        }
        return this._l;
      }
      getValue() {
        if (typeof this._v === 'undefined') {
          this._v = this.getMax() / 255;
        }
        return this._v;
      }

      /**
       * Returns the perceived brightness of the color, from 0-255.
       * Note: this is not the b of HSB
       * @see http://www.w3.org/TR/AERT#color-contrast
       */
      getBrightness() {
        if (typeof this._brightness === 'undefined') {
          this._brightness = (this.r * 299 + this.g * 587 + this.b * 114) / 1000;
        }
        return this._brightness;
      }

      // ======================== Func ========================

      darken(amount = 10) {
        const h = this.getHue();
        const s = this.getSaturation();
        let l = this.getLightness() - amount / 100;
        if (l < 0) {
          l = 0;
        }
        return this._c({
          h,
          s,
          l,
          a: this.a
        });
      }
      lighten(amount = 10) {
        const h = this.getHue();
        const s = this.getSaturation();
        let l = this.getLightness() + amount / 100;
        if (l > 1) {
          l = 1;
        }
        return this._c({
          h,
          s,
          l,
          a: this.a
        });
      }

      /**
       * Mix the current color a given amount with another color, from 0 to 100.
       * 0 means no mixing (return current color).
       */
      mix(input, amount = 50) {
        const color = this._c(input);
        const p = amount / 100;
        const calc = key => (color[key] - this[key]) * p + this[key];
        const rgba = {
          r: round(calc('r')),
          g: round(calc('g')),
          b: round(calc('b')),
          a: round(calc('a') * 100) / 100
        };
        return this._c(rgba);
      }

      /**
       * Mix the color with pure white, from 0 to 100.
       * Providing 0 will do nothing, providing 100 will always return white.
       */
      tint(amount = 10) {
        return this.mix({
          r: 255,
          g: 255,
          b: 255,
          a: 1
        }, amount);
      }

      /**
       * Mix the color with pure black, from 0 to 100.
       * Providing 0 will do nothing, providing 100 will always return black.
       */
      shade(amount = 10) {
        return this.mix({
          r: 0,
          g: 0,
          b: 0,
          a: 1
        }, amount);
      }
      onBackground(background) {
        const bg = this._c(background);
        const alpha = this.a + bg.a * (1 - this.a);
        const calc = key => {
          return round((this[key] * this.a + bg[key] * bg.a * (1 - this.a)) / alpha);
        };
        return this._c({
          r: calc('r'),
          g: calc('g'),
          b: calc('b'),
          a: alpha
        });
      }

      // ======================= Status =======================
      isDark() {
        return this.getBrightness() < 128;
      }
      isLight() {
        return this.getBrightness() >= 128;
      }

      // ======================== MISC ========================
      equals(other) {
        return this.r === other.r && this.g === other.g && this.b === other.b && this.a === other.a;
      }
      clone() {
        return this._c(this);
      }

      // ======================= Format =======================
      toHexString() {
        let hex = '#';
        const rHex = (this.r || 0).toString(16);
        hex += rHex.length === 2 ? rHex : '0' + rHex;
        const gHex = (this.g || 0).toString(16);
        hex += gHex.length === 2 ? gHex : '0' + gHex;
        const bHex = (this.b || 0).toString(16);
        hex += bHex.length === 2 ? bHex : '0' + bHex;
        if (typeof this.a === 'number' && this.a >= 0 && this.a < 1) {
          const aHex = round(this.a * 255).toString(16);
          hex += aHex.length === 2 ? aHex : '0' + aHex;
        }
        return hex;
      }

      /** CSS support color pattern */
      toHsl() {
        return {
          h: this.getHue(),
          s: this.getSaturation(),
          l: this.getLightness(),
          a: this.a
        };
      }

      /** CSS support color pattern */
      toHslString() {
        const h = this.getHue();
        const s = round(this.getSaturation() * 100);
        const l = round(this.getLightness() * 100);
        return this.a !== 1 ? `hsla(${h},${s}%,${l}%,${this.a})` : `hsl(${h},${s}%,${l}%)`;
      }

      /** Same as toHsb */
      toHsv() {
        return {
          h: this.getHue(),
          s: this.getSaturation(),
          v: this.getValue(),
          a: this.a
        };
      }
      toRgb() {
        return {
          r: this.r,
          g: this.g,
          b: this.b,
          a: this.a
        };
      }
      toRgbString() {
        return this.a !== 1 ? `rgba(${this.r},${this.g},${this.b},${this.a})` : `rgb(${this.r},${this.g},${this.b})`;
      }
      toString() {
        return this.toRgbString();
      }

      // ====================== Privates ======================
      /** Return a new FastColor object with one channel changed */
      _sc(rgb, value, max) {
        const clone = this.clone();
        clone[rgb] = limitRange(value, max);
        return clone;
      }
      _c(input) {
        return new this.constructor(input);
      }
      getMax() {
        if (typeof this._max === 'undefined') {
          this._max = Math.max(this.r, this.g, this.b);
        }
        return this._max;
      }
      getMin() {
        if (typeof this._min === 'undefined') {
          this._min = Math.min(this.r, this.g, this.b);
        }
        return this._min;
      }
      fromHexString(trimStr) {
        const withoutPrefix = trimStr.replace('#', '');
        function connectNum(index1, index2) {
          return parseInt(withoutPrefix[index1] + withoutPrefix[index2 || index1], 16);
        }
        if (withoutPrefix.length < 6) {
          // #rgb or #rgba
          this.r = connectNum(0);
          this.g = connectNum(1);
          this.b = connectNum(2);
          this.a = withoutPrefix[3] ? connectNum(3) / 255 : 1;
        } else {
          // #rrggbb or #rrggbbaa
          this.r = connectNum(0, 1);
          this.g = connectNum(2, 3);
          this.b = connectNum(4, 5);
          this.a = withoutPrefix[6] ? connectNum(6, 7) / 255 : 1;
        }
      }
      fromHsl({
        h,
        s,
        l,
        a
      }) {
        this._h = h % 360;
        this._s = s;
        this._l = l;
        this.a = typeof a === 'number' ? a : 1;
        if (s <= 0) {
          const rgb = round(l * 255);
          this.r = rgb;
          this.g = rgb;
          this.b = rgb;
        }
        let r = 0,
          g = 0,
          b = 0;
        const huePrime = h / 60;
        const chroma = (1 - Math.abs(2 * l - 1)) * s;
        const secondComponent = chroma * (1 - Math.abs(huePrime % 2 - 1));
        if (huePrime >= 0 && huePrime < 1) {
          r = chroma;
          g = secondComponent;
        } else if (huePrime >= 1 && huePrime < 2) {
          r = secondComponent;
          g = chroma;
        } else if (huePrime >= 2 && huePrime < 3) {
          g = chroma;
          b = secondComponent;
        } else if (huePrime >= 3 && huePrime < 4) {
          g = secondComponent;
          b = chroma;
        } else if (huePrime >= 4 && huePrime < 5) {
          r = secondComponent;
          b = chroma;
        } else if (huePrime >= 5 && huePrime < 6) {
          r = chroma;
          b = secondComponent;
        }
        const lightnessModification = l - chroma / 2;
        this.r = round((r + lightnessModification) * 255);
        this.g = round((g + lightnessModification) * 255);
        this.b = round((b + lightnessModification) * 255);
      }
      fromHsv({
        h,
        s,
        v,
        a
      }) {
        this._h = h % 360;
        this._s = s;
        this._v = v;
        this.a = typeof a === 'number' ? a : 1;
        const vv = round(v * 255);
        this.r = vv;
        this.g = vv;
        this.b = vv;
        if (s <= 0) {
          return;
        }
        const hh = h / 60;
        const i = Math.floor(hh);
        const ff = hh - i;
        const p = round(v * (1.0 - s) * 255);
        const q = round(v * (1.0 - s * ff) * 255);
        const t = round(v * (1.0 - s * (1.0 - ff)) * 255);
        switch (i) {
          case 0:
            this.g = t;
            this.b = p;
            break;
          case 1:
            this.r = q;
            this.b = p;
            break;
          case 2:
            this.r = p;
            this.b = t;
            break;
          case 3:
            this.r = p;
            this.g = q;
            break;
          case 4:
            this.r = t;
            this.g = p;
            break;
          case 5:
          default:
            this.g = p;
            this.b = q;
            break;
        }
      }
      fromHsvString(trimStr) {
        const cells = splitColorStr(trimStr, parseHSVorHSL);
        this.fromHsv({
          h: cells[0],
          s: cells[1],
          v: cells[2],
          a: cells[3]
        });
      }
      fromHslString(trimStr) {
        const cells = splitColorStr(trimStr, parseHSVorHSL);
        this.fromHsl({
          h: cells[0],
          s: cells[1],
          l: cells[2],
          a: cells[3]
        });
      }
      fromRgbString(trimStr) {
        const cells = splitColorStr(trimStr, (num, txt) =>
        // Convert percentage to number. e.g. 50% -> 128
        txt.includes('%') ? round(num / 100 * 255) : num);
        this.r = cells[0];
        this.g = cells[1];
        this.b = cells[2];
        this.a = cells[3];
      }
    }

    var hueStep = 2; // 
    var saturationStep = 0.16; // 
    var saturationStep2 = 0.05; // 
    var brightnessStep1 = 0.05; // 
    var brightnessStep2 = 0.15; // 
    var lightColorCount = 5; // 
    var darkColorCount = 4; // 

    // 
    var darkColorMap = [{
      index: 7,
      amount: 15
    }, {
      index: 6,
      amount: 25
    }, {
      index: 5,
      amount: 30
    }, {
      index: 5,
      amount: 45
    }, {
      index: 5,
      amount: 65
    }, {
      index: 5,
      amount: 85
    }, {
      index: 4,
      amount: 90
    }, {
      index: 3,
      amount: 95
    }, {
      index: 2,
      amount: 97
    }, {
      index: 1,
      amount: 98
    }];
    function getHue(hsv, i, light) {
      var hue;
      // 
      if (Math.round(hsv.h) >= 60 && Math.round(hsv.h) <= 240) {
        hue = light ? Math.round(hsv.h) - hueStep * i : Math.round(hsv.h) + hueStep * i;
      } else {
        hue = light ? Math.round(hsv.h) + hueStep * i : Math.round(hsv.h) - hueStep * i;
      }
      if (hue < 0) {
        hue += 360;
      } else if (hue >= 360) {
        hue -= 360;
      }
      return hue;
    }
    function getSaturation(hsv, i, light) {
      // grey color don't change saturation
      if (hsv.h === 0 && hsv.s === 0) {
        return hsv.s;
      }
      var saturation;
      if (light) {
        saturation = hsv.s - saturationStep * i;
      } else if (i === darkColorCount) {
        saturation = hsv.s + saturationStep;
      } else {
        saturation = hsv.s + saturationStep2 * i;
      }
      // 
      if (saturation > 1) {
        saturation = 1;
      }
      //  s  0.06-0.1 
      if (light && i === lightColorCount && saturation > 0.1) {
        saturation = 0.1;
      }
      if (saturation < 0.06) {
        saturation = 0.06;
      }
      return Math.round(saturation * 100) / 100;
    }
    function getValue$1(hsv, i, light) {
      var value;
      if (light) {
        value = hsv.v + brightnessStep1 * i;
      } else {
        value = hsv.v - brightnessStep2 * i;
      }
      // Clamp value between 0 and 1
      value = Math.max(0, Math.min(1, value));
      return Math.round(value * 100) / 100;
    }
    function generate$1(color) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var patterns = [];
      var pColor = new FastColor(color);
      var hsv = pColor.toHsv();
      for (var i = lightColorCount; i > 0; i -= 1) {
        var c = new FastColor({
          h: getHue(hsv, i, true),
          s: getSaturation(hsv, i, true),
          v: getValue$1(hsv, i, true)
        });
        patterns.push(c);
      }
      patterns.push(pColor);
      for (var _i = 1; _i <= darkColorCount; _i += 1) {
        var _c = new FastColor({
          h: getHue(hsv, _i),
          s: getSaturation(hsv, _i),
          v: getValue$1(hsv, _i)
        });
        patterns.push(_c);
      }

      // dark theme patterns
      if (opts.theme === 'dark') {
        return darkColorMap.map(function (_ref) {
          var index = _ref.index,
            amount = _ref.amount;
          return new FastColor(opts.backgroundColor || '#141414').mix(patterns[index], amount).toHexString();
        });
      }
      return patterns.map(function (c) {
        return c.toHexString();
      });
    }

    // Generated by script. Do NOT modify!

    var presetPrimaryColors = {
      "red": "#F5222D",
      "volcano": "#FA541C",
      "orange": "#FA8C16",
      "gold": "#FAAD14",
      "yellow": "#FADB14",
      "lime": "#A0D911",
      "green": "#52C41A",
      "cyan": "#13C2C2",
      "blue": "#1677FF",
      "geekblue": "#2F54EB",
      "purple": "#722ED1",
      "magenta": "#EB2F96",
      "grey": "#666666"
    };
    var red = ["#fff1f0", "#ffccc7", "#ffa39e", "#ff7875", "#ff4d4f", "#f5222d", "#cf1322", "#a8071a", "#820014", "#5c0011"];
    red.primary = red[5];
    var volcano = ["#fff2e8", "#ffd8bf", "#ffbb96", "#ff9c6e", "#ff7a45", "#fa541c", "#d4380d", "#ad2102", "#871400", "#610b00"];
    volcano.primary = volcano[5];
    var orange = ["#fff7e6", "#ffe7ba", "#ffd591", "#ffc069", "#ffa940", "#fa8c16", "#d46b08", "#ad4e00", "#873800", "#612500"];
    orange.primary = orange[5];
    var gold = ["#fffbe6", "#fff1b8", "#ffe58f", "#ffd666", "#ffc53d", "#faad14", "#d48806", "#ad6800", "#874d00", "#613400"];
    gold.primary = gold[5];
    var yellow = ["#feffe6", "#ffffb8", "#fffb8f", "#fff566", "#ffec3d", "#fadb14", "#d4b106", "#ad8b00", "#876800", "#614700"];
    yellow.primary = yellow[5];
    var lime = ["#fcffe6", "#f4ffb8", "#eaff8f", "#d3f261", "#bae637", "#a0d911", "#7cb305", "#5b8c00", "#3f6600", "#254000"];
    lime.primary = lime[5];
    var green = ["#f6ffed", "#d9f7be", "#b7eb8f", "#95de64", "#73d13d", "#52c41a", "#389e0d", "#237804", "#135200", "#092b00"];
    green.primary = green[5];
    var cyan = ["#e6fffb", "#b5f5ec", "#87e8de", "#5cdbd3", "#36cfc9", "#13c2c2", "#08979c", "#006d75", "#00474f", "#002329"];
    cyan.primary = cyan[5];
    var blue = ["#e6f4ff", "#bae0ff", "#91caff", "#69b1ff", "#4096ff", "#1677ff", "#0958d9", "#003eb3", "#002c8c", "#001d66"];
    blue.primary = blue[5];
    var geekblue = ["#f0f5ff", "#d6e4ff", "#adc6ff", "#85a5ff", "#597ef7", "#2f54eb", "#1d39c4", "#10239e", "#061178", "#030852"];
    geekblue.primary = geekblue[5];
    var purple = ["#f9f0ff", "#efdbff", "#d3adf7", "#b37feb", "#9254de", "#722ed1", "#531dab", "#391085", "#22075e", "#120338"];
    purple.primary = purple[5];
    var magenta = ["#fff0f6", "#ffd6e7", "#ffadd2", "#ff85c0", "#f759ab", "#eb2f96", "#c41d7f", "#9e1068", "#780650", "#520339"];
    magenta.primary = magenta[5];
    var grey = ["#a6a6a6", "#999999", "#8c8c8c", "#808080", "#737373", "#666666", "#404040", "#1a1a1a", "#000000", "#000000"];
    grey.primary = grey[5];
    var presetPalettes = {
      red: red,
      volcano: volcano,
      orange: orange,
      gold: gold,
      yellow: yellow,
      lime: lime,
      green: green,
      cyan: cyan,
      blue: blue,
      geekblue: geekblue,
      purple: purple,
      magenta: magenta,
      grey: grey
    };

    const defaultPresetColors = {
      blue: '#1677FF',
      purple: '#722ED1',
      cyan: '#13C2C2',
      green: '#52C41A',
      magenta: '#EB2F96',
      /**
       * @deprecated Use magenta instead
       */
      pink: '#EB2F96',
      red: '#F5222D',
      orange: '#FA8C16',
      yellow: '#FADB14',
      volcano: '#FA541C',
      geekblue: '#2F54EB',
      gold: '#FAAD14',
      lime: '#A0D911'
    };
    const seedToken = Object.assign(Object.assign({}, defaultPresetColors), {
      // Color
      colorPrimary: '#1677ff',
      colorSuccess: '#52c41a',
      colorWarning: '#faad14',
      colorError: '#ff4d4f',
      colorInfo: '#1677ff',
      colorLink: '',
      colorTextBase: '',
      colorBgBase: '',
      // Font
      fontFamily: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial,
'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol',
'Noto Color Emoji'`,
      fontFamilyCode: `'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, Courier, monospace`,
      fontSize: 14,
      // Line
      lineWidth: 1,
      lineType: 'solid',
      // Motion
      motionUnit: 0.1,
      motionBase: 0,
      motionEaseOutCirc: 'cubic-bezier(0.08, 0.82, 0.17, 1)',
      motionEaseInOutCirc: 'cubic-bezier(0.78, 0.14, 0.15, 0.86)',
      motionEaseOut: 'cubic-bezier(0.215, 0.61, 0.355, 1)',
      motionEaseInOut: 'cubic-bezier(0.645, 0.045, 0.355, 1)',
      motionEaseOutBack: 'cubic-bezier(0.12, 0.4, 0.29, 1.46)',
      motionEaseInBack: 'cubic-bezier(0.71, -0.46, 0.88, 0.6)',
      motionEaseInQuint: 'cubic-bezier(0.755, 0.05, 0.855, 0.06)',
      motionEaseOutQuint: 'cubic-bezier(0.23, 1, 0.32, 1)',
      // Radius
      borderRadius: 6,
      // Size
      sizeUnit: 4,
      sizeStep: 4,
      sizePopupArrow: 16,
      // Control Base
      controlHeight: 32,
      // zIndex
      zIndexBase: 0,
      zIndexPopupBase: 1000,
      // Image
      opacityImage: 1,
      // Wireframe
      wireframe: false,
      // Motion
      motion: true
    });

    function genColorMapToken(seed, _ref) {
      let {
        generateColorPalettes,
        generateNeutralColorPalettes
      } = _ref;
      const {
        colorSuccess: colorSuccessBase,
        colorWarning: colorWarningBase,
        colorError: colorErrorBase,
        colorInfo: colorInfoBase,
        colorPrimary: colorPrimaryBase,
        colorBgBase,
        colorTextBase
      } = seed;
      const primaryColors = generateColorPalettes(colorPrimaryBase);
      const successColors = generateColorPalettes(colorSuccessBase);
      const warningColors = generateColorPalettes(colorWarningBase);
      const errorColors = generateColorPalettes(colorErrorBase);
      const infoColors = generateColorPalettes(colorInfoBase);
      const neutralColors = generateNeutralColorPalettes(colorBgBase, colorTextBase);
      // Color Link
      const colorLink = seed.colorLink || seed.colorInfo;
      const linkColors = generateColorPalettes(colorLink);
      const colorErrorBgFilledHover = new FastColor(errorColors[1]).mix(new FastColor(errorColors[3]), 50).toHexString();
      return Object.assign(Object.assign({}, neutralColors), {
        colorPrimaryBg: primaryColors[1],
        colorPrimaryBgHover: primaryColors[2],
        colorPrimaryBorder: primaryColors[3],
        colorPrimaryBorderHover: primaryColors[4],
        colorPrimaryHover: primaryColors[5],
        colorPrimary: primaryColors[6],
        colorPrimaryActive: primaryColors[7],
        colorPrimaryTextHover: primaryColors[8],
        colorPrimaryText: primaryColors[9],
        colorPrimaryTextActive: primaryColors[10],
        colorSuccessBg: successColors[1],
        colorSuccessBgHover: successColors[2],
        colorSuccessBorder: successColors[3],
        colorSuccessBorderHover: successColors[4],
        colorSuccessHover: successColors[4],
        colorSuccess: successColors[6],
        colorSuccessActive: successColors[7],
        colorSuccessTextHover: successColors[8],
        colorSuccessText: successColors[9],
        colorSuccessTextActive: successColors[10],
        colorErrorBg: errorColors[1],
        colorErrorBgHover: errorColors[2],
        colorErrorBgFilledHover,
        colorErrorBgActive: errorColors[3],
        colorErrorBorder: errorColors[3],
        colorErrorBorderHover: errorColors[4],
        colorErrorHover: errorColors[5],
        colorError: errorColors[6],
        colorErrorActive: errorColors[7],
        colorErrorTextHover: errorColors[8],
        colorErrorText: errorColors[9],
        colorErrorTextActive: errorColors[10],
        colorWarningBg: warningColors[1],
        colorWarningBgHover: warningColors[2],
        colorWarningBorder: warningColors[3],
        colorWarningBorderHover: warningColors[4],
        colorWarningHover: warningColors[4],
        colorWarning: warningColors[6],
        colorWarningActive: warningColors[7],
        colorWarningTextHover: warningColors[8],
        colorWarningText: warningColors[9],
        colorWarningTextActive: warningColors[10],
        colorInfoBg: infoColors[1],
        colorInfoBgHover: infoColors[2],
        colorInfoBorder: infoColors[3],
        colorInfoBorderHover: infoColors[4],
        colorInfoHover: infoColors[4],
        colorInfo: infoColors[6],
        colorInfoActive: infoColors[7],
        colorInfoTextHover: infoColors[8],
        colorInfoText: infoColors[9],
        colorInfoTextActive: infoColors[10],
        colorLinkHover: linkColors[4],
        colorLink: linkColors[6],
        colorLinkActive: linkColors[7],
        colorBgMask: new FastColor('#000').setA(0.45).toRgbString(),
        colorWhite: '#fff'
      });
    }

    const genRadius = radiusBase => {
      let radiusLG = radiusBase;
      let radiusSM = radiusBase;
      let radiusXS = radiusBase;
      let radiusOuter = radiusBase;
      // radiusLG
      if (radiusBase < 6 && radiusBase >= 5) {
        radiusLG = radiusBase + 1;
      } else if (radiusBase < 16 && radiusBase >= 6) {
        radiusLG = radiusBase + 2;
      } else if (radiusBase >= 16) {
        radiusLG = 16;
      }
      // radiusSM
      if (radiusBase < 7 && radiusBase >= 5) {
        radiusSM = 4;
      } else if (radiusBase < 8 && radiusBase >= 7) {
        radiusSM = 5;
      } else if (radiusBase < 14 && radiusBase >= 8) {
        radiusSM = 6;
      } else if (radiusBase < 16 && radiusBase >= 14) {
        radiusSM = 7;
      } else if (radiusBase >= 16) {
        radiusSM = 8;
      }
      // radiusXS
      if (radiusBase < 6 && radiusBase >= 2) {
        radiusXS = 1;
      } else if (radiusBase >= 6) {
        radiusXS = 2;
      }
      // radiusOuter
      if (radiusBase > 4 && radiusBase < 8) {
        radiusOuter = 4;
      } else if (radiusBase >= 8) {
        radiusOuter = 6;
      }
      return {
        borderRadius: radiusBase,
        borderRadiusXS: radiusXS,
        borderRadiusSM: radiusSM,
        borderRadiusLG: radiusLG,
        borderRadiusOuter: radiusOuter
      };
    };

    function genCommonMapToken(token) {
      const {
        motionUnit,
        motionBase,
        borderRadius,
        lineWidth
      } = token;
      return Object.assign({
        // motion
        motionDurationFast: `${(motionBase + motionUnit).toFixed(1)}s`,
        motionDurationMid: `${(motionBase + motionUnit * 2).toFixed(1)}s`,
        motionDurationSlow: `${(motionBase + motionUnit * 3).toFixed(1)}s`,
        // line
        lineWidthBold: lineWidth + 1
      }, genRadius(borderRadius));
    }

    const genControlHeight = token => {
      const {
        controlHeight
      } = token;
      return {
        controlHeightSM: controlHeight * 0.75,
        controlHeightXS: controlHeight * 0.5,
        controlHeightLG: controlHeight * 1.25
      };
    };

    function getLineHeight(fontSize) {
      return (fontSize + 8) / fontSize;
    }
    // https://zhuanlan.zhihu.com/p/32746810
    function getFontSizes(base) {
      const fontSizes = new Array(10).fill(null).map((_, index) => {
        const i = index - 1;
        const baseSize = base * Math.pow(Math.E, i / 5);
        const intSize = index > 1 ? Math.floor(baseSize) : Math.ceil(baseSize);
        // Convert to even
        return Math.floor(intSize / 2) * 2;
      });
      fontSizes[1] = base;
      return fontSizes.map(size => ({
        size,
        lineHeight: getLineHeight(size)
      }));
    }

    const genFontMapToken = fontSize => {
      const fontSizePairs = getFontSizes(fontSize);
      const fontSizes = fontSizePairs.map(pair => pair.size);
      const lineHeights = fontSizePairs.map(pair => pair.lineHeight);
      const fontSizeMD = fontSizes[1];
      const fontSizeSM = fontSizes[0];
      const fontSizeLG = fontSizes[2];
      const lineHeight = lineHeights[1];
      const lineHeightSM = lineHeights[0];
      const lineHeightLG = lineHeights[2];
      return {
        fontSizeSM,
        fontSize: fontSizeMD,
        fontSizeLG,
        fontSizeXL: fontSizes[3],
        fontSizeHeading1: fontSizes[6],
        fontSizeHeading2: fontSizes[5],
        fontSizeHeading3: fontSizes[4],
        fontSizeHeading4: fontSizes[3],
        fontSizeHeading5: fontSizes[2],
        lineHeight,
        lineHeightLG,
        lineHeightSM,
        fontHeight: Math.round(lineHeight * fontSizeMD),
        fontHeightLG: Math.round(lineHeightLG * fontSizeLG),
        fontHeightSM: Math.round(lineHeightSM * fontSizeSM),
        lineHeightHeading1: lineHeights[6],
        lineHeightHeading2: lineHeights[5],
        lineHeightHeading3: lineHeights[4],
        lineHeightHeading4: lineHeights[3],
        lineHeightHeading5: lineHeights[2]
      };
    };

    function genSizeMapToken(token) {
      const {
        sizeUnit,
        sizeStep
      } = token;
      return {
        sizeXXL: sizeUnit * (sizeStep + 8),
        // 48
        sizeXL: sizeUnit * (sizeStep + 4),
        // 32
        sizeLG: sizeUnit * (sizeStep + 2),
        // 24
        sizeMD: sizeUnit * (sizeStep + 1),
        // 20
        sizeMS: sizeUnit * sizeStep,
        // 16
        size: sizeUnit * sizeStep,
        // 16
        sizeSM: sizeUnit * (sizeStep - 1),
        // 12
        sizeXS: sizeUnit * (sizeStep - 2),
        // 8
        sizeXXS: sizeUnit * (sizeStep - 3) // 4
      };
    }

    const getAlphaColor$1 = (baseColor, alpha) => new FastColor(baseColor).setA(alpha).toRgbString();
    const getSolidColor = (baseColor, brightness) => {
      const instance = new FastColor(baseColor);
      return instance.darken(brightness).toHexString();
    };

    const generateColorPalettes = baseColor => {
      const colors = generate$1(baseColor);
      return {
        1: colors[0],
        2: colors[1],
        3: colors[2],
        4: colors[3],
        5: colors[4],
        6: colors[5],
        7: colors[6],
        8: colors[4],
        9: colors[5],
        10: colors[6]
        // 8: colors[7],
        // 9: colors[8],
        // 10: colors[9],
      };
    };
    const generateNeutralColorPalettes = (bgBaseColor, textBaseColor) => {
      const colorBgBase = bgBaseColor || '#fff';
      const colorTextBase = textBaseColor || '#000';
      return {
        colorBgBase,
        colorTextBase,
        colorText: getAlphaColor$1(colorTextBase, 0.88),
        colorTextSecondary: getAlphaColor$1(colorTextBase, 0.65),
        colorTextTertiary: getAlphaColor$1(colorTextBase, 0.45),
        colorTextQuaternary: getAlphaColor$1(colorTextBase, 0.25),
        colorFill: getAlphaColor$1(colorTextBase, 0.15),
        colorFillSecondary: getAlphaColor$1(colorTextBase, 0.06),
        colorFillTertiary: getAlphaColor$1(colorTextBase, 0.04),
        colorFillQuaternary: getAlphaColor$1(colorTextBase, 0.02),
        colorBgSolid: getAlphaColor$1(colorTextBase, 1),
        colorBgSolidHover: getAlphaColor$1(colorTextBase, 0.75),
        colorBgSolidActive: getAlphaColor$1(colorTextBase, 0.95),
        colorBgLayout: getSolidColor(colorBgBase, 4),
        colorBgContainer: getSolidColor(colorBgBase, 0),
        colorBgElevated: getSolidColor(colorBgBase, 0),
        colorBgSpotlight: getAlphaColor$1(colorTextBase, 0.85),
        colorBgBlur: 'transparent',
        colorBorder: getSolidColor(colorBgBase, 15),
        colorBorderSecondary: getSolidColor(colorBgBase, 6)
      };
    };

    function derivative(token) {
      // pink is deprecated name of magenta, keep this for backwards compatibility
      presetPrimaryColors.pink = presetPrimaryColors.magenta;
      presetPalettes.pink = presetPalettes.magenta;
      const colorPalettes = Object.keys(defaultPresetColors).map(colorKey => {
        const colors = token[colorKey] === presetPrimaryColors[colorKey] ? presetPalettes[colorKey] : generate$1(token[colorKey]);
        return new Array(10).fill(1).reduce((prev, _, i) => {
          prev[`${colorKey}-${i + 1}`] = colors[i];
          prev[`${colorKey}${i + 1}`] = colors[i];
          return prev;
        }, {});
      }).reduce((prev, cur) => {
        // biome-ignore lint/style/noParameterAssign: it is a reduce
        prev = Object.assign(Object.assign({}, prev), cur);
        return prev;
      }, {});
      return Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, token), colorPalettes), genColorMapToken(token, {
        generateColorPalettes,
        generateNeutralColorPalettes
      })), genFontMapToken(token.fontSize)), genSizeMapToken(token)), genControlHeight(token)), genCommonMapToken(token));
    }

    const defaultTheme = createTheme(derivative);
    // ================================ Context =================================
    // To ensure snapshot stable. We disable hashed in test env.
    const defaultConfig = {
      token: seedToken,
      override: {
        override: seedToken
      },
      hashed: true
    };
    const DesignTokenContext = /*#__PURE__*/React.createContext(defaultConfig);

    const defaultPrefixCls = 'ant';
    const defaultIconPrefixCls = 'anticon';
    const Variants = ['outlined', 'borderless', 'filled'];
    const defaultGetPrefixCls = (suffixCls, customizePrefixCls) => {
      if (customizePrefixCls) {
        return customizePrefixCls;
      }
      return suffixCls ? `${defaultPrefixCls}-${suffixCls}` : defaultPrefixCls;
    };
    // zombieJ:  Do not pass `defaultRenderEmpty` here since it will cause circular dependency.
    const ConfigContext = /*#__PURE__*/reactExports.createContext({
      // We provide a default function for Context without provider
      getPrefixCls: defaultGetPrefixCls,
      iconPrefixCls: defaultIconPrefixCls
    });
    const {
      Consumer: ConfigConsumer
    } = ConfigContext;

    const dynamicStyleMark = `-ant-${Date.now()}-${Math.random()}`;
    function getStyle(globalPrefixCls, theme) {
      const variables = {};
      const formatColor = (color, updater) => {
        let clone = color.clone();
        clone = (updater === null || updater === void 0 ? void 0 : updater(clone)) || clone;
        return clone.toRgbString();
      };
      const fillColor = (colorVal, type) => {
        const baseColor = new FastColor(colorVal);
        const colorPalettes = generate$1(baseColor.toRgbString());
        variables[`${type}-color`] = formatColor(baseColor);
        variables[`${type}-color-disabled`] = colorPalettes[1];
        variables[`${type}-color-hover`] = colorPalettes[4];
        variables[`${type}-color-active`] = colorPalettes[6];
        variables[`${type}-color-outline`] = baseColor.clone().setA(0.2).toRgbString();
        variables[`${type}-color-deprecated-bg`] = colorPalettes[0];
        variables[`${type}-color-deprecated-border`] = colorPalettes[2];
      };
      // ================ Primary Color ================
      if (theme.primaryColor) {
        fillColor(theme.primaryColor, 'primary');
        const primaryColor = new FastColor(theme.primaryColor);
        const primaryColors = generate$1(primaryColor.toRgbString());
        // Legacy - We should use semantic naming standard
        primaryColors.forEach((color, index) => {
          variables[`primary-${index + 1}`] = color;
        });
        // Deprecated
        variables['primary-color-deprecated-l-35'] = formatColor(primaryColor, c => c.lighten(35));
        variables['primary-color-deprecated-l-20'] = formatColor(primaryColor, c => c.lighten(20));
        variables['primary-color-deprecated-t-20'] = formatColor(primaryColor, c => c.tint(20));
        variables['primary-color-deprecated-t-50'] = formatColor(primaryColor, c => c.tint(50));
        variables['primary-color-deprecated-f-12'] = formatColor(primaryColor, c => c.setA(c.a * 0.12));
        const primaryActiveColor = new FastColor(primaryColors[0]);
        variables['primary-color-active-deprecated-f-30'] = formatColor(primaryActiveColor, c => c.setA(c.a * 0.3));
        variables['primary-color-active-deprecated-d-02'] = formatColor(primaryActiveColor, c => c.darken(2));
      }
      // ================ Success Color ================
      if (theme.successColor) {
        fillColor(theme.successColor, 'success');
      }
      // ================ Warning Color ================
      if (theme.warningColor) {
        fillColor(theme.warningColor, 'warning');
      }
      // ================= Error Color =================
      if (theme.errorColor) {
        fillColor(theme.errorColor, 'error');
      }
      // ================= Info Color ==================
      if (theme.infoColor) {
        fillColor(theme.infoColor, 'info');
      }
      // Convert to css variables
      const cssList = Object.keys(variables).map(key => `--${globalPrefixCls}-${key}: ${variables[key]};`);
      return `
  :root {
    ${cssList.join('\n')}
  }
  `.trim();
    }
    function registerTheme(globalPrefixCls, theme) {
      const style = getStyle(globalPrefixCls, theme);
      if (canUseDom()) {
        updateCSS(style, `${dynamicStyleMark}-dynamic-theme`);
      }
    }

    const DisabledContext = /*#__PURE__*/reactExports.createContext(false);
    const DisabledContextProvider = _ref => {
      let {
        children,
        disabled
      } = _ref;
      const originDisabled = reactExports.useContext(DisabledContext);
      return /*#__PURE__*/reactExports.createElement(DisabledContext.Provider, {
        value: disabled !== null && disabled !== void 0 ? disabled : originDisabled
      }, children);
    };

    const SizeContext = /*#__PURE__*/reactExports.createContext(undefined);
    const SizeContextProvider = _ref => {
      let {
        children,
        size
      } = _ref;
      const originSize = reactExports.useContext(SizeContext);
      return /*#__PURE__*/reactExports.createElement(SizeContext.Provider, {
        value: size || originSize
      }, children);
    };

    function useConfig() {
      const componentDisabled = reactExports.useContext(DisabledContext);
      const componentSize = reactExports.useContext(SizeContext);
      return {
        componentDisabled,
        componentSize
      };
    }

    var AbstractCalculator = /*#__PURE__*/_createClass(function AbstractCalculator() {
      _classCallCheck(this, AbstractCalculator);
    });

    var CALC_UNIT = 'CALC_UNIT';
    var regexp$1 = new RegExp(CALC_UNIT, 'g');
    function unit(value) {
      if (typeof value === 'number') {
        return "".concat(value).concat(CALC_UNIT);
      }
      return value;
    }
    var CSSCalculator = /*#__PURE__*/function (_AbstractCalculator) {
      _inherits(CSSCalculator, _AbstractCalculator);
      var _super = _createSuper(CSSCalculator);
      function CSSCalculator(num, unitlessCssVar) {
        var _this;
        _classCallCheck(this, CSSCalculator);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "result", '');
        _defineProperty(_assertThisInitialized(_this), "unitlessCssVar", void 0);
        _defineProperty(_assertThisInitialized(_this), "lowPriority", void 0);
        var numType = _typeof(num);
        _this.unitlessCssVar = unitlessCssVar;
        if (num instanceof CSSCalculator) {
          _this.result = "(".concat(num.result, ")");
        } else if (numType === 'number') {
          _this.result = unit(num);
        } else if (numType === 'string') {
          _this.result = num;
        }
        return _this;
      }
      _createClass(CSSCalculator, [{
        key: "add",
        value: function add(num) {
          if (num instanceof CSSCalculator) {
            this.result = "".concat(this.result, " + ").concat(num.getResult());
          } else if (typeof num === 'number' || typeof num === 'string') {
            this.result = "".concat(this.result, " + ").concat(unit(num));
          }
          this.lowPriority = true;
          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          if (num instanceof CSSCalculator) {
            this.result = "".concat(this.result, " - ").concat(num.getResult());
          } else if (typeof num === 'number' || typeof num === 'string') {
            this.result = "".concat(this.result, " - ").concat(unit(num));
          }
          this.lowPriority = true;
          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          if (this.lowPriority) {
            this.result = "(".concat(this.result, ")");
          }
          if (num instanceof CSSCalculator) {
            this.result = "".concat(this.result, " * ").concat(num.getResult(true));
          } else if (typeof num === 'number' || typeof num === 'string') {
            this.result = "".concat(this.result, " * ").concat(num);
          }
          this.lowPriority = false;
          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          if (this.lowPriority) {
            this.result = "(".concat(this.result, ")");
          }
          if (num instanceof CSSCalculator) {
            this.result = "".concat(this.result, " / ").concat(num.getResult(true));
          } else if (typeof num === 'number' || typeof num === 'string') {
            this.result = "".concat(this.result, " / ").concat(num);
          }
          this.lowPriority = false;
          return this;
        }
      }, {
        key: "getResult",
        value: function getResult(force) {
          return this.lowPriority || force ? "(".concat(this.result, ")") : this.result;
        }
      }, {
        key: "equal",
        value: function equal(options) {
          var _this2 = this;
          var _ref = options || {},
            cssUnit = _ref.unit;
          var mergedUnit = true;
          if (typeof cssUnit === 'boolean') {
            mergedUnit = cssUnit;
          } else if (Array.from(this.unitlessCssVar).some(function (cssVar) {
            return _this2.result.includes(cssVar);
          })) {
            mergedUnit = false;
          }
          this.result = this.result.replace(regexp$1, mergedUnit ? 'px' : '');
          if (typeof this.lowPriority !== 'undefined') {
            return "calc(".concat(this.result, ")");
          }
          return this.result;
        }
      }]);
      return CSSCalculator;
    }(AbstractCalculator);

    var NumCalculator = /*#__PURE__*/function (_AbstractCalculator) {
      _inherits(NumCalculator, _AbstractCalculator);
      var _super = _createSuper(NumCalculator);
      function NumCalculator(num) {
        var _this;
        _classCallCheck(this, NumCalculator);
        _this = _super.call(this);
        _defineProperty(_assertThisInitialized(_this), "result", 0);
        if (num instanceof NumCalculator) {
          _this.result = num.result;
        } else if (typeof num === 'number') {
          _this.result = num;
        }
        return _this;
      }
      _createClass(NumCalculator, [{
        key: "add",
        value: function add(num) {
          if (num instanceof NumCalculator) {
            this.result += num.result;
          } else if (typeof num === 'number') {
            this.result += num;
          }
          return this;
        }
      }, {
        key: "sub",
        value: function sub(num) {
          if (num instanceof NumCalculator) {
            this.result -= num.result;
          } else if (typeof num === 'number') {
            this.result -= num;
          }
          return this;
        }
      }, {
        key: "mul",
        value: function mul(num) {
          if (num instanceof NumCalculator) {
            this.result *= num.result;
          } else if (typeof num === 'number') {
            this.result *= num;
          }
          return this;
        }
      }, {
        key: "div",
        value: function div(num) {
          if (num instanceof NumCalculator) {
            this.result /= num.result;
          } else if (typeof num === 'number') {
            this.result /= num;
          }
          return this;
        }
      }, {
        key: "equal",
        value: function equal() {
          return this.result;
        }
      }]);
      return NumCalculator;
    }(AbstractCalculator);

    var genCalc = function genCalc(type, unitlessCssVar) {
      var Calculator = type === 'css' ? CSSCalculator : NumCalculator;
      return function (num) {
        return new Calculator(num, unitlessCssVar);
      };
    };

    var getCompVarPrefix = function getCompVarPrefix(component, prefix) {
      return "".concat([prefix, component.replace(/([A-Z]+)([A-Z][a-z]+)/g, '$1-$2').replace(/([a-z])([A-Z])/g, '$1-$2')].filter(Boolean).join('-'));
    };

    function useEvent(callback) {
      var fnRef = reactExports.useRef();
      fnRef.current = callback;
      var memoFn = reactExports.useCallback(function () {
        var _fnRef$current;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
      }, []);
      return memoFn;
    }

    /**
     * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
     * We do not make this auto is to avoid real memory leak.
     * Developer should confirm it's safe to ignore themselves.
     */
    function useSafeState(defaultValue) {
      var destroyRef = reactExports.useRef(false);
      var _React$useState = reactExports.useState(defaultValue),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        value = _React$useState2[0],
        setValue = _React$useState2[1];
      reactExports.useEffect(function () {
        destroyRef.current = false;
        return function () {
          destroyRef.current = true;
        };
      }, []);
      function safeSetState(updater, ignoreDestroy) {
        if (ignoreDestroy && destroyRef.current) {
          return;
        }
        setValue(updater);
      }
      return [value, safeSetState];
    }

    /** We only think `undefined` is empty */
    function hasValue(value) {
      return value !== undefined;
    }

    /**
     * Similar to `useState` but will use props value if provided.
     * Note that internal use rc-util `useState` hook.
     */
    function useMergedState(defaultStateValue, option) {
      var _ref = option || {},
        defaultValue = _ref.defaultValue,
        value = _ref.value,
        onChange = _ref.onChange,
        postState = _ref.postState;

      // ======================= Init =======================
      var _useState = useSafeState(function () {
          if (hasValue(value)) {
            return value;
          } else if (hasValue(defaultValue)) {
            return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
          } else {
            return typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
          }
        }),
        _useState2 = _slicedToArray(_useState, 2),
        innerValue = _useState2[0],
        setInnerValue = _useState2[1];
      var mergedValue = value !== undefined ? value : innerValue;
      var postMergedValue = postState ? postState(mergedValue) : mergedValue;

      // ====================== Change ======================
      var onChangeFn = useEvent(onChange);
      var _useState3 = useSafeState([mergedValue]),
        _useState4 = _slicedToArray(_useState3, 2),
        prevValue = _useState4[0],
        setPrevValue = _useState4[1];
      useLayoutUpdateEffect(function () {
        var prev = prevValue[0];
        if (innerValue !== prev) {
          onChangeFn(innerValue, prev);
        }
      }, [prevValue]);

      // Sync value back to `undefined` when it from control to un-control
      useLayoutUpdateEffect(function () {
        if (!hasValue(value)) {
          setInnerValue(value);
        }
      }, [value]);

      // ====================== Update ======================
      var triggerChange = useEvent(function (updater, ignoreDestroy) {
        setInnerValue(updater, ignoreDestroy);
        setPrevValue([mergedValue], ignoreDestroy);
      });
      return [postMergedValue, triggerChange];
    }

    function getComponentToken(component, token, defaultToken, options) {
      var customToken = _objectSpread2({}, token[component]);
      if (options !== null && options !== void 0 && options.deprecatedTokens) {
        var deprecatedTokens = options.deprecatedTokens;
        deprecatedTokens.forEach(function (_ref) {
          var _ref2 = _slicedToArray(_ref, 2),
            oldTokenKey = _ref2[0],
            newTokenKey = _ref2[1];

          // Should wrap with `if` clause, or there will be `undefined` in object.
          if (customToken !== null && customToken !== void 0 && customToken[oldTokenKey] || customToken !== null && customToken !== void 0 && customToken[newTokenKey]) {
            var _customToken$newToken;
            (_customToken$newToken = customToken[newTokenKey]) !== null && _customToken$newToken !== void 0 ? _customToken$newToken : customToken[newTokenKey] = customToken === null || customToken === void 0 ? void 0 : customToken[oldTokenKey];
          }
        });
      }
      var mergedToken = _objectSpread2(_objectSpread2({}, defaultToken), customToken);

      // Remove same value as global token to minimize size
      Object.keys(mergedToken).forEach(function (key) {
        if (mergedToken[key] === token[key]) {
          delete mergedToken[key];
        }
      });
      return mergedToken;
    }

    var enableStatistic = typeof CSSINJS_STATISTIC !== 'undefined';
    var recording = true;

    /**
     * This function will do as `Object.assign` in production. But will use Object.defineProperty:get to
     * pass all value access in development. To support statistic field usage with alias token.
     */
    function merge$1() {
      for (var _len = arguments.length, objs = new Array(_len), _key = 0; _key < _len; _key++) {
        objs[_key] = arguments[_key];
      }
      /* istanbul ignore next */
      if (!enableStatistic) {
        return Object.assign.apply(Object, [{}].concat(objs));
      }
      recording = false;
      var ret = {};
      objs.forEach(function (obj) {
        if (_typeof(obj) !== 'object') {
          return;
        }
        var keys = Object.keys(obj);
        keys.forEach(function (key) {
          Object.defineProperty(ret, key, {
            configurable: true,
            enumerable: true,
            get: function get() {
              return obj[key];
            }
          });
        });
      });
      recording = true;
      return ret;
    }

    /** @internal Internal Usage. Not use in your production. */
    var statistic = {};

    /* istanbul ignore next */
    function noop$1() {}

    /** Statistic token usage case. Should use `merge` function if you do not want spread record. */
    var statisticToken = function statisticToken(token) {
      var tokenKeys;
      var proxy = token;
      var flush = noop$1;
      if (enableStatistic && typeof Proxy !== 'undefined') {
        tokenKeys = new Set();
        proxy = new Proxy(token, {
          get: function get(obj, prop) {
            if (recording) {
              var _tokenKeys;
              (_tokenKeys = tokenKeys) === null || _tokenKeys === void 0 || _tokenKeys.add(prop);
            }
            return obj[prop];
          }
        });
        flush = function flush(componentName, componentToken) {
          var _statistic$componentN;
          statistic[componentName] = {
            global: Array.from(tokenKeys),
            component: _objectSpread2(_objectSpread2({}, (_statistic$componentN = statistic[componentName]) === null || _statistic$componentN === void 0 ? void 0 : _statistic$componentN.component), componentToken)
          };
        };
      }
      return {
        token: proxy,
        keys: tokenKeys,
        flush: flush
      };
    };

    function getDefaultComponentToken(component, token, getDefaultToken) {
      if (typeof getDefaultToken === 'function') {
        var _token$component;
        return getDefaultToken(merge$1(token, (_token$component = token[component]) !== null && _token$component !== void 0 ? _token$component : {}));
      }
      return getDefaultToken !== null && getDefaultToken !== void 0 ? getDefaultToken : {};
    }

    function genMaxMin(type) {
      if (type === 'js') {
        return {
          max: Math.max,
          min: Math.min
        };
      }
      return {
        max: function max() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return "max(".concat(args.map(function (value) {
            return unit$1(value);
          }).join(','), ")");
        },
        min: function min() {
          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }
          return "min(".concat(args.map(function (value) {
            return unit$1(value);
          }).join(','), ")");
        }
      };
    }

    var BEAT_LIMIT = 1000 * 60 * 10;

    /**
     * A helper class to map keys to values.
     * It supports both primitive keys and object keys.
     */
    var ArrayKeyMap = /*#__PURE__*/function () {
      function ArrayKeyMap() {
        _classCallCheck(this, ArrayKeyMap);
        _defineProperty(this, "map", new Map());
        // Use WeakMap to avoid memory leak
        _defineProperty(this, "objectIDMap", new WeakMap());
        _defineProperty(this, "nextID", 0);
        _defineProperty(this, "lastAccessBeat", new Map());
        // We will clean up the cache when reach the limit
        _defineProperty(this, "accessBeat", 0);
      }
      _createClass(ArrayKeyMap, [{
        key: "set",
        value: function set(keys, value) {
          // New set will trigger clear
          this.clear();

          // Set logic
          var compositeKey = this.getCompositeKey(keys);
          this.map.set(compositeKey, value);
          this.lastAccessBeat.set(compositeKey, Date.now());
        }
      }, {
        key: "get",
        value: function get(keys) {
          var compositeKey = this.getCompositeKey(keys);
          var cache = this.map.get(compositeKey);
          this.lastAccessBeat.set(compositeKey, Date.now());
          this.accessBeat += 1;
          return cache;
        }
      }, {
        key: "getCompositeKey",
        value: function getCompositeKey(keys) {
          var _this = this;
          var ids = keys.map(function (key) {
            if (key && _typeof(key) === 'object') {
              return "obj_".concat(_this.getObjectID(key));
            }
            return "".concat(_typeof(key), "_").concat(key);
          });
          return ids.join('|');
        }
      }, {
        key: "getObjectID",
        value: function getObjectID(obj) {
          if (this.objectIDMap.has(obj)) {
            return this.objectIDMap.get(obj);
          }
          var id = this.nextID;
          this.objectIDMap.set(obj, id);
          this.nextID += 1;
          return id;
        }
      }, {
        key: "clear",
        value: function clear() {
          var _this2 = this;
          if (this.accessBeat > 10000) {
            var now = Date.now();
            this.lastAccessBeat.forEach(function (beat, key) {
              if (now - beat > BEAT_LIMIT) {
                _this2.map.delete(key);
                _this2.lastAccessBeat.delete(key);
              }
            });
            this.accessBeat = 0;
          }
        }
      }]);
      return ArrayKeyMap;
    }();
    var uniqueMap = new ArrayKeyMap();

    /**
     * Like `useMemo`, but this hook result will be shared across all instances.
     */
    function useUniqueMemo(memoFn, deps) {
      return React.useMemo(function () {
        var cachedValue = uniqueMap.get(deps);
        if (cachedValue) {
          return cachedValue;
        }
        var newValue = memoFn();
        uniqueMap.set(deps, newValue);
        return newValue;
      }, deps);
    }

    /**
     * Provide a default hook since not everyone needs to config this.
     */
    var useDefaultCSP = function useDefaultCSP() {
      return {};
    };

    function genStyleUtils(config) {
      // Dependency inversion for preparing basic config.
      var _config$useCSP = config.useCSP,
        useCSP = _config$useCSP === void 0 ? useDefaultCSP : _config$useCSP,
        useToken = config.useToken,
        usePrefix = config.usePrefix,
        getResetStyles = config.getResetStyles,
        getCommonStyle = config.getCommonStyle,
        getCompUnitless = config.getCompUnitless;
      function genStyleHooks(component, styleFn, getDefaultToken, options) {
        var componentName = Array.isArray(component) ? component[0] : component;
        function prefixToken(key) {
          return "".concat(String(componentName)).concat(key.slice(0, 1).toUpperCase()).concat(key.slice(1));
        }

        // Fill unitless
        var originUnitless = (options === null || options === void 0 ? void 0 : options.unitless) || {};
        var originCompUnitless = typeof getCompUnitless === 'function' ? getCompUnitless(component) : {};
        var compUnitless = _objectSpread2(_objectSpread2({}, originCompUnitless), {}, _defineProperty({}, prefixToken('zIndexPopup'), true));
        Object.keys(originUnitless).forEach(function (key) {
          compUnitless[prefixToken(key)] = originUnitless[key];
        });

        // Options
        var mergedOptions = _objectSpread2(_objectSpread2({}, options), {}, {
          unitless: compUnitless,
          prefixToken: prefixToken
        });

        // Hooks
        var useStyle = genComponentStyleHook(component, styleFn, getDefaultToken, mergedOptions);
        var useCSSVar = genCSSVarRegister(componentName, getDefaultToken, mergedOptions);
        return function (prefixCls) {
          var rootCls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prefixCls;
          var _useStyle = useStyle(prefixCls, rootCls),
            _useStyle2 = _slicedToArray(_useStyle, 2),
            hashId = _useStyle2[1];
          var _useCSSVar = useCSSVar(rootCls),
            _useCSSVar2 = _slicedToArray(_useCSSVar, 2),
            wrapCSSVar = _useCSSVar2[0],
            cssVarCls = _useCSSVar2[1];
          return [wrapCSSVar, hashId, cssVarCls];
        };
      }
      function genCSSVarRegister(component, getDefaultToken, options) {
        var compUnitless = options.unitless,
          _options$injectStyle = options.injectStyle,
          injectStyle = _options$injectStyle === void 0 ? true : _options$injectStyle,
          prefixToken = options.prefixToken,
          ignore = options.ignore;
        var CSSVarRegister = function CSSVarRegister(_ref) {
          var rootCls = _ref.rootCls,
            _ref$cssVar = _ref.cssVar,
            cssVar = _ref$cssVar === void 0 ? {} : _ref$cssVar;
          var _useToken = useToken(),
            realToken = _useToken.realToken;
          useCSSVarRegister({
            path: [component],
            prefix: cssVar.prefix,
            key: cssVar.key,
            unitless: compUnitless,
            ignore: ignore,
            token: realToken,
            scope: rootCls
          }, function () {
            var defaultToken = getDefaultComponentToken(component, realToken, getDefaultToken);
            var componentToken = getComponentToken(component, realToken, defaultToken, {
              deprecatedTokens: options === null || options === void 0 ? void 0 : options.deprecatedTokens
            });
            Object.keys(defaultToken).forEach(function (key) {
              componentToken[prefixToken(key)] = componentToken[key];
              delete componentToken[key];
            });
            return componentToken;
          });
          return null;
        };
        var useCSSVar = function useCSSVar(rootCls) {
          var _useToken2 = useToken(),
            cssVar = _useToken2.cssVar;
          return [function (node) {
            return injectStyle && cssVar ? /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(CSSVarRegister, {
              rootCls: rootCls,
              cssVar: cssVar,
              component: component
            }), node) : node;
          }, cssVar === null || cssVar === void 0 ? void 0 : cssVar.key];
        };
        return useCSSVar;
      }
      function genComponentStyleHook(componentName, styleFn, getDefaultToken) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var cells = Array.isArray(componentName) ? componentName : [componentName, componentName];
        var _cells = _slicedToArray(cells, 1),
          component = _cells[0];
        var concatComponent = cells.join('-');
        var mergedLayer = config.layer || {
          name: 'antd'
        };

        // Return new style hook
        return function (prefixCls) {
          var rootCls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : prefixCls;
          var _useToken3 = useToken(),
            theme = _useToken3.theme,
            realToken = _useToken3.realToken,
            hashId = _useToken3.hashId,
            token = _useToken3.token,
            cssVar = _useToken3.cssVar;
          var _usePrefix = usePrefix(),
            rootPrefixCls = _usePrefix.rootPrefixCls,
            iconPrefixCls = _usePrefix.iconPrefixCls;
          var csp = useCSP();
          var type = cssVar ? 'css' : 'js';

          // Use unique memo to share the result across all instances
          var calc = useUniqueMemo(function () {
            var unitlessCssVar = new Set();
            if (cssVar) {
              Object.keys(options.unitless || {}).forEach(function (key) {
                // Some component proxy the AliasToken (e.g. Image) and some not (e.g. Modal)
                // We should both pass in `unitlessCssVar` to make sure the CSSVar can be unitless.
                unitlessCssVar.add(token2CSSVar(key, cssVar.prefix));
                unitlessCssVar.add(token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix)));
              });
            }
            return genCalc(type, unitlessCssVar);
          }, [type, component, cssVar === null || cssVar === void 0 ? void 0 : cssVar.prefix]);
          var _genMaxMin = genMaxMin(type),
            max = _genMaxMin.max,
            min = _genMaxMin.min;

          // Shared config
          var sharedConfig = {
            theme: theme,
            token: token,
            hashId: hashId,
            nonce: function nonce() {
              return csp.nonce;
            },
            clientOnly: options.clientOnly,
            layer: mergedLayer,
            // antd is always at top of styles
            order: options.order || -999
          };

          // This if statement is safe, as it will only be used if the generator has the function. It's not dynamic.
          if (typeof getResetStyles === 'function') {
            // Generate style for all need reset tags.
            useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
              clientOnly: false,
              path: ['Shared', rootPrefixCls]
            }), function () {
              return getResetStyles(token, {
                prefix: {
                  rootPrefixCls: rootPrefixCls,
                  iconPrefixCls: iconPrefixCls
                },
                csp: csp
              });
            });
          }
          var wrapSSR = useStyleRegister(_objectSpread2(_objectSpread2({}, sharedConfig), {}, {
            path: [concatComponent, prefixCls, iconPrefixCls]
          }), function () {
            if (options.injectStyle === false) {
              return [];
            }
            var _statisticToken = statisticToken(token),
              proxyToken = _statisticToken.token,
              flush = _statisticToken.flush;
            var defaultComponentToken = getDefaultComponentToken(component, realToken, getDefaultToken);
            var componentCls = ".".concat(prefixCls);
            var componentToken = getComponentToken(component, realToken, defaultComponentToken, {
              deprecatedTokens: options.deprecatedTokens
            });
            if (cssVar && defaultComponentToken && _typeof(defaultComponentToken) === 'object') {
              Object.keys(defaultComponentToken).forEach(function (key) {
                defaultComponentToken[key] = "var(".concat(token2CSSVar(key, getCompVarPrefix(component, cssVar.prefix)), ")");
              });
            }
            var mergedToken = merge$1(proxyToken, {
              componentCls: componentCls,
              prefixCls: prefixCls,
              iconCls: ".".concat(iconPrefixCls),
              antCls: ".".concat(rootPrefixCls),
              calc: calc,
              // @ts-ignore
              max: max,
              // @ts-ignore
              min: min
            }, cssVar ? defaultComponentToken : componentToken);
            var styleInterpolation = styleFn(mergedToken, {
              hashId: hashId,
              prefixCls: prefixCls,
              rootPrefixCls: rootPrefixCls,
              iconPrefixCls: iconPrefixCls
            });
            flush(component, componentToken);
            var commonStyle = typeof getCommonStyle === 'function' ? getCommonStyle(mergedToken, prefixCls, rootCls, options.resetFont) : null;
            return [options.resetStyle === false ? null : commonStyle, styleInterpolation];
          });
          return [wrapSSR, hashId];
        };
      }
      function genSubStyleComponent(componentName, styleFn, getDefaultToken) {
        var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
        var useStyle = genComponentStyleHook(componentName, styleFn, getDefaultToken, _objectSpread2({
          resetStyle: false,
          // Sub Style should default after root one
          order: -998
        }, options));
        var StyledComponent = function StyledComponent(_ref2) {
          var prefixCls = _ref2.prefixCls,
            _ref2$rootCls = _ref2.rootCls,
            rootCls = _ref2$rootCls === void 0 ? prefixCls : _ref2$rootCls;
          useStyle(prefixCls, rootCls);
          return null;
        };
        return StyledComponent;
      }
      return {
        genStyleHooks: genStyleHooks,
        genSubStyleComponent: genSubStyleComponent,
        genComponentStyleHook: genComponentStyleHook
      };
    }

    const PresetColors = ['blue', 'purple', 'cyan', 'green', 'magenta', 'pink', 'red', 'orange', 'yellow', 'volcano', 'geekblue', 'lime', 'gold'];

    var version$1 = '5.23.1';

    function isStableColor(color) {
      return color >= 0 && color <= 255;
    }
    function getAlphaColor(frontColor, backgroundColor) {
      const {
        r: fR,
        g: fG,
        b: fB,
        a: originAlpha
      } = new FastColor(frontColor).toRgb();
      if (originAlpha < 1) {
        return frontColor;
      }
      const {
        r: bR,
        g: bG,
        b: bB
      } = new FastColor(backgroundColor).toRgb();
      for (let fA = 0.01; fA <= 1; fA += 0.01) {
        const r = Math.round((fR - bR * (1 - fA)) / fA);
        const g = Math.round((fG - bG * (1 - fA)) / fA);
        const b = Math.round((fB - bB * (1 - fA)) / fA);
        if (isStableColor(r) && isStableColor(g) && isStableColor(b)) {
          return new FastColor({
            r,
            g,
            b,
            a: Math.round(fA * 100) / 100
          }).toRgbString();
        }
      }
      // fallback
      /* istanbul ignore next */
      return new FastColor({
        r: fR,
        g: fG,
        b: fB,
        a: 1
      }).toRgbString();
    }

    var __rest$d = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    /**
     * Seed (designer) > Derivative (designer) > Alias (developer).
     *
     * Merge seed & derivative & override token and generate alias token for developer.
     */
    function formatToken(derivativeToken) {
      const {
          override
        } = derivativeToken,
        restToken = __rest$d(derivativeToken, ["override"]);
      const overrideTokens = Object.assign({}, override);
      Object.keys(seedToken).forEach(token => {
        delete overrideTokens[token];
      });
      const mergedToken = Object.assign(Object.assign({}, restToken), overrideTokens);
      const screenXS = 480;
      const screenSM = 576;
      const screenMD = 768;
      const screenLG = 992;
      const screenXL = 1200;
      const screenXXL = 1600;
      // Motion
      if (mergedToken.motion === false) {
        const fastDuration = '0s';
        mergedToken.motionDurationFast = fastDuration;
        mergedToken.motionDurationMid = fastDuration;
        mergedToken.motionDurationSlow = fastDuration;
      }
      // Generate alias token
      const aliasToken = Object.assign(Object.assign(Object.assign({}, mergedToken), {
        // ============== Background ============== //
        colorFillContent: mergedToken.colorFillSecondary,
        colorFillContentHover: mergedToken.colorFill,
        colorFillAlter: mergedToken.colorFillQuaternary,
        colorBgContainerDisabled: mergedToken.colorFillTertiary,
        // ============== Split ============== //
        colorBorderBg: mergedToken.colorBgContainer,
        colorSplit: getAlphaColor(mergedToken.colorBorderSecondary, mergedToken.colorBgContainer),
        // ============== Text ============== //
        colorTextPlaceholder: mergedToken.colorTextQuaternary,
        colorTextDisabled: mergedToken.colorTextQuaternary,
        colorTextHeading: mergedToken.colorText,
        colorTextLabel: mergedToken.colorTextSecondary,
        colorTextDescription: mergedToken.colorTextTertiary,
        colorTextLightSolid: mergedToken.colorWhite,
        colorHighlight: mergedToken.colorError,
        colorBgTextHover: mergedToken.colorFillSecondary,
        colorBgTextActive: mergedToken.colorFill,
        colorIcon: mergedToken.colorTextTertiary,
        colorIconHover: mergedToken.colorText,
        colorErrorOutline: getAlphaColor(mergedToken.colorErrorBg, mergedToken.colorBgContainer),
        colorWarningOutline: getAlphaColor(mergedToken.colorWarningBg, mergedToken.colorBgContainer),
        // Font
        fontSizeIcon: mergedToken.fontSizeSM,
        // Line
        lineWidthFocus: mergedToken.lineWidth * 3,
        // Control
        lineWidth: mergedToken.lineWidth,
        controlOutlineWidth: mergedToken.lineWidth * 2,
        // Checkbox size and expand icon size
        controlInteractiveSize: mergedToken.controlHeight / 2,
        controlItemBgHover: mergedToken.colorFillTertiary,
        controlItemBgActive: mergedToken.colorPrimaryBg,
        controlItemBgActiveHover: mergedToken.colorPrimaryBgHover,
        controlItemBgActiveDisabled: mergedToken.colorFill,
        controlTmpOutline: mergedToken.colorFillQuaternary,
        controlOutline: getAlphaColor(mergedToken.colorPrimaryBg, mergedToken.colorBgContainer),
        lineType: mergedToken.lineType,
        borderRadius: mergedToken.borderRadius,
        borderRadiusXS: mergedToken.borderRadiusXS,
        borderRadiusSM: mergedToken.borderRadiusSM,
        borderRadiusLG: mergedToken.borderRadiusLG,
        fontWeightStrong: 600,
        opacityLoading: 0.65,
        linkDecoration: 'none',
        linkHoverDecoration: 'none',
        linkFocusDecoration: 'none',
        controlPaddingHorizontal: 12,
        controlPaddingHorizontalSM: 8,
        paddingXXS: mergedToken.sizeXXS,
        paddingXS: mergedToken.sizeXS,
        paddingSM: mergedToken.sizeSM,
        padding: mergedToken.size,
        paddingMD: mergedToken.sizeMD,
        paddingLG: mergedToken.sizeLG,
        paddingXL: mergedToken.sizeXL,
        paddingContentHorizontalLG: mergedToken.sizeLG,
        paddingContentVerticalLG: mergedToken.sizeMS,
        paddingContentHorizontal: mergedToken.sizeMS,
        paddingContentVertical: mergedToken.sizeSM,
        paddingContentHorizontalSM: mergedToken.size,
        paddingContentVerticalSM: mergedToken.sizeXS,
        marginXXS: mergedToken.sizeXXS,
        marginXS: mergedToken.sizeXS,
        marginSM: mergedToken.sizeSM,
        margin: mergedToken.size,
        marginMD: mergedToken.sizeMD,
        marginLG: mergedToken.sizeLG,
        marginXL: mergedToken.sizeXL,
        marginXXL: mergedToken.sizeXXL,
        boxShadow: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowSecondary: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTertiary: `
      0 1px 2px 0 rgba(0, 0, 0, 0.03),
      0 1px 6px -1px rgba(0, 0, 0, 0.02),
      0 2px 4px 0 rgba(0, 0, 0, 0.02)
    `,
        screenXS,
        screenXSMin: screenXS,
        screenXSMax: screenSM - 1,
        screenSM,
        screenSMMin: screenSM,
        screenSMMax: screenMD - 1,
        screenMD,
        screenMDMin: screenMD,
        screenMDMax: screenLG - 1,
        screenLG,
        screenLGMin: screenLG,
        screenLGMax: screenXL - 1,
        screenXL,
        screenXLMin: screenXL,
        screenXLMax: screenXXL - 1,
        screenXXL,
        screenXXLMin: screenXXL,
        boxShadowPopoverArrow: '2px 2px 5px rgba(0, 0, 0, 0.05)',
        boxShadowCard: `
      0 1px 2px -2px ${new FastColor('rgba(0, 0, 0, 0.16)').toRgbString()},
      0 3px 6px 0 ${new FastColor('rgba(0, 0, 0, 0.12)').toRgbString()},
      0 5px 12px 4px ${new FastColor('rgba(0, 0, 0, 0.09)').toRgbString()}
    `,
        boxShadowDrawerRight: `
      -6px 0 16px 0 rgba(0, 0, 0, 0.08),
      -3px 0 6px -4px rgba(0, 0, 0, 0.12),
      -9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerLeft: `
      6px 0 16px 0 rgba(0, 0, 0, 0.08),
      3px 0 6px -4px rgba(0, 0, 0, 0.12),
      9px 0 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerUp: `
      0 6px 16px 0 rgba(0, 0, 0, 0.08),
      0 3px 6px -4px rgba(0, 0, 0, 0.12),
      0 9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowDrawerDown: `
      0 -6px 16px 0 rgba(0, 0, 0, 0.08),
      0 -3px 6px -4px rgba(0, 0, 0, 0.12),
      0 -9px 28px 8px rgba(0, 0, 0, 0.05)
    `,
        boxShadowTabsOverflowLeft: 'inset 10px 0 8px -8px rgba(0, 0, 0, 0.08)',
        boxShadowTabsOverflowRight: 'inset -10px 0 8px -8px rgba(0, 0, 0, 0.08)',
        boxShadowTabsOverflowTop: 'inset 0 10px 8px -8px rgba(0, 0, 0, 0.08)',
        boxShadowTabsOverflowBottom: 'inset 0 -10px 8px -8px rgba(0, 0, 0, 0.08)'
      }), overrideTokens);
      return aliasToken;
    }

    var __rest$c = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const unitless = {
      lineHeight: true,
      lineHeightSM: true,
      lineHeightLG: true,
      lineHeightHeading1: true,
      lineHeightHeading2: true,
      lineHeightHeading3: true,
      lineHeightHeading4: true,
      lineHeightHeading5: true,
      opacityLoading: true,
      fontWeightStrong: true,
      zIndexPopupBase: true,
      zIndexBase: true,
      opacityImage: true
    };
    const ignore = {
      size: true,
      sizeSM: true,
      sizeLG: true,
      sizeMD: true,
      sizeXS: true,
      sizeXXS: true,
      sizeMS: true,
      sizeXL: true,
      sizeXXL: true,
      sizeUnit: true,
      sizeStep: true,
      motionBase: true,
      motionUnit: true
    };
    const preserve = {
      screenXS: true,
      screenXSMin: true,
      screenXSMax: true,
      screenSM: true,
      screenSMMin: true,
      screenSMMax: true,
      screenMD: true,
      screenMDMin: true,
      screenMDMax: true,
      screenLG: true,
      screenLGMin: true,
      screenLGMax: true,
      screenXL: true,
      screenXLMin: true,
      screenXLMax: true,
      screenXXL: true,
      screenXXLMin: true
    };
    const getComputedToken = (originToken, overrideToken, theme) => {
      const derivativeToken = theme.getDerivativeToken(originToken);
      const {
          override
        } = overrideToken,
        components = __rest$c(overrideToken, ["override"]);
      // Merge with override
      let mergedDerivativeToken = Object.assign(Object.assign({}, derivativeToken), {
        override
      });
      // Format if needed
      mergedDerivativeToken = formatToken(mergedDerivativeToken);
      if (components) {
        Object.entries(components).forEach(_ref => {
          let [key, value] = _ref;
          const {
              theme: componentTheme
            } = value,
            componentTokens = __rest$c(value, ["theme"]);
          let mergedComponentToken = componentTokens;
          if (componentTheme) {
            mergedComponentToken = getComputedToken(Object.assign(Object.assign({}, mergedDerivativeToken), componentTokens), {
              override: componentTokens
            }, componentTheme);
          }
          mergedDerivativeToken[key] = mergedComponentToken;
        });
      }
      return mergedDerivativeToken;
    };
    // ================================== Hook ==================================
    function useToken() {
      const {
        token: rootDesignToken,
        hashed,
        theme,
        override,
        cssVar
      } = React.useContext(DesignTokenContext);
      const salt = `${version$1}-${hashed || ''}`;
      const mergedTheme = theme || defaultTheme;
      const [token, hashId, realToken] = useCacheToken(mergedTheme, [seedToken, rootDesignToken], {
        salt,
        override,
        getComputedToken,
        // formatToken will not be consumed after 1.15.0 with getComputedToken.
        // But token will break if @ant-design/cssinjs is under 1.15.0 without it
        formatToken,
        cssVar: cssVar && {
          prefix: cssVar.prefix,
          key: cssVar.key,
          unitless,
          ignore,
          preserve
        }
      });
      return [mergedTheme, realToken, hashed ? hashId : '', token, cssVar];
    }

    const resetComponent = function (token) {
      let needInheritFontFamily = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return {
        boxSizing: 'border-box',
        margin: 0,
        padding: 0,
        color: token.colorText,
        fontSize: token.fontSize,
        // font-variant: @font-variant-base;
        lineHeight: token.lineHeight,
        listStyle: 'none',
        // font-feature-settings: @font-feature-settings-base;
        fontFamily: needInheritFontFamily ? 'inherit' : token.fontFamily
      };
    };
    const resetIcon = () => ({
      display: 'inline-flex',
      alignItems: 'center',
      color: 'inherit',
      fontStyle: 'normal',
      lineHeight: 0,
      textAlign: 'center',
      textTransform: 'none',
      // for SVG icon, see https://blog.prototypr.io/align-svg-icons-to-text-and-say-goodbye-to-font-icons-d44b3d7b26b4
      verticalAlign: '-0.125em',
      textRendering: 'optimizeLegibility',
      '-webkit-font-smoothing': 'antialiased',
      '-moz-osx-font-smoothing': 'grayscale',
      '> *': {
        lineHeight: 1
      },
      svg: {
        display: 'inline-block'
      }
    });
    const clearFix = () => ({
      // https://github.com/ant-design/ant-design/issues/21301#issuecomment-583955229
      '&::before': {
        display: 'table',
        content: '""'
      },
      '&::after': {
        // https://github.com/ant-design/ant-design/issues/21864
        display: 'table',
        clear: 'both',
        content: '""'
      }
    });
    const genLinkStyle = token => ({
      a: {
        color: token.colorLink,
        textDecoration: token.linkDecoration,
        backgroundColor: 'transparent',
        // remove the gray background on active links in IE 10.
        outline: 'none',
        cursor: 'pointer',
        transition: `color ${token.motionDurationSlow}`,
        '-webkit-text-decoration-skip': 'objects',
        // remove gaps in links underline in iOS 8+ and Safari 8+.
        '&:hover': {
          color: token.colorLinkHover
        },
        '&:active': {
          color: token.colorLinkActive
        },
        '&:active, &:hover': {
          textDecoration: token.linkHoverDecoration,
          outline: 0
        },
        // https://github.com/ant-design/ant-design/issues/22503
        '&:focus': {
          textDecoration: token.linkFocusDecoration,
          outline: 0
        },
        '&[disabled]': {
          color: token.colorTextDisabled,
          cursor: 'not-allowed'
        }
      }
    });
    const genCommonStyle = (token, componentPrefixCls, rootCls, resetFont) => {
      const prefixSelector = `[class^="${componentPrefixCls}"], [class*=" ${componentPrefixCls}"]`;
      const rootPrefixSelector = rootCls ? `.${rootCls}` : prefixSelector;
      const resetStyle = {
        boxSizing: 'border-box',
        '&::before, &::after': {
          boxSizing: 'border-box'
        }
      };
      let resetFontStyle = {};
      if (resetFont !== false) {
        resetFontStyle = {
          fontFamily: token.fontFamily,
          fontSize: token.fontSize
        };
      }
      return {
        [rootPrefixSelector]: Object.assign(Object.assign(Object.assign({}, resetFontStyle), resetStyle), {
          [prefixSelector]: resetStyle
        })
      };
    };
    const genFocusOutline = (token, offset) => ({
      outline: `${unit$1(token.lineWidthFocus)} solid ${token.colorPrimaryBorder}`,
      outlineOffset: offset !== null && offset !== void 0 ? offset : 1,
      transition: 'outline-offset 0s, outline 0s'
    });
    const genFocusStyle = (token, offset) => ({
      '&:focus-visible': Object.assign({}, genFocusOutline(token, offset))
    });
    const genIconStyle = iconPrefixCls => ({
      [`.${iconPrefixCls}`]: Object.assign(Object.assign({}, resetIcon()), {
        [`.${iconPrefixCls} .${iconPrefixCls}-icon`]: {
          display: 'block'
        }
      })
    });

    const {
      genStyleHooks,
      genComponentStyleHook,
      genSubStyleComponent
    } = genStyleUtils({
      usePrefix: () => {
        const {
          getPrefixCls,
          iconPrefixCls
        } = reactExports.useContext(ConfigContext);
        const rootPrefixCls = getPrefixCls();
        return {
          rootPrefixCls,
          iconPrefixCls
        };
      },
      useToken: () => {
        const [theme, realToken, hashId, token, cssVar] = useToken();
        return {
          theme,
          realToken,
          hashId,
          token,
          cssVar
        };
      },
      useCSP: () => {
        const {
          csp
        } = reactExports.useContext(ConfigContext);
        return csp !== null && csp !== void 0 ? csp : {};
      },
      getResetStyles: (token, config) => {
        var _a;
        return [{
          '&': genLinkStyle(token)
        }, genIconStyle((_a = config === null || config === void 0 ? void 0 : config.prefix.iconPrefixCls) !== null && _a !== void 0 ? _a : defaultIconPrefixCls)];
      },
      getCommonStyle: genCommonStyle,
      getCompUnitless: () => unitless
    });

    const useResetIconStyle = (iconPrefixCls, csp) => {
      const [theme, token] = useToken();
      // Generate style for icons
      return useStyleRegister({
        token,
        hashId: '',
        path: ['ant-design-icons', iconPrefixCls],
        nonce: () => csp === null || csp === void 0 ? void 0 : csp.nonce,
        layer: {
          name: 'antd'
        }
      }, () => [genIconStyle(iconPrefixCls)]);
    };

    const fullClone$1 = Object.assign({}, React$1);
    const {
      useId
    } = fullClone$1;
    const useEmptyId = () => '';
    const useThemeKey = typeof useId === 'undefined' ? useEmptyId : useId;

    function useTheme(theme, parentTheme, config) {
      var _a;
      const themeConfig = theme || {};
      const parentThemeConfig = themeConfig.inherit === false || !parentTheme ? Object.assign(Object.assign({}, defaultConfig), {
        hashed: (_a = parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.hashed) !== null && _a !== void 0 ? _a : defaultConfig.hashed,
        cssVar: parentTheme === null || parentTheme === void 0 ? void 0 : parentTheme.cssVar
      }) : parentTheme;
      const themeKey = useThemeKey();
      return useMemo(() => {
        var _a, _b;
        if (!theme) {
          return parentTheme;
        }
        // Override
        const mergedComponents = Object.assign({}, parentThemeConfig.components);
        Object.keys(theme.components || {}).forEach(componentName => {
          mergedComponents[componentName] = Object.assign(Object.assign({}, mergedComponents[componentName]), theme.components[componentName]);
        });
        const cssVarKey = `css-var-${themeKey.replace(/:/g, '')}`;
        const mergedCssVar = ((_a = themeConfig.cssVar) !== null && _a !== void 0 ? _a : parentThemeConfig.cssVar) && Object.assign(Object.assign(Object.assign({
          prefix: config === null || config === void 0 ? void 0 : config.prefixCls
        }, typeof parentThemeConfig.cssVar === 'object' ? parentThemeConfig.cssVar : {}), typeof themeConfig.cssVar === 'object' ? themeConfig.cssVar : {}), {
          key: typeof themeConfig.cssVar === 'object' && ((_b = themeConfig.cssVar) === null || _b === void 0 ? void 0 : _b.key) || cssVarKey
        });
        // Base token
        return Object.assign(Object.assign(Object.assign({}, parentThemeConfig), themeConfig), {
          token: Object.assign(Object.assign({}, parentThemeConfig.token), themeConfig.token),
          components: mergedComponents,
          cssVar: mergedCssVar
        });
      }, [themeConfig, parentThemeConfig], (prev, next) => prev.some((prevTheme, index) => {
        const nextTheme = next[index];
        return !isEqual(prevTheme, nextTheme, true);
      }));
    }

    var _excluded$d = ["children"];
    var Context$1 = /*#__PURE__*/reactExports.createContext({});
    function MotionProvider(_ref) {
      var children = _ref.children,
        props = _objectWithoutProperties(_ref, _excluded$d);
      return /*#__PURE__*/reactExports.createElement(Context$1.Provider, {
        value: props
      }, children);
    }

    var DomWrapper = /*#__PURE__*/function (_React$Component) {
      _inherits(DomWrapper, _React$Component);
      var _super = _createSuper(DomWrapper);
      function DomWrapper() {
        _classCallCheck(this, DomWrapper);
        return _super.apply(this, arguments);
      }
      _createClass(DomWrapper, [{
        key: "render",
        value: function render() {
          return this.props.children;
        }
      }]);
      return DomWrapper;
    }(reactExports.Component);

    /**
     * Same as React.useState but will always get latest state.
     * This is useful when React merge multiple state updates into one.
     * e.g. onTransitionEnd trigger multiple event at once will be merged state update in React.
     */
    function useSyncState(defaultValue) {
      var _React$useReducer = reactExports.useReducer(function (x) {
          return x + 1;
        }, 0),
        _React$useReducer2 = _slicedToArray(_React$useReducer, 2),
        forceUpdate = _React$useReducer2[1];
      var currentValueRef = reactExports.useRef(defaultValue);
      var getValue = useEvent(function () {
        return currentValueRef.current;
      });
      var setValue = useEvent(function (updater) {
        currentValueRef.current = typeof updater === 'function' ? updater(currentValueRef.current) : updater;
        forceUpdate();
      });
      return [getValue, setValue];
    }

    var STATUS_NONE = 'none';
    var STATUS_APPEAR = 'appear';
    var STATUS_ENTER = 'enter';
    var STATUS_LEAVE = 'leave';
    var STEP_NONE = 'none';
    var STEP_PREPARE = 'prepare';
    var STEP_START = 'start';
    var STEP_ACTIVE = 'active';
    var STEP_ACTIVATED = 'end';
    /**
     * Used for disabled motion case.
     * Prepare stage will still work but start & active will be skipped.
     */
    var STEP_PREPARED = 'prepared';

    // ================= Transition =================
    // Event wrapper. Copy from react source code
    function makePrefixMap(styleProp, eventName) {
      var prefixes = {};
      prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
      prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
      prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
      prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
      prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
      return prefixes;
    }
    function getVendorPrefixes(domSupport, win) {
      var prefixes = {
        animationend: makePrefixMap('Animation', 'AnimationEnd'),
        transitionend: makePrefixMap('Transition', 'TransitionEnd')
      };
      if (domSupport) {
        if (!('AnimationEvent' in win)) {
          delete prefixes.animationend.animation;
        }
        if (!('TransitionEvent' in win)) {
          delete prefixes.transitionend.transition;
        }
      }
      return prefixes;
    }
    var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== 'undefined' ? window : {});
    var style = {};
    if (canUseDom()) {
      var _document$createEleme = document.createElement('div');
      style = _document$createEleme.style;
    }
    var prefixedEventNames = {};
    function getVendorPrefixedEventName(eventName) {
      if (prefixedEventNames[eventName]) {
        return prefixedEventNames[eventName];
      }
      var prefixMap = vendorPrefixes[eventName];
      if (prefixMap) {
        var stylePropList = Object.keys(prefixMap);
        var len = stylePropList.length;
        for (var i = 0; i < len; i += 1) {
          var styleProp = stylePropList[i];
          if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
            prefixedEventNames[eventName] = prefixMap[styleProp];
            return prefixedEventNames[eventName];
          }
        }
      }
      return '';
    }
    var internalAnimationEndName = getVendorPrefixedEventName('animationend');
    var internalTransitionEndName = getVendorPrefixedEventName('transitionend');
    var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
    var animationEndName = internalAnimationEndName || 'animationend';
    var transitionEndName = internalTransitionEndName || 'transitionend';
    function getTransitionName(transitionName, transitionType) {
      if (!transitionName) return null;
      if (_typeof(transitionName) === 'object') {
        var type = transitionType.replace(/-\w/g, function (match) {
          return match[1].toUpperCase();
        });
        return transitionName[type];
      }
      return "".concat(transitionName, "-").concat(transitionType);
    }

    var useDomMotionEvents = (function (onInternalMotionEnd) {
      var cacheElementRef = reactExports.useRef();

      // Remove events
      function removeMotionEvents(element) {
        if (element) {
          element.removeEventListener(transitionEndName, onInternalMotionEnd);
          element.removeEventListener(animationEndName, onInternalMotionEnd);
        }
      }

      // Patch events
      function patchMotionEvents(element) {
        if (cacheElementRef.current && cacheElementRef.current !== element) {
          removeMotionEvents(cacheElementRef.current);
        }
        if (element && element !== cacheElementRef.current) {
          element.addEventListener(transitionEndName, onInternalMotionEnd);
          element.addEventListener(animationEndName, onInternalMotionEnd);

          // Save as cache in case dom removed trigger by `motionDeadline`
          cacheElementRef.current = element;
        }
      }

      // Clean up when removed
      reactExports.useEffect(function () {
        return function () {
          removeMotionEvents(cacheElementRef.current);
        };
      }, []);
      return [patchMotionEvents, removeMotionEvents];
    });

    // It's safe to use `useLayoutEffect` but the warning is annoying
    var useIsomorphicLayoutEffect = canUseDom() ? reactExports.useLayoutEffect : reactExports.useEffect;

    var useNextFrame = (function () {
      var nextFrameRef = reactExports.useRef(null);
      function cancelNextFrame() {
        wrapperRaf.cancel(nextFrameRef.current);
      }
      function nextFrame(callback) {
        var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
        cancelNextFrame();
        var nextFrameId = wrapperRaf(function () {
          if (delay <= 1) {
            callback({
              isCanceled: function isCanceled() {
                return nextFrameId !== nextFrameRef.current;
              }
            });
          } else {
            nextFrame(callback, delay - 1);
          }
        });
        nextFrameRef.current = nextFrameId;
      }
      reactExports.useEffect(function () {
        return function () {
          cancelNextFrame();
        };
      }, []);
      return [nextFrame, cancelNextFrame];
    });

    var FULL_STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
    var SIMPLE_STEP_QUEUE = [STEP_PREPARE, STEP_PREPARED];

    /** Skip current step */
    var SkipStep = false;
    /** Current step should be update in */
    var DoStep = true;
    function isActive(step) {
      return step === STEP_ACTIVE || step === STEP_ACTIVATED;
    }
    var useStepQueue = (function (status, prepareOnly, callback) {
      var _useState = useSafeState(STEP_NONE),
        _useState2 = _slicedToArray(_useState, 2),
        step = _useState2[0],
        setStep = _useState2[1];
      var _useNextFrame = useNextFrame(),
        _useNextFrame2 = _slicedToArray(_useNextFrame, 2),
        nextFrame = _useNextFrame2[0],
        cancelNextFrame = _useNextFrame2[1];
      function startQueue() {
        setStep(STEP_PREPARE, true);
      }
      var STEP_QUEUE = prepareOnly ? SIMPLE_STEP_QUEUE : FULL_STEP_QUEUE;
      useIsomorphicLayoutEffect(function () {
        if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
          var index = STEP_QUEUE.indexOf(step);
          var nextStep = STEP_QUEUE[index + 1];
          var result = callback(step);
          if (result === SkipStep) {
            // Skip when no needed
            setStep(nextStep, true);
          } else if (nextStep) {
            // Do as frame for step update
            nextFrame(function (info) {
              function doNext() {
                // Skip since current queue is ood
                if (info.isCanceled()) return;
                setStep(nextStep, true);
              }
              if (result === true) {
                doNext();
              } else {
                // Only promise should be async
                Promise.resolve(result).then(doNext);
              }
            });
          }
        }
      }, [status, step]);
      reactExports.useEffect(function () {
        return function () {
          cancelNextFrame();
        };
      }, []);
      return [startQueue, step];
    });

    function useStatus(supportMotion, visible, getElement, _ref) {
      var _ref$motionEnter = _ref.motionEnter,
        motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,
        _ref$motionAppear = _ref.motionAppear,
        motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,
        _ref$motionLeave = _ref.motionLeave,
        motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,
        motionDeadline = _ref.motionDeadline,
        motionLeaveImmediately = _ref.motionLeaveImmediately,
        onAppearPrepare = _ref.onAppearPrepare,
        onEnterPrepare = _ref.onEnterPrepare,
        onLeavePrepare = _ref.onLeavePrepare,
        onAppearStart = _ref.onAppearStart,
        onEnterStart = _ref.onEnterStart,
        onLeaveStart = _ref.onLeaveStart,
        onAppearActive = _ref.onAppearActive,
        onEnterActive = _ref.onEnterActive,
        onLeaveActive = _ref.onLeaveActive,
        onAppearEnd = _ref.onAppearEnd,
        onEnterEnd = _ref.onEnterEnd,
        onLeaveEnd = _ref.onLeaveEnd,
        onVisibleChanged = _ref.onVisibleChanged;
      // Used for outer render usage to avoid `visible: false & status: none` to render nothing
      var _useState = useSafeState(),
        _useState2 = _slicedToArray(_useState, 2),
        asyncVisible = _useState2[0],
        setAsyncVisible = _useState2[1];
      var _useSyncState = useSyncState(STATUS_NONE),
        _useSyncState2 = _slicedToArray(_useSyncState, 2),
        getStatus = _useSyncState2[0],
        setStatus = _useSyncState2[1];
      var _useState3 = useSafeState(null),
        _useState4 = _slicedToArray(_useState3, 2),
        style = _useState4[0],
        setStyle = _useState4[1];
      var currentStatus = getStatus();
      var mountedRef = reactExports.useRef(false);
      var deadlineRef = reactExports.useRef(null);

      // =========================== Dom Node ===========================
      function getDomElement() {
        return getElement();
      }

      // ========================== Motion End ==========================
      var activeRef = reactExports.useRef(false);

      /**
       * Clean up status & style
       */
      function updateMotionEndStatus() {
        setStatus(STATUS_NONE);
        setStyle(null, true);
      }
      var onInternalMotionEnd = useEvent(function (event) {
        var status = getStatus();
        // Do nothing since not in any transition status.
        // This may happen when `motionDeadline` trigger.
        if (status === STATUS_NONE) {
          return;
        }
        var element = getDomElement();
        if (event && !event.deadline && event.target !== element) {
          // event exists
          // not initiated by deadline
          // transitionEnd not fired by inner elements
          return;
        }
        var currentActive = activeRef.current;
        var canEnd;
        if (status === STATUS_APPEAR && currentActive) {
          canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
        } else if (status === STATUS_ENTER && currentActive) {
          canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
        } else if (status === STATUS_LEAVE && currentActive) {
          canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
        }

        // Only update status when `canEnd` and not destroyed
        if (currentActive && canEnd !== false) {
          updateMotionEndStatus();
        }
      });
      var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),
        _useDomMotionEvents2 = _slicedToArray(_useDomMotionEvents, 1),
        patchMotionEvents = _useDomMotionEvents2[0];

      // ============================= Step =============================
      var getEventHandlers = function getEventHandlers(targetStatus) {
        switch (targetStatus) {
          case STATUS_APPEAR:
            return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onAppearPrepare), STEP_START, onAppearStart), STEP_ACTIVE, onAppearActive);
          case STATUS_ENTER:
            return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onEnterPrepare), STEP_START, onEnterStart), STEP_ACTIVE, onEnterActive);
          case STATUS_LEAVE:
            return _defineProperty(_defineProperty(_defineProperty({}, STEP_PREPARE, onLeavePrepare), STEP_START, onLeaveStart), STEP_ACTIVE, onLeaveActive);
          default:
            return {};
        }
      };
      var eventHandlers = reactExports.useMemo(function () {
        return getEventHandlers(currentStatus);
      }, [currentStatus]);
      var _useStepQueue = useStepQueue(currentStatus, !supportMotion, function (newStep) {
          // Only prepare step can be skip
          if (newStep === STEP_PREPARE) {
            var onPrepare = eventHandlers[STEP_PREPARE];
            if (!onPrepare) {
              return SkipStep;
            }
            return onPrepare(getDomElement());
          }

          // Rest step is sync update
          if (step in eventHandlers) {
            var _eventHandlers$step;
            setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
          }
          if (step === STEP_ACTIVE && currentStatus !== STATUS_NONE) {
            // Patch events when motion needed
            patchMotionEvents(getDomElement());
            if (motionDeadline > 0) {
              clearTimeout(deadlineRef.current);
              deadlineRef.current = setTimeout(function () {
                onInternalMotionEnd({
                  deadline: true
                });
              }, motionDeadline);
            }
          }
          if (step === STEP_PREPARED) {
            updateMotionEndStatus();
          }
          return DoStep;
        }),
        _useStepQueue2 = _slicedToArray(_useStepQueue, 2),
        startStep = _useStepQueue2[0],
        step = _useStepQueue2[1];
      var active = isActive(step);
      activeRef.current = active;

      // ============================ Status ============================
      var visibleRef = reactExports.useRef(null);

      // Update with new status
      useIsomorphicLayoutEffect(function () {
        // When use Suspense, the `visible` will repeat trigger,
        // But not real change of the `visible`, we need to skip it.
        // https://github.com/ant-design/ant-design/issues/44379
        if (mountedRef.current && visibleRef.current === visible) {
          return;
        }
        setAsyncVisible(visible);
        var isMounted = mountedRef.current;
        mountedRef.current = true;

        // if (!supportMotion) {
        //   return;
        // }

        var nextStatus;

        // Appear
        if (!isMounted && visible && motionAppear) {
          nextStatus = STATUS_APPEAR;
        }

        // Enter
        if (isMounted && visible && motionEnter) {
          nextStatus = STATUS_ENTER;
        }

        // Leave
        if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
          nextStatus = STATUS_LEAVE;
        }
        var nextEventHandlers = getEventHandlers(nextStatus);

        // Update to next status
        if (nextStatus && (supportMotion || nextEventHandlers[STEP_PREPARE])) {
          setStatus(nextStatus);
          startStep();
        } else {
          // Set back in case no motion but prev status has prepare step
          setStatus(STATUS_NONE);
        }
        visibleRef.current = visible;
      }, [visible]);

      // ============================ Effect ============================
      // Reset when motion changed
      reactExports.useEffect(function () {
        if (
        // Cancel appear
        currentStatus === STATUS_APPEAR && !motionAppear ||
        // Cancel enter
        currentStatus === STATUS_ENTER && !motionEnter ||
        // Cancel leave
        currentStatus === STATUS_LEAVE && !motionLeave) {
          setStatus(STATUS_NONE);
        }
      }, [motionAppear, motionEnter, motionLeave]);
      reactExports.useEffect(function () {
        return function () {
          mountedRef.current = false;
          clearTimeout(deadlineRef.current);
        };
      }, []);

      // Trigger `onVisibleChanged`
      var firstMountChangeRef = reactExports.useRef(false);
      reactExports.useEffect(function () {
        // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
        if (asyncVisible) {
          firstMountChangeRef.current = true;
        }
        if (asyncVisible !== undefined && currentStatus === STATUS_NONE) {
          // Skip first render is invisible since it's nothing changed
          if (firstMountChangeRef.current || asyncVisible) {
            onVisibleChanged === null || onVisibleChanged === void 0 || onVisibleChanged(asyncVisible);
          }
          firstMountChangeRef.current = true;
        }
      }, [asyncVisible, currentStatus]);

      // ============================ Styles ============================
      var mergedStyle = style;
      if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
        mergedStyle = _objectSpread2({
          transition: 'none'
        }, mergedStyle);
      }
      return [currentStatus, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
    }

    /**
     * `transitionSupport` is used for none transition test case.
     * Default we use browser transition event support check.
     */
    function genCSSMotion(config) {
      var transitionSupport = config;
      if (_typeof(config) === 'object') {
        transitionSupport = config.transitionSupport;
      }
      function isSupportTransition(props, contextMotion) {
        return !!(props.motionName && transitionSupport && contextMotion !== false);
      }
      var CSSMotion = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
        var _props$visible = props.visible,
          visible = _props$visible === void 0 ? true : _props$visible,
          _props$removeOnLeave = props.removeOnLeave,
          removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave,
          forceRender = props.forceRender,
          children = props.children,
          motionName = props.motionName,
          leavedClassName = props.leavedClassName,
          eventProps = props.eventProps;
        var _React$useContext = reactExports.useContext(Context$1),
          contextMotion = _React$useContext.motion;
        var supportMotion = isSupportTransition(props, contextMotion);

        // Ref to the react node, it may be a HTMLElement
        var nodeRef = reactExports.useRef();
        // Ref to the dom wrapper in case ref can not pass to HTMLElement
        var wrapperNodeRef = reactExports.useRef();
        function getDomElement() {
          try {
            // Here we're avoiding call for findDOMNode since it's deprecated
            // in strict mode. We're calling it only when node ref is not
            // an instance of DOM HTMLElement. Otherwise use
            // findDOMNode as a final resort
            return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
          } catch (e) {
            // Only happen when `motionDeadline` trigger but element removed.
            return null;
          }
        }
        var _useStatus = useStatus(supportMotion, visible, getDomElement, props),
          _useStatus2 = _slicedToArray(_useStatus, 4),
          status = _useStatus2[0],
          statusStep = _useStatus2[1],
          statusStyle = _useStatus2[2],
          mergedVisible = _useStatus2[3];

        // Record whether content has rendered
        // Will return null for un-rendered even when `removeOnLeave={false}`
        var renderedRef = reactExports.useRef(mergedVisible);
        if (mergedVisible) {
          renderedRef.current = true;
        }

        // ====================== Refs ======================
        var setNodeRef = reactExports.useCallback(function (node) {
          nodeRef.current = node;
          fillRef(ref, node);
        }, [ref]);

        // ===================== Render =====================
        var motionChildren;
        var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
          visible: visible
        });
        if (!children) {
          // No children
          motionChildren = null;
        } else if (status === STATUS_NONE) {
          // Stable children
          if (mergedVisible) {
            motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
          } else if (!removeOnLeave && renderedRef.current && leavedClassName) {
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              className: leavedClassName
            }), setNodeRef);
          } else if (forceRender || !removeOnLeave && !leavedClassName) {
            motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
              style: {
                display: 'none'
              }
            }), setNodeRef);
          } else {
            motionChildren = null;
          }
        } else {
          // In motion
          var statusSuffix;
          if (statusStep === STEP_PREPARE) {
            statusSuffix = 'prepare';
          } else if (isActive(statusStep)) {
            statusSuffix = 'active';
          } else if (statusStep === STEP_START) {
            statusSuffix = 'start';
          }
          var motionCls = getTransitionName(motionName, "".concat(status, "-").concat(statusSuffix));
          motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
            className: classNames(getTransitionName(motionName, status), _defineProperty(_defineProperty({}, motionCls, motionCls && statusSuffix), motionName, typeof motionName === 'string')),
            style: statusStyle
          }), setNodeRef);
        }

        // Auto inject ref if child node not have `ref` props
        if ( /*#__PURE__*/reactExports.isValidElement(motionChildren) && supportRef(motionChildren)) {
          var originNodeRef = getNodeRef(motionChildren);
          if (!originNodeRef) {
            motionChildren = /*#__PURE__*/reactExports.cloneElement(motionChildren, {
              ref: setNodeRef
            });
          }
        }
        return /*#__PURE__*/reactExports.createElement(DomWrapper, {
          ref: wrapperNodeRef
        }, motionChildren);
      });
      CSSMotion.displayName = 'CSSMotion';
      return CSSMotion;
    }
    var CSSMotion = genCSSMotion(supportTransition);

    var STATUS_ADD = 'add';
    var STATUS_KEEP = 'keep';
    var STATUS_REMOVE = 'remove';
    var STATUS_REMOVED = 'removed';
    function wrapKeyToObject(key) {
      var keyObj;
      if (key && _typeof(key) === 'object' && 'key' in key) {
        keyObj = key;
      } else {
        keyObj = {
          key: key
        };
      }
      return _objectSpread2(_objectSpread2({}, keyObj), {}, {
        key: String(keyObj.key)
      });
    }
    function parseKeys() {
      var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      return keys.map(wrapKeyToObject);
    }
    function diffKeys() {
      var prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
      var currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var list = [];
      var currentIndex = 0;
      var currentLen = currentKeys.length;
      var prevKeyObjects = parseKeys(prevKeys);
      var currentKeyObjects = parseKeys(currentKeys);

      // Check prev keys to insert or keep
      prevKeyObjects.forEach(function (keyObj) {
        var hit = false;
        for (var i = currentIndex; i < currentLen; i += 1) {
          var currentKeyObj = currentKeyObjects[i];
          if (currentKeyObj.key === keyObj.key) {
            // New added keys should add before current key
            if (currentIndex < i) {
              list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function (obj) {
                return _objectSpread2(_objectSpread2({}, obj), {}, {
                  status: STATUS_ADD
                });
              }));
              currentIndex = i;
            }
            list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
              status: STATUS_KEEP
            }));
            currentIndex += 1;
            hit = true;
            break;
          }
        }

        // If not hit, it means key is removed
        if (!hit) {
          list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
            status: STATUS_REMOVE
          }));
        }
      });

      // Add rest to the list
      if (currentIndex < currentLen) {
        list = list.concat(currentKeyObjects.slice(currentIndex).map(function (obj) {
          return _objectSpread2(_objectSpread2({}, obj), {}, {
            status: STATUS_ADD
          });
        }));
      }

      /**
       * Merge same key when it remove and add again:
       *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
       */
      var keys = {};
      list.forEach(function (_ref) {
        var key = _ref.key;
        keys[key] = (keys[key] || 0) + 1;
      });
      var duplicatedKeys = Object.keys(keys).filter(function (key) {
        return keys[key] > 1;
      });
      duplicatedKeys.forEach(function (matchKey) {
        // Remove `STATUS_REMOVE` node.
        list = list.filter(function (_ref2) {
          var key = _ref2.key,
            status = _ref2.status;
          return key !== matchKey || status !== STATUS_REMOVE;
        });

        // Update `STATUS_ADD` to `STATUS_KEEP`
        list.forEach(function (node) {
          if (node.key === matchKey) {
            // eslint-disable-next-line no-param-reassign
            node.status = STATUS_KEEP;
          }
        });
      });
      return list;
    }

    var _excluded$c = ["component", "children", "onVisibleChanged", "onAllRemoved"],
      _excluded2$1 = ["status"];
    var MOTION_PROP_NAMES = ['eventProps', 'visible', 'children', 'motionName', 'motionAppear', 'motionEnter', 'motionLeave', 'motionLeaveImmediately', 'motionDeadline', 'removeOnLeave', 'leavedClassName', 'onAppearPrepare', 'onAppearStart', 'onAppearActive', 'onAppearEnd', 'onEnterStart', 'onEnterActive', 'onEnterEnd', 'onLeaveStart', 'onLeaveActive', 'onLeaveEnd'];
    /**
     * Generate a CSSMotionList component with config
     * @param transitionSupport No need since CSSMotionList no longer depends on transition support
     * @param CSSMotion CSSMotion component
     */
    function genCSSMotionList(transitionSupport) {
      var CSSMotion$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : CSSMotion;
      var CSSMotionList = /*#__PURE__*/function (_React$Component) {
        _inherits(CSSMotionList, _React$Component);
        var _super = _createSuper(CSSMotionList);
        function CSSMotionList() {
          var _this;
          _classCallCheck(this, CSSMotionList);
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          _this = _super.call.apply(_super, [this].concat(args));
          _defineProperty(_assertThisInitialized(_this), "state", {
            keyEntities: []
          });
          // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.
          _defineProperty(_assertThisInitialized(_this), "removeKey", function (removeKey) {
            _this.setState(function (prevState) {
              var nextKeyEntities = prevState.keyEntities.map(function (entity) {
                if (entity.key !== removeKey) return entity;
                return _objectSpread2(_objectSpread2({}, entity), {}, {
                  status: STATUS_REMOVED
                });
              });
              return {
                keyEntities: nextKeyEntities
              };
            }, function () {
              var keyEntities = _this.state.keyEntities;
              var restKeysCount = keyEntities.filter(function (_ref) {
                var status = _ref.status;
                return status !== STATUS_REMOVED;
              }).length;
              if (restKeysCount === 0 && _this.props.onAllRemoved) {
                _this.props.onAllRemoved();
              }
            });
          });
          return _this;
        }
        _createClass(CSSMotionList, [{
          key: "render",
          value: function render() {
            var _this2 = this;
            var keyEntities = this.state.keyEntities;
            var _this$props = this.props,
              component = _this$props.component,
              children = _this$props.children,
              _onVisibleChanged = _this$props.onVisibleChanged;
              _this$props.onAllRemoved;
              var restProps = _objectWithoutProperties(_this$props, _excluded$c);
            var Component = component || reactExports.Fragment;
            var motionProps = {};
            MOTION_PROP_NAMES.forEach(function (prop) {
              motionProps[prop] = restProps[prop];
              delete restProps[prop];
            });
            delete restProps.keys;
            return /*#__PURE__*/reactExports.createElement(Component, restProps, keyEntities.map(function (_ref2, index) {
              var status = _ref2.status,
                eventProps = _objectWithoutProperties(_ref2, _excluded2$1);
              var visible = status === STATUS_ADD || status === STATUS_KEEP;
              return /*#__PURE__*/reactExports.createElement(CSSMotion$1, _extends({}, motionProps, {
                key: eventProps.key,
                visible: visible,
                eventProps: eventProps,
                onVisibleChanged: function onVisibleChanged(changedVisible) {
                  _onVisibleChanged === null || _onVisibleChanged === void 0 || _onVisibleChanged(changedVisible, {
                    key: eventProps.key
                  });
                  if (!changedVisible) {
                    _this2.removeKey(eventProps.key);
                  }
                }
              }), function (props, ref) {
                return children(_objectSpread2(_objectSpread2({}, props), {}, {
                  index: index
                }), ref);
              });
            }));
          }
        }], [{
          key: "getDerivedStateFromProps",
          value: function getDerivedStateFromProps(_ref3, _ref4) {
            var keys = _ref3.keys;
            var keyEntities = _ref4.keyEntities;
            var parsedKeyObjects = parseKeys(keys);
            var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
            return {
              keyEntities: mixedKeyEntities.filter(function (entity) {
                var prevEntity = keyEntities.find(function (_ref5) {
                  var key = _ref5.key;
                  return entity.key === key;
                });

                // Remove if already mark as removed
                if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
                  return false;
                }
                return true;
              })
            };
          }
        }]);
        return CSSMotionList;
      }(reactExports.Component);
      _defineProperty(CSSMotionList, "defaultProps", {
        component: 'div'
      });
      return CSSMotionList;
    }
    var CSSMotionList = genCSSMotionList(supportTransition);

    function MotionWrapper(props) {
      const {
        children
      } = props;
      const [, token] = useToken();
      const {
        motion
      } = token;
      const needWrapMotionProviderRef = reactExports.useRef(false);
      needWrapMotionProviderRef.current = needWrapMotionProviderRef.current || motion === false;
      if (needWrapMotionProviderRef.current) {
        return /*#__PURE__*/reactExports.createElement(MotionProvider, {
          motion: motion
        }, children);
      }
      return children;
    }

    var PropWarning = () => null;

    var __rest$b = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    // These props is used by `useContext` directly in sub component
    const PASSED_PROPS = ['getTargetContainer', 'getPopupContainer', 'renderEmpty', 'input', 'pagination', 'form', 'select', 'button'];
    let globalPrefixCls;
    let globalIconPrefixCls;
    let globalTheme;
    let globalHolderRender;
    function getGlobalPrefixCls() {
      return globalPrefixCls || defaultPrefixCls;
    }
    function getGlobalIconPrefixCls() {
      return globalIconPrefixCls || defaultIconPrefixCls;
    }
    function isLegacyTheme(theme) {
      return Object.keys(theme).some(key => key.endsWith('Color'));
    }
    const setGlobalConfig = props => {
      const {
        prefixCls,
        iconPrefixCls,
        theme,
        holderRender
      } = props;
      if (prefixCls !== undefined) {
        globalPrefixCls = prefixCls;
      }
      if (iconPrefixCls !== undefined) {
        globalIconPrefixCls = iconPrefixCls;
      }
      if ('holderRender' in props) {
        globalHolderRender = holderRender;
      }
      if (theme) {
        if (isLegacyTheme(theme)) {
          registerTheme(getGlobalPrefixCls(), theme);
        } else {
          globalTheme = theme;
        }
      }
    };
    const globalConfig = () => ({
      getPrefixCls: (suffixCls, customizePrefixCls) => {
        if (customizePrefixCls) {
          return customizePrefixCls;
        }
        return suffixCls ? `${getGlobalPrefixCls()}-${suffixCls}` : getGlobalPrefixCls();
      },
      getIconPrefixCls: getGlobalIconPrefixCls,
      getRootPrefixCls: () => {
        // If Global prefixCls provided, use this
        if (globalPrefixCls) {
          return globalPrefixCls;
        }
        // Fallback to default prefixCls
        return getGlobalPrefixCls();
      },
      getTheme: () => globalTheme,
      holderRender: globalHolderRender
    });
    const ProviderChildren = props => {
      const {
        children,
        csp: customCsp,
        autoInsertSpaceInButton,
        alert,
        anchor,
        form,
        locale,
        componentSize,
        direction,
        space,
        splitter,
        virtual,
        dropdownMatchSelectWidth,
        popupMatchSelectWidth,
        popupOverflow,
        legacyLocale,
        parentContext,
        iconPrefixCls: customIconPrefixCls,
        theme,
        componentDisabled,
        segmented,
        statistic,
        spin,
        calendar,
        carousel,
        cascader,
        collapse,
        typography,
        checkbox,
        descriptions,
        divider,
        drawer,
        skeleton,
        steps,
        image,
        layout,
        list,
        mentions,
        modal,
        progress,
        result,
        slider,
        breadcrumb,
        menu,
        pagination,
        input,
        textArea,
        empty,
        badge,
        radio,
        rate,
        switch: SWITCH,
        transfer,
        avatar,
        message,
        tag,
        table,
        card,
        tabs,
        timeline,
        timePicker,
        upload,
        notification,
        tree,
        colorPicker,
        datePicker,
        rangePicker,
        flex,
        wave,
        dropdown,
        warning: warningConfig,
        tour,
        tooltip,
        popover,
        popconfirm,
        floatButtonGroup,
        variant,
        inputNumber,
        treeSelect
      } = props;
      // =================================== Context ===================================
      const getPrefixCls = reactExports.useCallback((suffixCls, customizePrefixCls) => {
        const {
          prefixCls
        } = props;
        if (customizePrefixCls) {
          return customizePrefixCls;
        }
        const mergedPrefixCls = prefixCls || parentContext.getPrefixCls('');
        return suffixCls ? `${mergedPrefixCls}-${suffixCls}` : mergedPrefixCls;
      }, [parentContext.getPrefixCls, props.prefixCls]);
      const iconPrefixCls = customIconPrefixCls || parentContext.iconPrefixCls || defaultIconPrefixCls;
      const csp = customCsp || parentContext.csp;
      useResetIconStyle(iconPrefixCls, csp);
      const mergedTheme = useTheme(theme, parentContext.theme, {
        prefixCls: getPrefixCls('')
      });
      const baseConfig = {
        csp,
        autoInsertSpaceInButton,
        alert,
        anchor,
        locale: locale || legacyLocale,
        direction,
        space,
        splitter,
        virtual,
        popupMatchSelectWidth: popupMatchSelectWidth !== null && popupMatchSelectWidth !== void 0 ? popupMatchSelectWidth : dropdownMatchSelectWidth,
        popupOverflow,
        getPrefixCls,
        iconPrefixCls,
        theme: mergedTheme,
        segmented,
        statistic,
        spin,
        calendar,
        carousel,
        cascader,
        collapse,
        typography,
        checkbox,
        descriptions,
        divider,
        drawer,
        skeleton,
        steps,
        image,
        input,
        textArea,
        layout,
        list,
        mentions,
        modal,
        progress,
        result,
        slider,
        breadcrumb,
        menu,
        pagination,
        empty,
        badge,
        radio,
        rate,
        switch: SWITCH,
        transfer,
        avatar,
        message,
        tag,
        table,
        card,
        tabs,
        timeline,
        timePicker,
        upload,
        notification,
        tree,
        colorPicker,
        datePicker,
        rangePicker,
        flex,
        wave,
        dropdown,
        warning: warningConfig,
        tour,
        tooltip,
        popover,
        popconfirm,
        floatButtonGroup,
        variant,
        inputNumber,
        treeSelect
      };
      const config = Object.assign({}, parentContext);
      Object.keys(baseConfig).forEach(key => {
        if (baseConfig[key] !== undefined) {
          config[key] = baseConfig[key];
        }
      });
      // Pass the props used by `useContext` directly with child component.
      // These props should merged into `config`.
      PASSED_PROPS.forEach(propName => {
        const propValue = props[propName];
        if (propValue) {
          config[propName] = propValue;
        }
      });
      if (typeof autoInsertSpaceInButton !== 'undefined') {
        // merge deprecated api
        config.button = Object.assign({
          autoInsertSpace: autoInsertSpaceInButton
        }, config.button);
      }
      // https://github.com/ant-design/ant-design/issues/27617
      const memoedConfig = useMemo(() => config, config, (prevConfig, currentConfig) => {
        const prevKeys = Object.keys(prevConfig);
        const currentKeys = Object.keys(currentConfig);
        return prevKeys.length !== currentKeys.length || prevKeys.some(key => prevConfig[key] !== currentConfig[key]);
      });
      const memoIconContextValue = reactExports.useMemo(() => ({
        prefixCls: iconPrefixCls,
        csp
      }), [iconPrefixCls, csp]);
      let childNode = /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, /*#__PURE__*/reactExports.createElement(PropWarning, {
        dropdownMatchSelectWidth: dropdownMatchSelectWidth
      }), children);
      const validateMessages = reactExports.useMemo(() => {
        var _a, _b, _c, _d;
        return merge$2(((_a = localeValues.Form) === null || _a === void 0 ? void 0 : _a.defaultValidateMessages) || {}, ((_c = (_b = memoedConfig.locale) === null || _b === void 0 ? void 0 : _b.Form) === null || _c === void 0 ? void 0 : _c.defaultValidateMessages) || {}, ((_d = memoedConfig.form) === null || _d === void 0 ? void 0 : _d.validateMessages) || {}, (form === null || form === void 0 ? void 0 : form.validateMessages) || {});
      }, [memoedConfig, form === null || form === void 0 ? void 0 : form.validateMessages]);
      if (Object.keys(validateMessages).length > 0) {
        childNode = /*#__PURE__*/reactExports.createElement(ValidateMessagesContext.Provider, {
          value: validateMessages
        }, childNode);
      }
      if (locale) {
        childNode = /*#__PURE__*/reactExports.createElement(LocaleProvider, {
          locale: locale,
          _ANT_MARK__: ANT_MARK
        }, childNode);
      }
      {
        childNode = /*#__PURE__*/reactExports.createElement(IconContext.Provider, {
          value: memoIconContextValue
        }, childNode);
      }
      if (componentSize) {
        childNode = /*#__PURE__*/reactExports.createElement(SizeContextProvider, {
          size: componentSize
        }, childNode);
      }
      // =================================== Motion ===================================
      childNode = /*#__PURE__*/reactExports.createElement(MotionWrapper, null, childNode);
      // ================================ Dynamic theme ================================
      const memoTheme = reactExports.useMemo(() => {
        const _a = mergedTheme || {},
          {
            algorithm,
            token,
            components,
            cssVar
          } = _a,
          rest = __rest$b(_a, ["algorithm", "token", "components", "cssVar"]);
        const themeObj = algorithm && (!Array.isArray(algorithm) || algorithm.length > 0) ? createTheme(algorithm) : defaultTheme;
        const parsedComponents = {};
        Object.entries(components || {}).forEach(_ref => {
          let [componentName, componentToken] = _ref;
          const parsedToken = Object.assign({}, componentToken);
          if ('algorithm' in parsedToken) {
            if (parsedToken.algorithm === true) {
              parsedToken.theme = themeObj;
            } else if (Array.isArray(parsedToken.algorithm) || typeof parsedToken.algorithm === 'function') {
              parsedToken.theme = createTheme(parsedToken.algorithm);
            }
            delete parsedToken.algorithm;
          }
          parsedComponents[componentName] = parsedToken;
        });
        const mergedToken = Object.assign(Object.assign({}, seedToken), token);
        return Object.assign(Object.assign({}, rest), {
          theme: themeObj,
          token: mergedToken,
          components: parsedComponents,
          override: Object.assign({
            override: mergedToken
          }, parsedComponents),
          cssVar: cssVar
        });
      }, [mergedTheme]);
      if (theme) {
        childNode = /*#__PURE__*/reactExports.createElement(DesignTokenContext.Provider, {
          value: memoTheme
        }, childNode);
      }
      // ================================== Warning ===================================
      if (memoedConfig.warning) {
        childNode = /*#__PURE__*/reactExports.createElement(WarningContext.Provider, {
          value: memoedConfig.warning
        }, childNode);
      }
      // =================================== Render ===================================
      if (componentDisabled !== undefined) {
        childNode = /*#__PURE__*/reactExports.createElement(DisabledContextProvider, {
          disabled: componentDisabled
        }, childNode);
      }
      return /*#__PURE__*/reactExports.createElement(ConfigContext.Provider, {
        value: memoedConfig
      }, childNode);
    };
    const ConfigProvider = props => {
      const context = reactExports.useContext(ConfigContext);
      const antLocale = reactExports.useContext(LocaleContext);
      return /*#__PURE__*/reactExports.createElement(ProviderChildren, Object.assign({
        parentContext: context,
        legacyLocale: antLocale
      }, props));
    };
    ConfigProvider.ConfigContext = ConfigContext;
    ConfigProvider.SizeContext = SizeContext;
    ConfigProvider.config = setGlobalConfig;
    ConfigProvider.useConfig = useConfig;
    Object.defineProperty(ConfigProvider, 'SizeContext', {
      get: () => {
        return SizeContext;
      }
    });

    // This icon file is generated automatically.
    var CheckCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm193.5 301.7l-210.6 292a31.8 31.8 0 01-51.7 0L318.5 484.9c-3.8-5.3 0-12.7 6.5-12.7h46.9c10.2 0 19.9 4.9 25.9 13.3l71.2 98.8 157.2-218c6-8.3 15.6-13.3 25.9-13.3H699c6.5 0 10.3 7.4 6.5 12.7z" } }] }, "name": "check-circle", "theme": "filled" };

    function getRoot(ele) {
      var _ele$getRootNode;
      return ele === null || ele === void 0 || (_ele$getRootNode = ele.getRootNode) === null || _ele$getRootNode === void 0 ? void 0 : _ele$getRootNode.call(ele);
    }

    /**
     * Check if is in shadowRoot
     */
    function inShadow(ele) {
      return getRoot(ele) instanceof ShadowRoot;
    }

    /**
     * Return shadowRoot if possible
     */
    function getShadowRoot(ele) {
      return inShadow(ele) ? getRoot(ele) : null;
    }

    function camelCase(input) {
      return input.replace(/-(.)/g, function (match, g) {
        return g.toUpperCase();
      });
    }
    function warning$1(valid, message) {
      warningOnce(valid, "[@ant-design/icons] ".concat(message));
    }
    function isIconDefinition(target) {
      return _typeof(target) === 'object' && typeof target.name === 'string' && typeof target.theme === 'string' && (_typeof(target.icon) === 'object' || typeof target.icon === 'function');
    }
    function normalizeAttrs() {
      var attrs = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      return Object.keys(attrs).reduce(function (acc, key) {
        var val = attrs[key];
        switch (key) {
          case 'class':
            acc.className = val;
            delete acc.class;
            break;
          default:
            delete acc[key];
            acc[camelCase(key)] = val;
        }
        return acc;
      }, {});
    }
    function generate(node, key, rootProps) {
      if (!rootProps) {
        return /*#__PURE__*/React.createElement(node.tag, _objectSpread2({
          key: key
        }, normalizeAttrs(node.attrs)), (node.children || []).map(function (child, index) {
          return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
        }));
      }
      return /*#__PURE__*/React.createElement(node.tag, _objectSpread2(_objectSpread2({
        key: key
      }, normalizeAttrs(node.attrs)), rootProps), (node.children || []).map(function (child, index) {
        return generate(child, "".concat(key, "-").concat(node.tag, "-").concat(index));
      }));
    }
    function getSecondaryColor(primaryColor) {
      // choose the second color
      return generate$1(primaryColor)[0];
    }
    function normalizeTwoToneColors(twoToneColor) {
      if (!twoToneColor) {
        return [];
      }
      return Array.isArray(twoToneColor) ? twoToneColor : [twoToneColor];
    }
    var iconStyles = "\n.anticon {\n  display: inline-flex;\n  align-items: center;\n  color: inherit;\n  font-style: normal;\n  line-height: 0;\n  text-align: center;\n  text-transform: none;\n  vertical-align: -0.125em;\n  text-rendering: optimizeLegibility;\n  -webkit-font-smoothing: antialiased;\n  -moz-osx-font-smoothing: grayscale;\n}\n\n.anticon > * {\n  line-height: 1;\n}\n\n.anticon svg {\n  display: inline-block;\n}\n\n.anticon::before {\n  display: none;\n}\n\n.anticon .anticon-icon {\n  display: block;\n}\n\n.anticon[tabindex] {\n  cursor: pointer;\n}\n\n.anticon-spin::before,\n.anticon-spin {\n  display: inline-block;\n  -webkit-animation: loadingCircle 1s infinite linear;\n  animation: loadingCircle 1s infinite linear;\n}\n\n@-webkit-keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n\n@keyframes loadingCircle {\n  100% {\n    -webkit-transform: rotate(360deg);\n    transform: rotate(360deg);\n  }\n}\n";
    var useInsertStyles = function useInsertStyles(eleRef) {
      var _useContext = reactExports.useContext(IconContext),
        csp = _useContext.csp,
        prefixCls = _useContext.prefixCls,
        layer = _useContext.layer;
      var mergedStyleStr = iconStyles;
      if (prefixCls) {
        mergedStyleStr = mergedStyleStr.replace(/anticon/g, prefixCls);
      }
      if (layer) {
        mergedStyleStr = "@layer ".concat(layer, " {\n").concat(mergedStyleStr, "\n}");
      }
      reactExports.useEffect(function () {
        var ele = eleRef.current;
        var shadowRoot = getShadowRoot(ele);
        updateCSS(mergedStyleStr, '@ant-design-icons', {
          prepend: !layer,
          csp: csp,
          attachTo: shadowRoot
        });
      }, []);
    };

    var _excluded$b = ["icon", "className", "onClick", "style", "primaryColor", "secondaryColor"];
    var twoToneColorPalette = {
      primaryColor: '#333',
      secondaryColor: '#E6E6E6',
      calculated: false
    };
    function setTwoToneColors(_ref) {
      var primaryColor = _ref.primaryColor,
        secondaryColor = _ref.secondaryColor;
      twoToneColorPalette.primaryColor = primaryColor;
      twoToneColorPalette.secondaryColor = secondaryColor || getSecondaryColor(primaryColor);
      twoToneColorPalette.calculated = !!secondaryColor;
    }
    function getTwoToneColors() {
      return _objectSpread2({}, twoToneColorPalette);
    }
    var IconBase = function IconBase(props) {
      var icon = props.icon,
        className = props.className,
        onClick = props.onClick,
        style = props.style,
        primaryColor = props.primaryColor,
        secondaryColor = props.secondaryColor,
        restProps = _objectWithoutProperties(props, _excluded$b);
      var svgRef = reactExports.useRef();
      var colors = twoToneColorPalette;
      if (primaryColor) {
        colors = {
          primaryColor: primaryColor,
          secondaryColor: secondaryColor || getSecondaryColor(primaryColor)
        };
      }
      useInsertStyles(svgRef);
      warning$1(isIconDefinition(icon), "icon should be icon definiton, but got ".concat(icon));
      if (!isIconDefinition(icon)) {
        return null;
      }
      var target = icon;
      if (target && typeof target.icon === 'function') {
        target = _objectSpread2(_objectSpread2({}, target), {}, {
          icon: target.icon(colors.primaryColor, colors.secondaryColor)
        });
      }
      return generate(target.icon, "svg-".concat(target.name), _objectSpread2(_objectSpread2({
        className: className,
        onClick: onClick,
        style: style,
        'data-icon': target.name,
        width: '1em',
        height: '1em',
        fill: 'currentColor',
        'aria-hidden': 'true'
      }, restProps), {}, {
        ref: svgRef
      }));
    };
    IconBase.displayName = 'IconReact';
    IconBase.getTwoToneColors = getTwoToneColors;
    IconBase.setTwoToneColors = setTwoToneColors;

    function setTwoToneColor(twoToneColor) {
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor),
        _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
        primaryColor = _normalizeTwoToneColo2[0],
        secondaryColor = _normalizeTwoToneColo2[1];
      return IconBase.setTwoToneColors({
        primaryColor: primaryColor,
        secondaryColor: secondaryColor
      });
    }
    function getTwoToneColor() {
      var colors = IconBase.getTwoToneColors();
      if (!colors.calculated) {
        return colors.primaryColor;
      }
      return [colors.primaryColor, colors.secondaryColor];
    }

    var _excluded$a = ["className", "icon", "spin", "rotate", "tabIndex", "onClick", "twoToneColor"];
    // Initial setting
    // should move it to antd main repo?
    setTwoToneColor(blue.primary);

    // https://github.com/DefinitelyTyped/DefinitelyTyped/issues/34757#issuecomment-488848720

    var Icon = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
      var className = props.className,
        icon = props.icon,
        spin = props.spin,
        rotate = props.rotate,
        tabIndex = props.tabIndex,
        onClick = props.onClick,
        twoToneColor = props.twoToneColor,
        restProps = _objectWithoutProperties(props, _excluded$a);
      var _React$useContext = reactExports.useContext(IconContext),
        _React$useContext$pre = _React$useContext.prefixCls,
        prefixCls = _React$useContext$pre === void 0 ? 'anticon' : _React$useContext$pre,
        rootClassName = _React$useContext.rootClassName;
      var classString = classNames(rootClassName, prefixCls, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-").concat(icon.name), !!icon.name), "".concat(prefixCls, "-spin"), !!spin || icon.name === 'loading'), className);
      var iconTabIndex = tabIndex;
      if (iconTabIndex === undefined && onClick) {
        iconTabIndex = -1;
      }
      var svgStyle = rotate ? {
        msTransform: "rotate(".concat(rotate, "deg)"),
        transform: "rotate(".concat(rotate, "deg)")
      } : undefined;
      var _normalizeTwoToneColo = normalizeTwoToneColors(twoToneColor),
        _normalizeTwoToneColo2 = _slicedToArray(_normalizeTwoToneColo, 2),
        primaryColor = _normalizeTwoToneColo2[0],
        secondaryColor = _normalizeTwoToneColo2[1];
      return /*#__PURE__*/reactExports.createElement("span", _extends({
        role: "img",
        "aria-label": icon.name
      }, restProps, {
        ref: ref,
        tabIndex: iconTabIndex,
        onClick: onClick,
        className: classString
      }), /*#__PURE__*/reactExports.createElement(IconBase, {
        icon: icon,
        primaryColor: primaryColor,
        secondaryColor: secondaryColor,
        style: svgStyle
      }));
    });
    Icon.displayName = 'AntdIcon';
    Icon.getTwoToneColor = getTwoToneColor;
    Icon.setTwoToneColor = setTwoToneColor;

    var CheckCircleFilled = function CheckCircleFilled(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: CheckCircleFilled$1
      }));
    };

    /**![check-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0xOTMuNSAzMDEuN2wtMjEwLjYgMjkyYTMxLjggMzEuOCAwIDAxLTUxLjcgMEwzMTguNSA0ODQuOWMtMy44LTUuMyAwLTEyLjcgNi41LTEyLjdoNDYuOWMxMC4yIDAgMTkuOSA0LjkgMjUuOSAxMy4zbDcxLjIgOTguOCAxNTcuMi0yMThjNi04LjMgMTUuNi0xMy4zIDI1LjktMTMuM0g2OTljNi41IDAgMTAuMyA3LjQgNi41IDEyLjd6IiAvPjwvc3ZnPg==) */
    var RefIcon$8 = /*#__PURE__*/reactExports.forwardRef(CheckCircleFilled);

    // This icon file is generated automatically.
    var CloseCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64c247.4 0 448 200.6 448 448S759.4 960 512 960 64 759.4 64 512 264.6 64 512 64zm127.98 274.82h-.04l-.08.06L512 466.75 384.14 338.88c-.04-.05-.06-.06-.08-.06a.12.12 0 00-.07 0c-.03 0-.05.01-.09.05l-45.02 45.02a.2.2 0 00-.05.09.12.12 0 000 .07v.02a.27.27 0 00.06.06L466.75 512 338.88 639.86c-.05.04-.06.06-.06.08a.12.12 0 000 .07c0 .03.01.05.05.09l45.02 45.02a.2.2 0 00.09.05.12.12 0 00.07 0c.02 0 .04-.01.08-.05L512 557.25l127.86 127.87c.04.04.06.05.08.05a.12.12 0 00.07 0c.03 0 .05-.01.09-.05l45.02-45.02a.2.2 0 00.05-.09.12.12 0 000-.07v-.02a.27.27 0 00-.05-.06L557.25 512l127.87-127.86c.04-.04.05-.06.05-.08a.12.12 0 000-.07c0-.03-.01-.05-.05-.09l-45.02-45.02a.2.2 0 00-.09-.05.12.12 0 00-.07 0z" } }] }, "name": "close-circle", "theme": "filled" };

    var CloseCircleFilled = function CloseCircleFilled(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: CloseCircleFilled$1
      }));
    };

    /**![close-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iNjQgNjQgODk2IDg5NiIgZm9jdXNhYmxlPSJmYWxzZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNTEyIDY0YzI0Ny40IDAgNDQ4IDIwMC42IDQ0OCA0NDhTNzU5LjQgOTYwIDUxMiA5NjAgNjQgNzU5LjQgNjQgNTEyIDI2NC42IDY0IDUxMiA2NHptMTI3Ljk4IDI3NC44MmgtLjA0bC0uMDguMDZMNTEyIDQ2Ni43NSAzODQuMTQgMzM4Ljg4Yy0uMDQtLjA1LS4wNi0uMDYtLjA4LS4wNmEuMTIuMTIgMCAwMC0uMDcgMGMtLjAzIDAtLjA1LjAxLS4wOS4wNWwtNDUuMDIgNDUuMDJhLjIuMiAwIDAwLS4wNS4wOS4xMi4xMiAwIDAwMCAuMDd2LjAyYS4yNy4yNyAwIDAwLjA2LjA2TDQ2Ni43NSA1MTIgMzM4Ljg4IDYzOS44NmMtLjA1LjA0LS4wNi4wNi0uMDYuMDhhLjEyLjEyIDAgMDAwIC4wN2MwIC4wMy4wMS4wNS4wNS4wOWw0NS4wMiA0NS4wMmEuMi4yIDAgMDAuMDkuMDUuMTIuMTIgMCAwMC4wNyAwYy4wMiAwIC4wNC0uMDEuMDgtLjA1TDUxMiA1NTcuMjVsMTI3Ljg2IDEyNy44N2MuMDQuMDQuMDYuMDUuMDguMDVhLjEyLjEyIDAgMDAuMDcgMGMuMDMgMCAuMDUtLjAxLjA5LS4wNWw0NS4wMi00NS4wMmEuMi4yIDAgMDAuMDUtLjA5LjEyLjEyIDAgMDAwLS4wN3YtLjAyYS4yNy4yNyAwIDAwLS4wNS0uMDZMNTU3LjI1IDUxMmwxMjcuODctMTI3Ljg2Yy4wNC0uMDQuMDUtLjA2LjA1LS4wOGEuMTIuMTIgMCAwMDAtLjA3YzAtLjAzLS4wMS0uMDUtLjA1LS4wOWwtNDUuMDItNDUuMDJhLjIuMiAwIDAwLS4wOS0uMDUuMTIuMTIgMCAwMC0uMDcgMHoiIC8+PC9zdmc+) */
    var RefIcon$7 = /*#__PURE__*/reactExports.forwardRef(CloseCircleFilled);

    // This icon file is generated automatically.
    var CloseOutlined$1 = { "icon": { "tag": "svg", "attrs": { "fill-rule": "evenodd", "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M799.86 166.31c.02 0 .04.02.08.06l57.69 57.7c.04.03.05.05.06.08a.12.12 0 010 .06c0 .03-.02.05-.06.09L569.93 512l287.7 287.7c.04.04.05.06.06.09a.12.12 0 010 .07c0 .02-.02.04-.06.08l-57.7 57.69c-.03.04-.05.05-.07.06a.12.12 0 01-.07 0c-.03 0-.05-.02-.09-.06L512 569.93l-287.7 287.7c-.04.04-.06.05-.09.06a.12.12 0 01-.07 0c-.02 0-.04-.02-.08-.06l-57.69-57.7c-.04-.03-.05-.05-.06-.07a.12.12 0 010-.07c0-.03.02-.05.06-.09L454.07 512l-287.7-287.7c-.04-.04-.05-.06-.06-.09a.12.12 0 010-.07c0-.02.02-.04.06-.08l57.7-57.69c.03-.04.05-.05.07-.06a.12.12 0 01.07 0c.03 0 .05.02.09.06L512 454.07l287.7-287.7c.04-.04.06-.05.09-.06a.12.12 0 01.07 0z" } }] }, "name": "close", "theme": "outlined" };

    var CloseOutlined = function CloseOutlined(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: CloseOutlined$1
      }));
    };

    /**![close](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIGZpbGwtcnVsZT0iZXZlbm9kZCIgdmlld0JveD0iNjQgNjQgODk2IDg5NiIgZm9jdXNhYmxlPSJmYWxzZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cGF0aCBkPSJNNzk5Ljg2IDE2Ni4zMWMuMDIgMCAuMDQuMDIuMDguMDZsNTcuNjkgNTcuN2MuMDQuMDMuMDUuMDUuMDYuMDhhLjEyLjEyIDAgMDEwIC4wNmMwIC4wMy0uMDIuMDUtLjA2LjA5TDU2OS45MyA1MTJsMjg3LjcgMjg3LjdjLjA0LjA0LjA1LjA2LjA2LjA5YS4xMi4xMiAwIDAxMCAuMDdjMCAuMDItLjAyLjA0LS4wNi4wOGwtNTcuNyA1Ny42OWMtLjAzLjA0LS4wNS4wNS0uMDcuMDZhLjEyLjEyIDAgMDEtLjA3IDBjLS4wMyAwLS4wNS0uMDItLjA5LS4wNkw1MTIgNTY5LjkzbC0yODcuNyAyODcuN2MtLjA0LjA0LS4wNi4wNS0uMDkuMDZhLjEyLjEyIDAgMDEtLjA3IDBjLS4wMiAwLS4wNC0uMDItLjA4LS4wNmwtNTcuNjktNTcuN2MtLjA0LS4wMy0uMDUtLjA1LS4wNi0uMDdhLjEyLjEyIDAgMDEwLS4wN2MwLS4wMy4wMi0uMDUuMDYtLjA5TDQ1NC4wNyA1MTJsLTI4Ny43LTI4Ny43Yy0uMDQtLjA0LS4wNS0uMDYtLjA2LS4wOWEuMTIuMTIgMCAwMTAtLjA3YzAtLjAyLjAyLS4wNC4wNi0uMDhsNTcuNy01Ny42OWMuMDMtLjA0LjA1LS4wNS4wNy0uMDZhLjEyLjEyIDAgMDEuMDcgMGMuMDMgMCAuMDUuMDIuMDkuMDZMNTEyIDQ1NC4wN2wyODcuNy0yODcuN2MuMDQtLjA0LjA2LS4wNS4wOS0uMDZhLjEyLjEyIDAgMDEuMDcgMHoiIC8+PC9zdmc+) */
    var RefIcon$6 = /*#__PURE__*/reactExports.forwardRef(CloseOutlined);

    // This icon file is generated automatically.
    var ExclamationCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm-32 232c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V296zm32 440a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "exclamation-circle", "theme": "filled" };

    var ExclamationCircleFilled = function ExclamationCircleFilled(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: ExclamationCircleFilled$1
      }));
    };

    /**![exclamation-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0tMzIgMjMyYzAtNC40IDMuNi04IDgtOGg0OGM0LjQgMCA4IDMuNiA4IDh2MjcyYzAgNC40LTMuNiA4LTggOGgtNDhjLTQuNCAwLTgtMy42LTgtOFYyOTZ6bTMyIDQ0MGE0OC4wMSA0OC4wMSAwIDAxMC05NiA0OC4wMSA0OC4wMSAwIDAxMCA5NnoiIC8+PC9zdmc+) */
    var RefIcon$5 = /*#__PURE__*/reactExports.forwardRef(ExclamationCircleFilled);

    // This icon file is generated automatically.
    var InfoCircleFilled$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M512 64C264.6 64 64 264.6 64 512s200.6 448 448 448 448-200.6 448-448S759.4 64 512 64zm32 664c0 4.4-3.6 8-8 8h-48c-4.4 0-8-3.6-8-8V456c0-4.4 3.6-8 8-8h48c4.4 0 8 3.6 8 8v272zm-32-344a48.01 48.01 0 010-96 48.01 48.01 0 010 96z" } }] }, "name": "info-circle", "theme": "filled" };

    var InfoCircleFilled = function InfoCircleFilled(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: InfoCircleFilled$1
      }));
    };

    /**![info-circle](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTUxMiA2NEMyNjQuNiA2NCA2NCAyNjQuNiA2NCA1MTJzMjAwLjYgNDQ4IDQ0OCA0NDggNDQ4LTIwMC42IDQ0OC00NDhTNzU5LjQgNjQgNTEyIDY0em0zMiA2NjRjMCA0LjQtMy42IDgtOCA4aC00OGMtNC40IDAtOC0zLjYtOC04VjQ1NmMwLTQuNCAzLjYtOCA4LThoNDhjNC40IDAgOCAzLjYgOCA4djI3MnptLTMyLTM0NGE0OC4wMSA0OC4wMSAwIDAxMC05NiA0OC4wMSA0OC4wMSAwIDAxMCA5NnoiIC8+PC9zdmc+) */
    var RefIcon$4 = /*#__PURE__*/reactExports.forwardRef(InfoCircleFilled);

    var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
    var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
    var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);

    /* eslint-enable max-len */
    var ariaPrefix = 'aria-';
    var dataPrefix = 'data-';
    function match(key, prefix) {
      return key.indexOf(prefix) === 0;
    }
    /**
     * Picker props from exist props with filter
     * @param props Passed props
     * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
     */
    function pickAttrs(props) {
      var ariaOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var mergedConfig;
      if (ariaOnly === false) {
        mergedConfig = {
          aria: true,
          data: true,
          attr: true
        };
      } else if (ariaOnly === true) {
        mergedConfig = {
          aria: true
        };
      } else {
        mergedConfig = _objectSpread2({}, ariaOnly);
      }
      var attrs = {};
      Object.keys(props).forEach(function (key) {
        if (
        // Aria
        mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) ||
        // Data
        mergedConfig.data && match(key, dataPrefix) ||
        // Attr
        mergedConfig.attr && propList.includes(key)) {
          attrs[key] = props[key];
        }
      });
      return attrs;
    }

    function isFragment(child) {
      return child && /*#__PURE__*/React.isValidElement(child) && child.type === React.Fragment;
    }
    const replaceElement = (element, replacement, props) => {
      if (! /*#__PURE__*/React.isValidElement(element)) {
        return replacement;
      }
      return /*#__PURE__*/React.cloneElement(element, typeof props === 'function' ? props(element.props || {}) : props);
    };
    function cloneElement(element, props) {
      return replaceElement(element, element, props);
    }

    /**
     * This hook is only for cssVar to add root className for components.
     * If root ClassName is needed, this hook could be refactored with `-root`
     * @param prefixCls
     */
    const useCSSVarCls = prefixCls => {
      const [,,,, cssVar] = useToken();
      return cssVar ? `${prefixCls}-css-var` : '';
    };

    /**
     * @ignore
     * some key-codes definition and utils from closure-library
     * @author yiminghe@gmail.com
     */

    var KeyCode = {
      // NUMLOCK on FF/Safari Mac
      /**
       * ENTER
       */
      ENTER: 13};

    var Notify = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
      var prefixCls = props.prefixCls,
        style = props.style,
        className = props.className,
        _props$duration = props.duration,
        duration = _props$duration === void 0 ? 4.5 : _props$duration,
        showProgress = props.showProgress,
        _props$pauseOnHover = props.pauseOnHover,
        pauseOnHover = _props$pauseOnHover === void 0 ? true : _props$pauseOnHover,
        eventKey = props.eventKey,
        content = props.content,
        closable = props.closable,
        _props$closeIcon = props.closeIcon,
        closeIcon = _props$closeIcon === void 0 ? 'x' : _props$closeIcon,
        divProps = props.props,
        onClick = props.onClick,
        onNoticeClose = props.onNoticeClose,
        times = props.times,
        forcedHovering = props.hovering;
      var _React$useState = reactExports.useState(false),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        hovering = _React$useState2[0],
        setHovering = _React$useState2[1];
      var _React$useState3 = reactExports.useState(0),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        percent = _React$useState4[0],
        setPercent = _React$useState4[1];
      var _React$useState5 = reactExports.useState(0),
        _React$useState6 = _slicedToArray(_React$useState5, 2),
        spentTime = _React$useState6[0],
        setSpentTime = _React$useState6[1];
      var mergedHovering = forcedHovering || hovering;
      var mergedShowProgress = duration > 0 && showProgress;

      // ======================== Close =========================
      var onInternalClose = function onInternalClose() {
        onNoticeClose(eventKey);
      };
      var onCloseKeyDown = function onCloseKeyDown(e) {
        if (e.key === 'Enter' || e.code === 'Enter' || e.keyCode === KeyCode.ENTER) {
          onInternalClose();
        }
      };

      // ======================== Effect ========================
      reactExports.useEffect(function () {
        if (!mergedHovering && duration > 0) {
          var start = Date.now() - spentTime;
          var timeout = setTimeout(function () {
            onInternalClose();
          }, duration * 1000 - spentTime);
          return function () {
            if (pauseOnHover) {
              clearTimeout(timeout);
            }
            setSpentTime(Date.now() - start);
          };
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [duration, mergedHovering, times]);
      reactExports.useEffect(function () {
        if (!mergedHovering && mergedShowProgress && (pauseOnHover || spentTime === 0)) {
          var start = performance.now();
          var animationFrame;
          var calculate = function calculate() {
            cancelAnimationFrame(animationFrame);
            animationFrame = requestAnimationFrame(function (timestamp) {
              var runtime = timestamp + spentTime - start;
              var progress = Math.min(runtime / (duration * 1000), 1);
              setPercent(progress * 100);
              if (progress < 1) {
                calculate();
              }
            });
          };
          calculate();
          return function () {
            if (pauseOnHover) {
              cancelAnimationFrame(animationFrame);
            }
          };
        }
        // eslint-disable-next-line react-hooks/exhaustive-deps
      }, [duration, spentTime, mergedHovering, mergedShowProgress, times]);

      // ======================== Closable ========================
      var closableObj = reactExports.useMemo(function () {
        if (_typeof(closable) === 'object' && closable !== null) {
          return closable;
        }
        if (closable) {
          return {
            closeIcon: closeIcon
          };
        }
        return {};
      }, [closable, closeIcon]);
      var ariaProps = pickAttrs(closableObj, true);

      // ======================== Progress ========================
      var validPercent = 100 - (!percent || percent < 0 ? 0 : percent > 100 ? 100 : percent);

      // ======================== Render ========================
      var noticePrefixCls = "".concat(prefixCls, "-notice");
      return /*#__PURE__*/reactExports.createElement("div", _extends({}, divProps, {
        ref: ref,
        className: classNames(noticePrefixCls, className, _defineProperty({}, "".concat(noticePrefixCls, "-closable"), closable)),
        style: style,
        onMouseEnter: function onMouseEnter(e) {
          var _divProps$onMouseEnte;
          setHovering(true);
          divProps === null || divProps === void 0 || (_divProps$onMouseEnte = divProps.onMouseEnter) === null || _divProps$onMouseEnte === void 0 || _divProps$onMouseEnte.call(divProps, e);
        },
        onMouseLeave: function onMouseLeave(e) {
          var _divProps$onMouseLeav;
          setHovering(false);
          divProps === null || divProps === void 0 || (_divProps$onMouseLeav = divProps.onMouseLeave) === null || _divProps$onMouseLeav === void 0 || _divProps$onMouseLeav.call(divProps, e);
        },
        onClick: onClick
      }), /*#__PURE__*/reactExports.createElement("div", {
        className: "".concat(noticePrefixCls, "-content")
      }, content), closable && /*#__PURE__*/reactExports.createElement("a", _extends({
        tabIndex: 0,
        className: "".concat(noticePrefixCls, "-close"),
        onKeyDown: onCloseKeyDown,
        "aria-label": "Close"
      }, ariaProps, {
        onClick: function onClick(e) {
          e.preventDefault();
          e.stopPropagation();
          onInternalClose();
        }
      }), closableObj.closeIcon), mergedShowProgress && /*#__PURE__*/reactExports.createElement("progress", {
        className: "".concat(noticePrefixCls, "-progress"),
        max: "100",
        value: validPercent
      }, validPercent + '%'));
    });

    var NotificationContext = /*#__PURE__*/React.createContext({});
    var NotificationProvider = function NotificationProvider(_ref) {
      var children = _ref.children,
        classNames = _ref.classNames;
      return /*#__PURE__*/React.createElement(NotificationContext.Provider, {
        value: {
          classNames: classNames
        }
      }, children);
    };

    var DEFAULT_OFFSET$1 = 8;
    var DEFAULT_THRESHOLD = 3;
    var DEFAULT_GAP = 16;
    var useStack = function useStack(config) {
      var result = {
        offset: DEFAULT_OFFSET$1,
        threshold: DEFAULT_THRESHOLD,
        gap: DEFAULT_GAP
      };
      if (config && _typeof(config) === 'object') {
        var _config$offset, _config$threshold, _config$gap;
        result.offset = (_config$offset = config.offset) !== null && _config$offset !== void 0 ? _config$offset : DEFAULT_OFFSET$1;
        result.threshold = (_config$threshold = config.threshold) !== null && _config$threshold !== void 0 ? _config$threshold : DEFAULT_THRESHOLD;
        result.gap = (_config$gap = config.gap) !== null && _config$gap !== void 0 ? _config$gap : DEFAULT_GAP;
      }
      return [!!config, result];
    };

    var _excluded$9 = ["className", "style", "classNames", "styles"];
    var NoticeList = function NoticeList(props) {
      var configList = props.configList,
        placement = props.placement,
        prefixCls = props.prefixCls,
        className = props.className,
        style = props.style,
        motion = props.motion,
        onAllNoticeRemoved = props.onAllNoticeRemoved,
        onNoticeClose = props.onNoticeClose,
        stackConfig = props.stack;
      var _useContext = reactExports.useContext(NotificationContext),
        ctxCls = _useContext.classNames;
      var dictRef = reactExports.useRef({});
      var _useState = reactExports.useState(null),
        _useState2 = _slicedToArray(_useState, 2),
        latestNotice = _useState2[0],
        setLatestNotice = _useState2[1];
      var _useState3 = reactExports.useState([]),
        _useState4 = _slicedToArray(_useState3, 2),
        hoverKeys = _useState4[0],
        setHoverKeys = _useState4[1];
      var keys = configList.map(function (config) {
        return {
          config: config,
          key: String(config.key)
        };
      });
      var _useStack = useStack(stackConfig),
        _useStack2 = _slicedToArray(_useStack, 2),
        stack = _useStack2[0],
        _useStack2$ = _useStack2[1],
        offset = _useStack2$.offset,
        threshold = _useStack2$.threshold,
        gap = _useStack2$.gap;
      var expanded = stack && (hoverKeys.length > 0 || keys.length <= threshold);
      var placementMotion = typeof motion === 'function' ? motion(placement) : motion;

      // Clean hover key
      reactExports.useEffect(function () {
        if (stack && hoverKeys.length > 1) {
          setHoverKeys(function (prev) {
            return prev.filter(function (key) {
              return keys.some(function (_ref) {
                var dataKey = _ref.key;
                return key === dataKey;
              });
            });
          });
        }
      }, [hoverKeys, keys, stack]);

      // Force update latest notice
      reactExports.useEffect(function () {
        var _keys;
        if (stack && dictRef.current[(_keys = keys[keys.length - 1]) === null || _keys === void 0 ? void 0 : _keys.key]) {
          var _keys2;
          setLatestNotice(dictRef.current[(_keys2 = keys[keys.length - 1]) === null || _keys2 === void 0 ? void 0 : _keys2.key]);
        }
      }, [keys, stack]);
      return /*#__PURE__*/React.createElement(CSSMotionList, _extends({
        key: placement,
        className: classNames(prefixCls, "".concat(prefixCls, "-").concat(placement), ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.list, className, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-stack"), !!stack), "".concat(prefixCls, "-stack-expanded"), expanded)),
        style: style,
        keys: keys,
        motionAppear: true
      }, placementMotion, {
        onAllRemoved: function onAllRemoved() {
          onAllNoticeRemoved(placement);
        }
      }), function (_ref2, nodeRef) {
        var config = _ref2.config,
          motionClassName = _ref2.className,
          motionStyle = _ref2.style,
          motionIndex = _ref2.index;
        var _ref3 = config,
          key = _ref3.key,
          times = _ref3.times;
        var strKey = String(key);
        var _ref4 = config,
          configClassName = _ref4.className,
          configStyle = _ref4.style,
          configClassNames = _ref4.classNames,
          configStyles = _ref4.styles,
          restConfig = _objectWithoutProperties(_ref4, _excluded$9);
        var dataIndex = keys.findIndex(function (item) {
          return item.key === strKey;
        });

        // If dataIndex is -1, that means this notice has been removed in data, but still in dom
        // Should minus (motionIndex - 1) to get the correct index because keys.length is not the same as dom length
        var stackStyle = {};
        if (stack) {
          var index = keys.length - 1 - (dataIndex > -1 ? dataIndex : motionIndex - 1);
          var transformX = placement === 'top' || placement === 'bottom' ? '-50%' : '0';
          if (index > 0) {
            var _dictRef$current$strK, _dictRef$current$strK2, _dictRef$current$strK3;
            stackStyle.height = expanded ? (_dictRef$current$strK = dictRef.current[strKey]) === null || _dictRef$current$strK === void 0 ? void 0 : _dictRef$current$strK.offsetHeight : latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetHeight;

            // Transform
            var verticalOffset = 0;
            for (var i = 0; i < index; i++) {
              var _dictRef$current$keys;
              verticalOffset += ((_dictRef$current$keys = dictRef.current[keys[keys.length - 1 - i].key]) === null || _dictRef$current$keys === void 0 ? void 0 : _dictRef$current$keys.offsetHeight) + gap;
            }
            var transformY = (expanded ? verticalOffset : index * offset) * (placement.startsWith('top') ? 1 : -1);
            var scaleX = !expanded && latestNotice !== null && latestNotice !== void 0 && latestNotice.offsetWidth && (_dictRef$current$strK2 = dictRef.current[strKey]) !== null && _dictRef$current$strK2 !== void 0 && _dictRef$current$strK2.offsetWidth ? ((latestNotice === null || latestNotice === void 0 ? void 0 : latestNotice.offsetWidth) - offset * 2 * (index < 3 ? index : 3)) / ((_dictRef$current$strK3 = dictRef.current[strKey]) === null || _dictRef$current$strK3 === void 0 ? void 0 : _dictRef$current$strK3.offsetWidth) : 1;
            stackStyle.transform = "translate3d(".concat(transformX, ", ").concat(transformY, "px, 0) scaleX(").concat(scaleX, ")");
          } else {
            stackStyle.transform = "translate3d(".concat(transformX, ", 0, 0)");
          }
        }
        return /*#__PURE__*/React.createElement("div", {
          ref: nodeRef,
          className: classNames("".concat(prefixCls, "-notice-wrapper"), motionClassName, configClassNames === null || configClassNames === void 0 ? void 0 : configClassNames.wrapper),
          style: _objectSpread2(_objectSpread2(_objectSpread2({}, motionStyle), stackStyle), configStyles === null || configStyles === void 0 ? void 0 : configStyles.wrapper),
          onMouseEnter: function onMouseEnter() {
            return setHoverKeys(function (prev) {
              return prev.includes(strKey) ? prev : [].concat(_toConsumableArray(prev), [strKey]);
            });
          },
          onMouseLeave: function onMouseLeave() {
            return setHoverKeys(function (prev) {
              return prev.filter(function (k) {
                return k !== strKey;
              });
            });
          }
        }, /*#__PURE__*/React.createElement(Notify, _extends({}, restConfig, {
          ref: function ref(node) {
            if (dataIndex > -1) {
              dictRef.current[strKey] = node;
            } else {
              delete dictRef.current[strKey];
            }
          },
          prefixCls: prefixCls,
          classNames: configClassNames,
          styles: configStyles,
          className: classNames(configClassName, ctxCls === null || ctxCls === void 0 ? void 0 : ctxCls.notice),
          style: configStyle,
          times: times,
          key: key,
          eventKey: key,
          onNoticeClose: onNoticeClose,
          hovering: stack && hoverKeys.length > 0
        })));
      });
    };

    // ant-notification ant-notification-topRight
    var Notifications = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
      var _props$prefixCls = props.prefixCls,
        prefixCls = _props$prefixCls === void 0 ? 'rc-notification' : _props$prefixCls,
        container = props.container,
        motion = props.motion,
        maxCount = props.maxCount,
        className = props.className,
        style = props.style,
        onAllRemoved = props.onAllRemoved,
        stack = props.stack,
        renderNotifications = props.renderNotifications;
      var _React$useState = reactExports.useState([]),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        configList = _React$useState2[0],
        setConfigList = _React$useState2[1];

      // ======================== Close =========================
      var onNoticeClose = function onNoticeClose(key) {
        var _config$onClose;
        // Trigger close event
        var config = configList.find(function (item) {
          return item.key === key;
        });
        config === null || config === void 0 || (_config$onClose = config.onClose) === null || _config$onClose === void 0 || _config$onClose.call(config);
        setConfigList(function (list) {
          return list.filter(function (item) {
            return item.key !== key;
          });
        });
      };

      // ========================= Refs =========================
      reactExports.useImperativeHandle(ref, function () {
        return {
          open: function open(config) {
            setConfigList(function (list) {
              var clone = _toConsumableArray(list);

              // Replace if exist
              var index = clone.findIndex(function (item) {
                return item.key === config.key;
              });
              var innerConfig = _objectSpread2({}, config);
              if (index >= 0) {
                var _list$index;
                innerConfig.times = (((_list$index = list[index]) === null || _list$index === void 0 ? void 0 : _list$index.times) || 0) + 1;
                clone[index] = innerConfig;
              } else {
                innerConfig.times = 0;
                clone.push(innerConfig);
              }
              if (maxCount > 0 && clone.length > maxCount) {
                clone = clone.slice(-maxCount);
              }
              return clone;
            });
          },
          close: function close(key) {
            onNoticeClose(key);
          },
          destroy: function destroy() {
            setConfigList([]);
          }
        };
      });

      // ====================== Placements ======================
      var _React$useState3 = reactExports.useState({}),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        placements = _React$useState4[0],
        setPlacements = _React$useState4[1];
      reactExports.useEffect(function () {
        var nextPlacements = {};
        configList.forEach(function (config) {
          var _config$placement = config.placement,
            placement = _config$placement === void 0 ? 'topRight' : _config$placement;
          if (placement) {
            nextPlacements[placement] = nextPlacements[placement] || [];
            nextPlacements[placement].push(config);
          }
        });

        // Fill exist placements to avoid empty list causing remove without motion
        Object.keys(placements).forEach(function (placement) {
          nextPlacements[placement] = nextPlacements[placement] || [];
        });
        setPlacements(nextPlacements);
      }, [configList]);

      // Clean up container if all notices fade out
      var onAllNoticeRemoved = function onAllNoticeRemoved(placement) {
        setPlacements(function (originPlacements) {
          var clone = _objectSpread2({}, originPlacements);
          var list = clone[placement] || [];
          if (!list.length) {
            delete clone[placement];
          }
          return clone;
        });
      };

      // Effect tell that placements is empty now
      var emptyRef = reactExports.useRef(false);
      reactExports.useEffect(function () {
        if (Object.keys(placements).length > 0) {
          emptyRef.current = true;
        } else if (emptyRef.current) {
          // Trigger only when from exist to empty
          onAllRemoved === null || onAllRemoved === void 0 || onAllRemoved();
          emptyRef.current = false;
        }
      }, [placements]);
      // ======================== Render ========================
      if (!container) {
        return null;
      }
      var placementList = Object.keys(placements);
      return /*#__PURE__*/reactDomExports.createPortal( /*#__PURE__*/reactExports.createElement(reactExports.Fragment, null, placementList.map(function (placement) {
        var placementConfigList = placements[placement];
        var list = /*#__PURE__*/reactExports.createElement(NoticeList, {
          key: placement,
          configList: placementConfigList,
          placement: placement,
          prefixCls: prefixCls,
          className: className === null || className === void 0 ? void 0 : className(placement),
          style: style === null || style === void 0 ? void 0 : style(placement),
          motion: motion,
          onNoticeClose: onNoticeClose,
          onAllNoticeRemoved: onAllNoticeRemoved,
          stack: stack
        });
        return renderNotifications ? renderNotifications(list, {
          prefixCls: prefixCls,
          key: placement
        }) : list;
      })), container);
    });

    var _excluded$8 = ["getContainer", "motion", "prefixCls", "maxCount", "className", "style", "onAllRemoved", "stack", "renderNotifications"];
    var defaultGetContainer = function defaultGetContainer() {
      return document.body;
    };
    var uniqueKey = 0;
    function mergeConfig$2() {
      var clone = {};
      for (var _len = arguments.length, objList = new Array(_len), _key = 0; _key < _len; _key++) {
        objList[_key] = arguments[_key];
      }
      objList.forEach(function (obj) {
        if (obj) {
          Object.keys(obj).forEach(function (key) {
            var val = obj[key];
            if (val !== undefined) {
              clone[key] = val;
            }
          });
        }
      });
      return clone;
    }
    function useNotification() {
      var rootConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var _rootConfig$getContai = rootConfig.getContainer,
        getContainer = _rootConfig$getContai === void 0 ? defaultGetContainer : _rootConfig$getContai,
        motion = rootConfig.motion,
        prefixCls = rootConfig.prefixCls,
        maxCount = rootConfig.maxCount,
        className = rootConfig.className,
        style = rootConfig.style,
        onAllRemoved = rootConfig.onAllRemoved,
        stack = rootConfig.stack,
        renderNotifications = rootConfig.renderNotifications,
        shareConfig = _objectWithoutProperties(rootConfig, _excluded$8);
      var _React$useState = reactExports.useState(),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        container = _React$useState2[0],
        setContainer = _React$useState2[1];
      var notificationsRef = reactExports.useRef();
      var contextHolder = /*#__PURE__*/reactExports.createElement(Notifications, {
        container: container,
        ref: notificationsRef,
        prefixCls: prefixCls,
        motion: motion,
        maxCount: maxCount,
        className: className,
        style: style,
        onAllRemoved: onAllRemoved,
        stack: stack,
        renderNotifications: renderNotifications
      });
      var _React$useState3 = reactExports.useState([]),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        taskQueue = _React$useState4[0],
        setTaskQueue = _React$useState4[1];

      // ========================= Refs =========================
      var api = reactExports.useMemo(function () {
        return {
          open: function open(config) {
            var mergedConfig = mergeConfig$2(shareConfig, config);
            if (mergedConfig.key === null || mergedConfig.key === undefined) {
              mergedConfig.key = "rc-notification-".concat(uniqueKey);
              uniqueKey += 1;
            }
            setTaskQueue(function (queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: 'open',
                config: mergedConfig
              }]);
            });
          },
          close: function close(key) {
            setTaskQueue(function (queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: 'close',
                key: key
              }]);
            });
          },
          destroy: function destroy() {
            setTaskQueue(function (queue) {
              return [].concat(_toConsumableArray(queue), [{
                type: 'destroy'
              }]);
            });
          }
        };
      }, []);

      // ======================= Container ======================
      // React 18 should all in effect that we will check container in each render
      // Which means getContainer should be stable.
      reactExports.useEffect(function () {
        setContainer(getContainer());
      });

      // ======================== Effect ========================
      reactExports.useEffect(function () {
        // Flush task when node ready
        if (notificationsRef.current && taskQueue.length) {
          taskQueue.forEach(function (task) {
            switch (task.type) {
              case 'open':
                notificationsRef.current.open(task.config);
                break;
              case 'close':
                notificationsRef.current.close(task.key);
                break;
              case 'destroy':
                notificationsRef.current.destroy();
                break;
            }
          });

          // React 17 will mix order of effect & setState in async
          // - open: setState[0]
          // - effect[0]
          // - open: setState[1]
          // - effect setState([]) * here will clean up [0, 1] in React 17
          setTaskQueue(function (oriQueue) {
            return oriQueue.filter(function (task) {
              return !taskQueue.includes(task);
            });
          });
        }
      }, [taskQueue]);

      // ======================== Return ========================
      return [api, contextHolder];
    }

    // This icon file is generated automatically.
    var LoadingOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "0 0 1024 1024", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M988 548c-19.9 0-36-16.1-36-36 0-59.4-11.6-117-34.6-171.3a440.45 440.45 0 00-94.3-139.9 437.71 437.71 0 00-139.9-94.3C629 83.6 571.4 72 512 72c-19.9 0-36-16.1-36-36s16.1-36 36-36c69.1 0 136.2 13.5 199.3 40.3C772.3 66 827 103 874 150c47 47 83.9 101.8 109.7 162.7 26.7 63.1 40.2 130.2 40.2 199.3.1 19.9-16 36-35.9 36z" } }] }, "name": "loading", "theme": "outlined" };

    var LoadingOutlined = function LoadingOutlined(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: LoadingOutlined$1
      }));
    };

    /**![loading](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjAgMCAxMDI0IDEwMjQiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk4OCA1NDhjLTE5LjkgMC0zNi0xNi4xLTM2LTM2IDAtNTkuNC0xMS42LTExNy0zNC42LTE3MS4zYTQ0MC40NSA0NDAuNDUgMCAwMC05NC4zLTEzOS45IDQzNy43MSA0MzcuNzEgMCAwMC0xMzkuOS05NC4zQzYyOSA4My42IDU3MS40IDcyIDUxMiA3MmMtMTkuOSAwLTM2LTE2LjEtMzYtMzZzMTYuMS0zNiAzNi0zNmM2OS4xIDAgMTM2LjIgMTMuNSAxOTkuMyA0MC4zQzc3Mi4zIDY2IDgyNyAxMDMgODc0IDE1MGM0NyA0NyA4My45IDEwMS44IDEwOS43IDE2Mi43IDI2LjcgNjMuMSA0MC4yIDEzMC4yIDQwLjIgMTk5LjMuMSAxOS45LTE2IDM2LTM1LjkgMzZ6IiAvPjwvc3ZnPg==) */
    var RefIcon$3 = /*#__PURE__*/reactExports.forwardRef(LoadingOutlined);

    // Z-Index control range
    // Container: 1000 + offset 100 (max base + 10 * offset = 2000)
    // Popover: offset 50
    // Notification: Container Max zIndex + componentOffset
    const CONTAINER_OFFSET = 100;
    const CONTAINER_OFFSET_MAX_COUNT = 10;
    const CONTAINER_MAX_OFFSET = CONTAINER_OFFSET * CONTAINER_OFFSET_MAX_COUNT;

    const genMessageStyle = token => {
      const {
        componentCls,
        iconCls,
        boxShadow,
        colorText,
        colorSuccess,
        colorError,
        colorWarning,
        colorInfo,
        fontSizeLG,
        motionEaseInOutCirc,
        motionDurationSlow,
        marginXS,
        paddingXS,
        borderRadiusLG,
        zIndexPopup,
        // Custom token
        contentPadding,
        contentBg
      } = token;
      const noticeCls = `${componentCls}-notice`;
      const messageMoveIn = new Keyframe('MessageMoveIn', {
        '0%': {
          padding: 0,
          transform: 'translateY(-100%)',
          opacity: 0
        },
        '100%': {
          padding: paddingXS,
          transform: 'translateY(0)',
          opacity: 1
        }
      });
      const messageMoveOut = new Keyframe('MessageMoveOut', {
        '0%': {
          maxHeight: token.height,
          padding: paddingXS,
          opacity: 1
        },
        '100%': {
          maxHeight: 0,
          padding: 0,
          opacity: 0
        }
      });
      const noticeStyle = {
        padding: paddingXS,
        textAlign: 'center',
        [`${componentCls}-custom-content`]: {
          display: 'flex',
          alignItems: 'center'
        },
        [`${componentCls}-custom-content > ${iconCls}`]: {
          marginInlineEnd: marginXS,
          // affected by ltr or rtl
          fontSize: fontSizeLG
        },
        [`${noticeCls}-content`]: {
          display: 'inline-block',
          padding: contentPadding,
          background: contentBg,
          borderRadius: borderRadiusLG,
          boxShadow,
          pointerEvents: 'all'
        },
        [`${componentCls}-success > ${iconCls}`]: {
          color: colorSuccess
        },
        [`${componentCls}-error > ${iconCls}`]: {
          color: colorError
        },
        [`${componentCls}-warning > ${iconCls}`]: {
          color: colorWarning
        },
        [`${componentCls}-info > ${iconCls},
      ${componentCls}-loading > ${iconCls}`]: {
          color: colorInfo
        }
      };
      return [
      // ============================ Holder ============================
      {
        [componentCls]: Object.assign(Object.assign({}, resetComponent(token)), {
          color: colorText,
          position: 'fixed',
          top: marginXS,
          width: '100%',
          pointerEvents: 'none',
          zIndex: zIndexPopup,
          [`${componentCls}-move-up`]: {
            animationFillMode: 'forwards'
          },
          [`
        ${componentCls}-move-up-appear,
        ${componentCls}-move-up-enter
      `]: {
            animationName: messageMoveIn,
            animationDuration: motionDurationSlow,
            animationPlayState: 'paused',
            animationTimingFunction: motionEaseInOutCirc
          },
          [`
        ${componentCls}-move-up-appear${componentCls}-move-up-appear-active,
        ${componentCls}-move-up-enter${componentCls}-move-up-enter-active
      `]: {
            animationPlayState: 'running'
          },
          [`${componentCls}-move-up-leave`]: {
            animationName: messageMoveOut,
            animationDuration: motionDurationSlow,
            animationPlayState: 'paused',
            animationTimingFunction: motionEaseInOutCirc
          },
          [`${componentCls}-move-up-leave${componentCls}-move-up-leave-active`]: {
            animationPlayState: 'running'
          },
          '&-rtl': {
            direction: 'rtl',
            span: {
              direction: 'rtl'
            }
          }
        })
      },
      // ============================ Notice ============================
      {
        [componentCls]: {
          [`${noticeCls}-wrapper`]: Object.assign({}, noticeStyle)
        }
      },
      // ============================= Pure =============================
      {
        [`${componentCls}-notice-pure-panel`]: Object.assign(Object.assign({}, noticeStyle), {
          padding: 0,
          textAlign: 'start'
        })
      }];
    };
    const prepareComponentToken$2 = token => ({
      zIndexPopup: token.zIndexPopupBase + CONTAINER_MAX_OFFSET + 10,
      contentBg: token.colorBgElevated,
      contentPadding: `${(token.controlHeightLG - token.fontSize * token.lineHeight) / 2}px ${token.paddingSM}px`
    });
    // ============================== Export ==============================
    var useStyle$5 = genStyleHooks('Message', token => {
      // Gen-style functions here
      const combinedToken = merge$1(token, {
        height: 150
      });
      return [genMessageStyle(combinedToken)];
    }, prepareComponentToken$2);

    var __rest$a = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const TypeIcon = {
      info: /*#__PURE__*/reactExports.createElement(RefIcon$4, null),
      success: /*#__PURE__*/reactExports.createElement(RefIcon$8, null),
      error: /*#__PURE__*/reactExports.createElement(RefIcon$7, null),
      warning: /*#__PURE__*/reactExports.createElement(RefIcon$5, null),
      loading: /*#__PURE__*/reactExports.createElement(RefIcon$3, null)
    };
    const PureContent = _ref => {
      let {
        prefixCls,
        type,
        icon,
        children
      } = _ref;
      return /*#__PURE__*/reactExports.createElement("div", {
        className: classNames(`${prefixCls}-custom-content`, `${prefixCls}-${type}`)
      }, icon || TypeIcon[type], /*#__PURE__*/reactExports.createElement("span", null, children));
    };
    /** @private Internal Component. Do not use in your production. */
    const PurePanel = props => {
      const {
          prefixCls: staticPrefixCls,
          className,
          type,
          icon,
          content
        } = props,
        restProps = __rest$a(props, ["prefixCls", "className", "type", "icon", "content"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = staticPrefixCls || getPrefixCls('message');
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$5(prefixCls, rootCls);
      return wrapCSSVar(/*#__PURE__*/reactExports.createElement(Notify, Object.assign({}, restProps, {
        prefixCls: prefixCls,
        className: classNames(className, hashId, `${prefixCls}-notice-pure-panel`, cssVarCls, rootCls),
        eventKey: "pure",
        duration: null,
        content: /*#__PURE__*/reactExports.createElement(PureContent, {
          prefixCls: prefixCls,
          type: type,
          icon: icon
        }, content)
      })));
    };

    function getMotion(prefixCls, transitionName) {
      return {
        motionName: transitionName !== null && transitionName !== void 0 ? transitionName : `${prefixCls}-move-up`
      };
    }
    /** Wrap message open with promise like function */
    function wrapPromiseFn(openFn) {
      let closeFn;
      const closePromise = new Promise(resolve => {
        closeFn = openFn(() => {
          resolve(true);
        });
      });
      const result = () => {
        closeFn === null || closeFn === void 0 ? void 0 : closeFn();
      };
      result.then = (filled, rejected) => closePromise.then(filled, rejected);
      result.promise = closePromise;
      return result;
    }

    var __rest$9 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const DEFAULT_OFFSET = 8;
    const DEFAULT_DURATION = 3;
    const Wrapper = _ref => {
      let {
        children,
        prefixCls
      } = _ref;
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$5(prefixCls, rootCls);
      return wrapCSSVar(/*#__PURE__*/reactExports.createElement(NotificationProvider, {
        classNames: {
          list: classNames(hashId, cssVarCls, rootCls)
        }
      }, children));
    };
    const renderNotifications = (node, _ref2) => {
      let {
        prefixCls,
        key
      } = _ref2;
      return /*#__PURE__*/reactExports.createElement(Wrapper, {
        prefixCls: prefixCls,
        key: key
      }, node);
    };
    const Holder = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
        top,
        prefixCls: staticPrefixCls,
        getContainer: staticGetContainer,
        maxCount,
        duration = DEFAULT_DURATION,
        rtl,
        transitionName,
        onAllRemoved
      } = props;
      const {
        getPrefixCls,
        getPopupContainer,
        message,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = staticPrefixCls || getPrefixCls('message');
      // =============================== Style ===============================
      const getStyle = () => ({
        left: '50%',
        transform: 'translateX(-50%)',
        top: top !== null && top !== void 0 ? top : DEFAULT_OFFSET
      });
      const getClassName = () => classNames({
        [`${prefixCls}-rtl`]: rtl !== null && rtl !== void 0 ? rtl : direction === 'rtl'
      });
      // ============================== Motion ===============================
      const getNotificationMotion = () => getMotion(prefixCls, transitionName);
      // ============================ Close Icon =============================
      const mergedCloseIcon = /*#__PURE__*/reactExports.createElement("span", {
        className: `${prefixCls}-close-x`
      }, /*#__PURE__*/reactExports.createElement(RefIcon$6, {
        className: `${prefixCls}-close-icon`
      }));
      // ============================== Origin ===============================
      const [api, holder] = useNotification({
        prefixCls,
        style: getStyle,
        className: getClassName,
        motion: getNotificationMotion,
        closable: false,
        closeIcon: mergedCloseIcon,
        duration,
        getContainer: () => (staticGetContainer === null || staticGetContainer === void 0 ? void 0 : staticGetContainer()) || (getPopupContainer === null || getPopupContainer === void 0 ? void 0 : getPopupContainer()) || document.body,
        maxCount,
        onAllRemoved,
        renderNotifications
      });
      // ================================ Ref ================================
      reactExports.useImperativeHandle(ref, () => Object.assign(Object.assign({}, api), {
        prefixCls,
        message
      }));
      return holder;
    });
    // ==============================================================================
    // ==                                   Hook                                   ==
    // ==============================================================================
    let keyIndex = 0;
    function useInternalMessage(messageConfig) {
      const holderRef = reactExports.useRef(null);
      // ================================ API ================================
      const wrapAPI = reactExports.useMemo(() => {
        // Wrap with notification content
        // >>> close
        const close = key => {
          var _a;
          (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.close(key);
        };
        // >>> Open
        const open = config => {
          if (!holderRef.current) {
            const fakeResult = () => {};
            fakeResult.then = () => {};
            return fakeResult;
          }
          const {
            open: originOpen,
            prefixCls,
            message
          } = holderRef.current;
          const noticePrefixCls = `${prefixCls}-notice`;
          const {
              content,
              icon,
              type,
              key,
              className,
              style,
              onClose
            } = config,
            restConfig = __rest$9(config, ["content", "icon", "type", "key", "className", "style", "onClose"]);
          let mergedKey = key;
          if (mergedKey === undefined || mergedKey === null) {
            keyIndex += 1;
            mergedKey = `antd-message-${keyIndex}`;
          }
          return wrapPromiseFn(resolve => {
            originOpen(Object.assign(Object.assign({}, restConfig), {
              key: mergedKey,
              content: (/*#__PURE__*/reactExports.createElement(PureContent, {
                prefixCls: prefixCls,
                type: type,
                icon: icon
              }, content)),
              placement: 'top',
              className: classNames(type && `${noticePrefixCls}-${type}`, className, message === null || message === void 0 ? void 0 : message.className),
              style: Object.assign(Object.assign({}, message === null || message === void 0 ? void 0 : message.style), style),
              onClose: () => {
                onClose === null || onClose === void 0 ? void 0 : onClose();
                resolve();
              }
            }));
            // Return close function
            return () => {
              close(mergedKey);
            };
          });
        };
        // >>> destroy
        const destroy = key => {
          var _a;
          if (key !== undefined) {
            close(key);
          } else {
            (_a = holderRef.current) === null || _a === void 0 ? void 0 : _a.destroy();
          }
        };
        const clone = {
          open,
          destroy
        };
        const keys = ['info', 'success', 'warning', 'error', 'loading'];
        keys.forEach(type => {
          const typeOpen = (jointContent, duration, onClose) => {
            let config;
            if (jointContent && typeof jointContent === 'object' && 'content' in jointContent) {
              config = jointContent;
            } else {
              config = {
                content: jointContent
              };
            }
            // Params
            let mergedDuration;
            let mergedOnClose;
            if (typeof duration === 'function') {
              mergedOnClose = duration;
            } else {
              mergedDuration = duration;
              mergedOnClose = onClose;
            }
            const mergedConfig = Object.assign(Object.assign({
              onClose: mergedOnClose,
              duration: mergedDuration
            }, config), {
              type
            });
            return open(mergedConfig);
          };
          clone[type] = typeOpen;
        });
        return clone;
      }, []);
      // ============================== Return ===============================
      return [wrapAPI, /*#__PURE__*/reactExports.createElement(Holder, Object.assign({
        key: "message-holder"
      }, messageConfig, {
        ref: holderRef
      }))];
    }
    function useMessage(messageConfig) {
      return useInternalMessage(messageConfig);
    }

    function _regeneratorRuntime() {
      _regeneratorRuntime = function _regeneratorRuntime() {
        return e;
      };
      var t,
        e = {},
        r = Object.prototype,
        n = r.hasOwnProperty,
        o = Object.defineProperty || function (t, e, r) {
          t[e] = r.value;
        },
        i = "function" == typeof Symbol ? Symbol : {},
        a = i.iterator || "@@iterator",
        c = i.asyncIterator || "@@asyncIterator",
        u = i.toStringTag || "@@toStringTag";
      function define(t, e, r) {
        return Object.defineProperty(t, e, {
          value: r,
          enumerable: true,
          configurable: true,
          writable: true
        }), t[e];
      }
      try {
        define({}, "");
      } catch (t) {
        define = function define(t, e, r) {
          return t[e] = r;
        };
      }
      function wrap(t, e, r, n) {
        var i = e && e.prototype instanceof Generator ? e : Generator,
          a = Object.create(i.prototype),
          c = new Context(n || []);
        return o(a, "_invoke", {
          value: makeInvokeMethod(t, r, c)
        }), a;
      }
      function tryCatch(t, e, r) {
        try {
          return {
            type: "normal",
            arg: t.call(e, r)
          };
        } catch (t) {
          return {
            type: "throw",
            arg: t
          };
        }
      }
      e.wrap = wrap;
      var h = "suspendedStart",
        l = "suspendedYield",
        f = "executing",
        s = "completed",
        y = {};
      function Generator() {}
      function GeneratorFunction() {}
      function GeneratorFunctionPrototype() {}
      var p = {};
      define(p, a, function () {
        return this;
      });
      var d = Object.getPrototypeOf,
        v = d && d(d(values([])));
      v && v !== r && n.call(v, a) && (p = v);
      var g = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(p);
      function defineIteratorMethods(t) {
        ["next", "throw", "return"].forEach(function (e) {
          define(t, e, function (t) {
            return this._invoke(e, t);
          });
        });
      }
      function AsyncIterator(t, e) {
        function invoke(r, o, i, a) {
          var c = tryCatch(t[r], t, o);
          if ("throw" !== c.type) {
            var u = c.arg,
              h = u.value;
            return h && "object" == _typeof(h) && n.call(h, "__await") ? e.resolve(h.__await).then(function (t) {
              invoke("next", t, i, a);
            }, function (t) {
              invoke("throw", t, i, a);
            }) : e.resolve(h).then(function (t) {
              u.value = t, i(u);
            }, function (t) {
              return invoke("throw", t, i, a);
            });
          }
          a(c.arg);
        }
        var r;
        o(this, "_invoke", {
          value: function value(t, n) {
            function callInvokeWithMethodAndArg() {
              return new e(function (e, r) {
                invoke(t, n, e, r);
              });
            }
            return r = r ? r.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
          }
        });
      }
      function makeInvokeMethod(e, r, n) {
        var o = h;
        return function (i, a) {
          if (o === f) throw Error("Generator is already running");
          if (o === s) {
            if ("throw" === i) throw a;
            return {
              value: t,
              done: true
            };
          }
          for (n.method = i, n.arg = a;;) {
            var c = n.delegate;
            if (c) {
              var u = maybeInvokeDelegate(c, n);
              if (u) {
                if (u === y) continue;
                return u;
              }
            }
            if ("next" === n.method) n.sent = n._sent = n.arg;else if ("throw" === n.method) {
              if (o === h) throw o = s, n.arg;
              n.dispatchException(n.arg);
            } else "return" === n.method && n.abrupt("return", n.arg);
            o = f;
            var p = tryCatch(e, r, n);
            if ("normal" === p.type) {
              if (o = n.done ? s : l, p.arg === y) continue;
              return {
                value: p.arg,
                done: n.done
              };
            }
            "throw" === p.type && (o = s, n.method = "throw", n.arg = p.arg);
          }
        };
      }
      function maybeInvokeDelegate(e, r) {
        var n = r.method,
          o = e.iterator[n];
        if (o === t) return r.delegate = null, "throw" === n && e.iterator["return"] && (r.method = "return", r.arg = t, maybeInvokeDelegate(e, r), "throw" === r.method) || "return" !== n && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + n + "' method")), y;
        var i = tryCatch(o, e.iterator, r.arg);
        if ("throw" === i.type) return r.method = "throw", r.arg = i.arg, r.delegate = null, y;
        var a = i.arg;
        return a ? a.done ? (r[e.resultName] = a.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, y) : a : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, y);
      }
      function pushTryEntry(t) {
        var e = {
          tryLoc: t[0]
        };
        1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e);
      }
      function resetTryEntry(t) {
        var e = t.completion || {};
        e.type = "normal", delete e.arg, t.completion = e;
      }
      function Context(t) {
        this.tryEntries = [{
          tryLoc: "root"
        }], t.forEach(pushTryEntry, this), this.reset(true);
      }
      function values(e) {
        if (e || "" === e) {
          var r = e[a];
          if (r) return r.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var o = -1,
              i = function next() {
                for (; ++o < e.length;) if (n.call(e, o)) return next.value = e[o], next.done = false, next;
                return next.value = t, next.done = true, next;
              };
            return i.next = i;
          }
        }
        throw new TypeError(_typeof(e) + " is not iterable");
      }
      return GeneratorFunction.prototype = GeneratorFunctionPrototype, o(g, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: true
      }), o(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: true
      }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, u, "GeneratorFunction"), e.isGeneratorFunction = function (t) {
        var e = "function" == typeof t && t.constructor;
        return !!e && (e === GeneratorFunction || "GeneratorFunction" === (e.displayName || e.name));
      }, e.mark = function (t) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(t, GeneratorFunctionPrototype) : (t.__proto__ = GeneratorFunctionPrototype, define(t, u, "GeneratorFunction")), t.prototype = Object.create(g), t;
      }, e.awrap = function (t) {
        return {
          __await: t
        };
      }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, c, function () {
        return this;
      }), e.AsyncIterator = AsyncIterator, e.async = function (t, r, n, o, i) {
        void 0 === i && (i = Promise);
        var a = new AsyncIterator(wrap(t, r, n, o), i);
        return e.isGeneratorFunction(r) ? a : a.next().then(function (t) {
          return t.done ? t.value : a.next();
        });
      }, defineIteratorMethods(g), define(g, u, "Generator"), define(g, a, function () {
        return this;
      }), define(g, "toString", function () {
        return "[object Generator]";
      }), e.keys = function (t) {
        var e = Object(t),
          r = [];
        for (var n in e) r.push(n);
        return r.reverse(), function next() {
          for (; r.length;) {
            var t = r.pop();
            if (t in e) return next.value = t, next.done = false, next;
          }
          return next.done = true, next;
        };
      }, e.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(e) {
          if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = false, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(resetTryEntry), !e) for (var r in this) "t" === r.charAt(0) && n.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t);
        },
        stop: function stop() {
          this.done = true;
          var t = this.tryEntries[0].completion;
          if ("throw" === t.type) throw t.arg;
          return this.rval;
        },
        dispatchException: function dispatchException(e) {
          if (this.done) throw e;
          var r = this;
          function handle(n, o) {
            return a.type = "throw", a.arg = e, r.next = n, o && (r.method = "next", r.arg = t), !!o;
          }
          for (var o = this.tryEntries.length - 1; o >= 0; --o) {
            var i = this.tryEntries[o],
              a = i.completion;
            if ("root" === i.tryLoc) return handle("end");
            if (i.tryLoc <= this.prev) {
              var c = n.call(i, "catchLoc"),
                u = n.call(i, "finallyLoc");
              if (c && u) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              } else if (c) {
                if (this.prev < i.catchLoc) return handle(i.catchLoc, true);
              } else {
                if (!u) throw Error("try statement without catch or finally");
                if (this.prev < i.finallyLoc) return handle(i.finallyLoc);
              }
            }
          }
        },
        abrupt: function abrupt(t, e) {
          for (var r = this.tryEntries.length - 1; r >= 0; --r) {
            var o = this.tryEntries[r];
            if (o.tryLoc <= this.prev && n.call(o, "finallyLoc") && this.prev < o.finallyLoc) {
              var i = o;
              break;
            }
          }
          i && ("break" === t || "continue" === t) && i.tryLoc <= e && e <= i.finallyLoc && (i = null);
          var a = i ? i.completion : {};
          return a.type = t, a.arg = e, i ? (this.method = "next", this.next = i.finallyLoc, y) : this.complete(a);
        },
        complete: function complete(t, e) {
          if ("throw" === t.type) throw t.arg;
          return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), y;
        },
        finish: function finish(t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), resetTryEntry(r), y;
          }
        },
        "catch": function _catch(t) {
          for (var e = this.tryEntries.length - 1; e >= 0; --e) {
            var r = this.tryEntries[e];
            if (r.tryLoc === t) {
              var n = r.completion;
              if ("throw" === n.type) {
                var o = n.arg;
                resetTryEntry(r);
              }
              return o;
            }
          }
          throw Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(e, r, n) {
          return this.delegate = {
            iterator: values(e),
            resultName: r,
            nextLoc: n
          }, "next" === this.method && (this.arg = t), y;
        }
      }, e;
    }

    function asyncGeneratorStep(n, t, e, r, o, a, c) {
      try {
        var i = n[a](c),
          u = i.value;
      } catch (n) {
        return void e(n);
      }
      i.done ? t(u) : Promise.resolve(u).then(r, o);
    }
    function _asyncToGenerator(n) {
      return function () {
        var t = this,
          e = arguments;
        return new Promise(function (r, o) {
          var a = n.apply(t, e);
          function _next(n) {
            asyncGeneratorStep(a, r, o, _next, _throw, "next", n);
          }
          function _throw(n) {
            asyncGeneratorStep(a, r, o, _next, _throw, "throw", n);
          }
          _next(void 0);
        });
      };
    }

    // Let compiler not to search module usage
    var fullClone = _objectSpread2({}, ReactDOM$1);
    var version = fullClone.version,
      reactRender = fullClone.render,
      unmountComponentAtNode = fullClone.unmountComponentAtNode;
    var createRoot;
    try {
      var mainVersion = Number((version || '').split('.')[0]);
      if (mainVersion >= 18) {
        createRoot = fullClone.createRoot;
      }
    } catch (e) {
      // Do nothing;
    }
    function toggleWarning(skip) {
      var __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = fullClone.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      if (__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED && _typeof(__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED) === 'object') {
        __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.usingClientEntryPoint = skip;
      }
    }
    var MARK = '__rc_react_root__';

    // ========================== Render ==========================

    function modernRender(node, container) {
      toggleWarning(true);
      var root = container[MARK] || createRoot(container);
      toggleWarning(false);
      root.render(node);
      container[MARK] = root;
    }
    function legacyRender(node, container) {
      reactRender === null || reactRender === void 0 || reactRender(node, container);
    }
    function render$1(node, container) {
      if (createRoot) {
        modernRender(node, container);
        return;
      }
      legacyRender(node, container);
    }

    // ========================= Unmount ==========================
    function modernUnmount(_x) {
      return _modernUnmount.apply(this, arguments);
    }
    function _modernUnmount() {
      _modernUnmount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(container) {
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) switch (_context.prev = _context.next) {
            case 0:
              return _context.abrupt("return", Promise.resolve().then(function () {
                var _container$MARK;
                (_container$MARK = container[MARK]) === null || _container$MARK === void 0 || _container$MARK.unmount();
                delete container[MARK];
              }));
            case 1:
            case "end":
              return _context.stop();
          }
        }, _callee);
      }));
      return _modernUnmount.apply(this, arguments);
    }
    function legacyUnmount(container) {
      unmountComponentAtNode(container);
    }
    function unmount$1(_x2) {
      return _unmount.apply(this, arguments);
    }
    function _unmount() {
      _unmount = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(container) {
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              if (!(createRoot !== undefined)) {
                _context2.next = 2;
                break;
              }
              return _context2.abrupt("return", modernUnmount(container));
            case 2:
              legacyUnmount(container);
            case 3:
            case "end":
              return _context2.stop();
          }
        }, _callee2);
      }));
      return _unmount.apply(this, arguments);
    }

    const defaultReactRender = (node, container) => {
      render$1(node, container);
      return () => {
        return unmount$1(container);
      };
    };
    let unstableRender = defaultReactRender;
    function getReactRender() {
      return unstableRender;
    }

    var isVisible = (function (element) {
      if (!element) {
        return false;
      }
      if (element instanceof Element) {
        if (element.offsetParent) {
          return true;
        }
        if (element.getBBox) {
          var _getBBox = element.getBBox(),
            width = _getBBox.width,
            height = _getBBox.height;
          if (width || height) {
            return true;
          }
        }
        if (element.getBoundingClientRect) {
          var _element$getBoundingC = element.getBoundingClientRect(),
            _width = _element$getBoundingC.width,
            _height = _element$getBoundingC.height;
          if (_width || _height) {
            return true;
          }
        }
      }
      return false;
    });

    const genWaveStyle = token => {
      const {
        componentCls,
        colorPrimary
      } = token;
      return {
        [componentCls]: {
          position: 'absolute',
          background: 'transparent',
          pointerEvents: 'none',
          boxSizing: 'border-box',
          color: `var(--wave-color, ${colorPrimary})`,
          boxShadow: `0 0 0 0 currentcolor`,
          opacity: 0.2,
          // =================== Motion ===================
          '&.wave-motion-appear': {
            transition: [`box-shadow 0.4s ${token.motionEaseOutCirc}`, `opacity 2s ${token.motionEaseOutCirc}`].join(','),
            '&-active': {
              boxShadow: `0 0 0 6px currentcolor`,
              opacity: 0
            },
            '&.wave-quick': {
              transition: [`box-shadow ${token.motionDurationSlow} ${token.motionEaseInOut}`, `opacity ${token.motionDurationSlow} ${token.motionEaseInOut}`].join(',')
            }
          }
        }
      };
    };
    var useStyle$4 = genComponentStyleHook('Wave', token => [genWaveStyle(token)]);

    const TARGET_CLS = `${defaultPrefixCls}-wave-target`;

    function isValidWaveColor(color) {
      return color && color !== '#fff' && color !== '#ffffff' && color !== 'rgb(255, 255, 255)' && color !== 'rgba(255, 255, 255, 1)' && !/rgba\((?:\d*, ){3}0\)/.test(color) &&
      // any transparent rgba color
      color !== 'transparent';
    }
    function getTargetWaveColor(node) {
      const {
        borderTopColor,
        borderColor,
        backgroundColor
      } = getComputedStyle(node);
      if (isValidWaveColor(borderTopColor)) {
        return borderTopColor;
      }
      if (isValidWaveColor(borderColor)) {
        return borderColor;
      }
      if (isValidWaveColor(backgroundColor)) {
        return backgroundColor;
      }
      return null;
    }

    function validateNum(value) {
      return Number.isNaN(value) ? 0 : value;
    }
    const WaveEffect = props => {
      const {
        className,
        target,
        component,
        registerUnmount
      } = props;
      const divRef = reactExports.useRef(null);
      // ====================== Refs ======================
      const unmountRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        unmountRef.current = registerUnmount();
      }, []);
      // ===================== Effect =====================
      const [color, setWaveColor] = reactExports.useState(null);
      const [borderRadius, setBorderRadius] = reactExports.useState([]);
      const [left, setLeft] = reactExports.useState(0);
      const [top, setTop] = reactExports.useState(0);
      const [width, setWidth] = reactExports.useState(0);
      const [height, setHeight] = reactExports.useState(0);
      const [enabled, setEnabled] = reactExports.useState(false);
      const waveStyle = {
        left,
        top,
        width,
        height,
        borderRadius: borderRadius.map(radius => `${radius}px`).join(' ')
      };
      if (color) {
        waveStyle['--wave-color'] = color;
      }
      function syncPos() {
        const nodeStyle = getComputedStyle(target);
        // Get wave color from target
        setWaveColor(getTargetWaveColor(target));
        const isStatic = nodeStyle.position === 'static';
        // Rect
        const {
          borderLeftWidth,
          borderTopWidth
        } = nodeStyle;
        setLeft(isStatic ? target.offsetLeft : validateNum(-parseFloat(borderLeftWidth)));
        setTop(isStatic ? target.offsetTop : validateNum(-parseFloat(borderTopWidth)));
        setWidth(target.offsetWidth);
        setHeight(target.offsetHeight);
        // Get border radius
        const {
          borderTopLeftRadius,
          borderTopRightRadius,
          borderBottomLeftRadius,
          borderBottomRightRadius
        } = nodeStyle;
        setBorderRadius([borderTopLeftRadius, borderTopRightRadius, borderBottomRightRadius, borderBottomLeftRadius].map(radius => validateNum(parseFloat(radius))));
      }
      reactExports.useEffect(() => {
        if (target) {
          // We need delay to check position here
          // since UI may change after click
          const id = wrapperRaf(() => {
            syncPos();
            setEnabled(true);
          });
          // Add resize observer to follow size
          let resizeObserver;
          if (typeof ResizeObserver !== 'undefined') {
            resizeObserver = new ResizeObserver(syncPos);
            resizeObserver.observe(target);
          }
          return () => {
            wrapperRaf.cancel(id);
            resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
          };
        }
      }, []);
      if (!enabled) {
        return null;
      }
      const isSmallComponent = (component === 'Checkbox' || component === 'Radio') && (target === null || target === void 0 ? void 0 : target.classList.contains(TARGET_CLS));
      return /*#__PURE__*/reactExports.createElement(CSSMotion, {
        visible: true,
        motionAppear: true,
        motionName: "wave-motion",
        motionDeadline: 5000,
        onAppearEnd: (_, event) => {
          var _a, _b;
          if (event.deadline || event.propertyName === 'opacity') {
            const holder = (_a = divRef.current) === null || _a === void 0 ? void 0 : _a.parentElement;
            (_b = unmountRef.current) === null || _b === void 0 ? void 0 : _b.call(unmountRef).then(() => {
              holder === null || holder === void 0 ? void 0 : holder.remove();
            });
          }
          return false;
        }
      }, (_ref, ref) => {
        let {
          className: motionClassName
        } = _ref;
        return /*#__PURE__*/reactExports.createElement("div", {
          ref: composeRef(divRef, ref),
          className: classNames(className, motionClassName, {
            'wave-quick': isSmallComponent
          }),
          style: waveStyle
        });
      });
    };
    const showWaveEffect = (target, info) => {
      var _a;
      const {
        component
      } = info;
      // Skip for unchecked checkbox
      if (component === 'Checkbox' && !((_a = target.querySelector('input')) === null || _a === void 0 ? void 0 : _a.checked)) {
        return;
      }
      // Create holder
      const holder = document.createElement('div');
      holder.style.position = 'absolute';
      holder.style.left = '0px';
      holder.style.top = '0px';
      target === null || target === void 0 ? void 0 : target.insertBefore(holder, target === null || target === void 0 ? void 0 : target.firstChild);
      const reactRender = getReactRender();
      let unmountCallback = null;
      function registerUnmount() {
        return unmountCallback;
      }
      unmountCallback = reactRender(/*#__PURE__*/reactExports.createElement(WaveEffect, Object.assign({}, info, {
        target: target,
        registerUnmount: registerUnmount
      })), holder);
    };

    const useWave = (nodeRef, className, component) => {
      const {
        wave
      } = reactExports.useContext(ConfigContext);
      const [, token, hashId] = useToken();
      const showWave = useEvent(event => {
        const node = nodeRef.current;
        if ((wave === null || wave === void 0 ? void 0 : wave.disabled) || !node) {
          return;
        }
        const targetNode = node.querySelector(`.${TARGET_CLS}`) || node;
        const {
          showEffect
        } = wave || {};
        // Customize wave effect
        (showEffect || showWaveEffect)(targetNode, {
          className,
          token,
          component,
          event,
          hashId
        });
      });
      const rafId = reactExports.useRef(null);
      // Merge trigger event into one for each frame
      const showDebounceWave = event => {
        wrapperRaf.cancel(rafId.current);
        rafId.current = wrapperRaf(() => {
          showWave(event);
        });
      };
      return showDebounceWave;
    };

    const Wave = props => {
      const {
        children,
        disabled,
        component
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const containerRef = reactExports.useRef(null);
      // ============================== Style ===============================
      const prefixCls = getPrefixCls('wave');
      const [, hashId] = useStyle$4(prefixCls);
      // =============================== Wave ===============================
      const showWave = useWave(containerRef, classNames(prefixCls, hashId), component);
      // ============================== Effect ==============================
      React.useEffect(() => {
        const node = containerRef.current;
        if (!node || node.nodeType !== 1 || disabled) {
          return;
        }
        // Click handler
        const onClick = e => {
          // Fix radio button click twice
          if (!isVisible(e.target) ||
          // No need wave
          !node.getAttribute || node.getAttribute('disabled') || node.disabled || node.className.includes('disabled') || node.className.includes('-leave')) {
            return;
          }
          showWave(e);
        };
        // Bind events
        node.addEventListener('click', onClick, true);
        return () => {
          node.removeEventListener('click', onClick, true);
        };
      }, [disabled]);
      // ============================== Render ==============================
      if (! /*#__PURE__*/React.isValidElement(children)) {
        return children !== null && children !== void 0 ? children : null;
      }
      const ref = supportRef(children) ? composeRef(getNodeRef(children), containerRef) : containerRef;
      return cloneElement(children, {
        ref
      });
    };

    const useSize = customSize => {
      const size = React.useContext(SizeContext);
      const mergedSize = React.useMemo(() => {
        if (!customSize) {
          return size;
        }
        if (typeof customSize === 'string') {
          return customSize !== null && customSize !== void 0 ? customSize : size;
        }
        if (customSize instanceof Function) {
          return customSize(size);
        }
        return size;
      }, [customSize, size]);
      return mergedSize;
    };

    undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const SpaceCompactItemContext = /*#__PURE__*/reactExports.createContext(null);
    const useCompactItemContext = (prefixCls, direction) => {
      const compactItemContext = reactExports.useContext(SpaceCompactItemContext);
      const compactItemClassnames = reactExports.useMemo(() => {
        if (!compactItemContext) {
          return '';
        }
        const {
          compactDirection,
          isFirstItem,
          isLastItem
        } = compactItemContext;
        const separator = compactDirection === 'vertical' ? '-vertical-' : '-';
        return classNames(`${prefixCls}-compact${separator}item`, {
          [`${prefixCls}-compact${separator}first-item`]: isFirstItem,
          [`${prefixCls}-compact${separator}last-item`]: isLastItem,
          [`${prefixCls}-compact${separator}item-rtl`]: direction === 'rtl'
        });
      }, [prefixCls, direction, compactItemContext]);
      return {
        compactSize: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactSize,
        compactDirection: compactItemContext === null || compactItemContext === void 0 ? void 0 : compactItemContext.compactDirection,
        compactItemClassnames
      };
    };
    const NoCompactStyle = _ref => {
      let {
        children
      } = _ref;
      return /*#__PURE__*/reactExports.createElement(SpaceCompactItemContext.Provider, {
        value: null
      }, children);
    };

    var __rest$8 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const GroupSizeContext = /*#__PURE__*/reactExports.createContext(undefined);
    const ButtonGroup = props => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
          prefixCls: customizePrefixCls,
          size,
          className
        } = props,
        others = __rest$8(props, ["prefixCls", "size", "className"]);
      const prefixCls = getPrefixCls('btn-group', customizePrefixCls);
      const [,, hashId] = useToken();
      let sizeCls = '';
      switch (size) {
        case 'large':
          sizeCls = 'lg';
          break;
        case 'small':
          sizeCls = 'sm';
          break;
        // Do nothing
      }
      const classes = classNames(prefixCls, {
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-rtl`]: direction === 'rtl'
      }, className, hashId);
      return /*#__PURE__*/reactExports.createElement(GroupSizeContext.Provider, {
        value: size
      }, /*#__PURE__*/reactExports.createElement("div", Object.assign({}, others, {
        className: classes
      })));
    };

    const rxTwoCNChar = /^[\u4E00-\u9FA5]{2}$/;
    const isTwoCNChar = rxTwoCNChar.test.bind(rxTwoCNChar);
    function isString$1(str) {
      return typeof str === 'string';
    }
    function isUnBorderedButtonVariant(type) {
      return type === 'text' || type === 'link';
    }
    function splitCNCharsBySpace(child, needInserted) {
      if (child === null || child === undefined) {
        return;
      }
      const SPACE = needInserted ? ' ' : '';
      if (typeof child !== 'string' && typeof child !== 'number' && isString$1(child.type) && isTwoCNChar(child.props.children)) {
        return cloneElement(child, {
          children: child.props.children.split('').join(SPACE)
        });
      }
      if (isString$1(child)) {
        return isTwoCNChar(child) ? /*#__PURE__*/React.createElement("span", null, child.split('').join(SPACE)) : /*#__PURE__*/React.createElement("span", null, child);
      }
      if (isFragment(child)) {
        return /*#__PURE__*/React.createElement("span", null, child);
      }
      return child;
    }
    function spaceChildren(children, needInserted) {
      let isPrevChildPure = false;
      const childList = [];
      React.Children.forEach(children, child => {
        const type = typeof child;
        const isCurrentChildPure = type === 'string' || type === 'number';
        if (isPrevChildPure && isCurrentChildPure) {
          const lastIndex = childList.length - 1;
          const lastChild = childList[lastIndex];
          childList[lastIndex] = `${lastChild}${child}`;
        } else {
          childList.push(child);
        }
        isPrevChildPure = isCurrentChildPure;
      });
      return React.Children.map(childList, child => splitCNCharsBySpace(child, needInserted));
    }
    ['default', 'primary', 'danger'].concat(_toConsumableArray(PresetColors));

    const IconWrapper = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
        className,
        style,
        children,
        prefixCls
      } = props;
      const iconWrapperCls = classNames(`${prefixCls}-icon`, className);
      return /*#__PURE__*/React.createElement("span", {
        ref: ref,
        className: iconWrapperCls,
        style: style
      }, children);
    });

    const InnerLoadingIcon = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
        prefixCls,
        className,
        style,
        iconClassName
      } = props;
      const mergedIconCls = classNames(`${prefixCls}-loading-icon`, className);
      return /*#__PURE__*/React.createElement(IconWrapper, {
        prefixCls: prefixCls,
        className: mergedIconCls,
        style: style,
        ref: ref
      }, /*#__PURE__*/React.createElement(RefIcon$3, {
        className: iconClassName
      }));
    });
    const getCollapsedWidth = () => ({
      width: 0,
      opacity: 0,
      transform: 'scale(0)'
    });
    const getRealWidth = node => ({
      width: node.scrollWidth,
      opacity: 1,
      transform: 'scale(1)'
    });
    const DefaultLoadingIcon = props => {
      const {
        prefixCls,
        loading,
        existIcon,
        className,
        style,
        mount
      } = props;
      const visible = !!loading;
      if (existIcon) {
        return /*#__PURE__*/React.createElement(InnerLoadingIcon, {
          prefixCls: prefixCls,
          className: className,
          style: style
        });
      }
      return /*#__PURE__*/React.createElement(CSSMotion, {
        visible: visible,
        // Used for minus flex gap style only
        motionName: `${prefixCls}-loading-icon-motion`,
        motionAppear: !mount,
        motionEnter: !mount,
        motionLeave: !mount,
        removeOnLeave: true,
        onAppearStart: getCollapsedWidth,
        onAppearActive: getRealWidth,
        onEnterStart: getCollapsedWidth,
        onEnterActive: getRealWidth,
        onLeaveStart: getRealWidth,
        onLeaveActive: getCollapsedWidth
      }, (_ref, ref) => {
        let {
          className: motionCls,
          style: motionStyle
        } = _ref;
        const mergedStyle = Object.assign(Object.assign({}, style), motionStyle);
        return /*#__PURE__*/React.createElement(InnerLoadingIcon, {
          prefixCls: prefixCls,
          className: classNames(className, motionCls),
          style: mergedStyle,
          ref: ref
        });
      });
    };

    const genButtonBorderStyle = (buttonTypeCls, borderColor) => ({
      // Border
      [`> span, > ${buttonTypeCls}`]: {
        '&:not(:last-child)': {
          [`&, & > ${buttonTypeCls}`]: {
            '&:not(:disabled)': {
              borderInlineEndColor: borderColor
            }
          }
        },
        '&:not(:first-child)': {
          [`&, & > ${buttonTypeCls}`]: {
            '&:not(:disabled)': {
              borderInlineStartColor: borderColor
            }
          }
        }
      }
    });
    const genGroupStyle$1 = token => {
      const {
        componentCls,
        fontSize,
        lineWidth,
        groupBorderColor,
        colorErrorHover
      } = token;
      return {
        [`${componentCls}-group`]: [{
          position: 'relative',
          display: 'inline-flex',
          // Border
          [`> span, > ${componentCls}`]: {
            '&:not(:last-child)': {
              [`&, & > ${componentCls}`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            '&:not(:first-child)': {
              marginInlineStart: token.calc(lineWidth).mul(-1).equal(),
              [`&, & > ${componentCls}`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            }
          },
          [componentCls]: {
            position: 'relative',
            zIndex: 1,
            '&:hover, &:focus, &:active': {
              zIndex: 2
            },
            '&[disabled]': {
              zIndex: 0
            }
          },
          [`${componentCls}-icon-only`]: {
            fontSize
          }
        },
        // Border Color
        genButtonBorderStyle(`${componentCls}-primary`, groupBorderColor), genButtonBorderStyle(`${componentCls}-danger`, colorErrorHover)]
      };
    };

    var _excluded$7 = ["b"],
      _excluded2 = ["v"];
    var getRoundNumber = function getRoundNumber(value) {
      return Math.round(Number(value || 0));
    };
    var convertHsb2Hsv = function convertHsb2Hsv(color) {
      if (color instanceof FastColor) {
        return color;
      }
      if (color && _typeof(color) === 'object' && 'h' in color && 'b' in color) {
        var _ref = color,
          b = _ref.b,
          resets = _objectWithoutProperties(_ref, _excluded$7);
        return _objectSpread2(_objectSpread2({}, resets), {}, {
          v: b
        });
      }
      if (typeof color === 'string' && /hsb/.test(color)) {
        return color.replace(/hsb/, 'hsv');
      }
      return color;
    };
    var Color = /*#__PURE__*/function (_FastColor) {
      _inherits(Color, _FastColor);
      var _super = _createSuper(Color);
      function Color(color) {
        _classCallCheck(this, Color);
        return _super.call(this, convertHsb2Hsv(color));
      }
      _createClass(Color, [{
        key: "toHsbString",
        value: function toHsbString() {
          var hsb = this.toHsb();
          var saturation = getRoundNumber(hsb.s * 100);
          var lightness = getRoundNumber(hsb.b * 100);
          var hue = getRoundNumber(hsb.h);
          var alpha = hsb.a;
          var hsbString = "hsb(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%)");
          var hsbaString = "hsba(".concat(hue, ", ").concat(saturation, "%, ").concat(lightness, "%, ").concat(alpha.toFixed(alpha === 0 ? 0 : 2), ")");
          return alpha === 1 ? hsbString : hsbaString;
        }
      }, {
        key: "toHsb",
        value: function toHsb() {
          var _this$toHsv = this.toHsv(),
            v = _this$toHsv.v,
            resets = _objectWithoutProperties(_this$toHsv, _excluded2);
          return _objectSpread2(_objectSpread2({}, resets), {}, {
            b: v,
            a: this.a
          });
        }
      }]);
      return Color;
    }(FastColor);

    var generateColor = function generateColor(color) {
      if (color instanceof Color) {
        return color;
      }
      return new Color(color);
    };
    generateColor('#1677ff');

    const toHexFormat = (value, alpha) => (value === null || value === void 0 ? void 0 : value.replace(/[^\w/]/g, '').slice(0, alpha ? 8 : 6)) || '';
    const getHex = (value, alpha) => value ? toHexFormat(value, alpha) : '';
    let AggregationColor = /*#__PURE__*/function () {
      function AggregationColor(color) {
        _classCallCheck(this, AggregationColor);
        var _a;
        this.cleared = false;
        // Clone from another AggregationColor
        if (color instanceof AggregationColor) {
          this.metaColor = color.metaColor.clone();
          this.colors = (_a = color.colors) === null || _a === void 0 ? void 0 : _a.map(info => ({
            color: new AggregationColor(info.color),
            percent: info.percent
          }));
          this.cleared = color.cleared;
          return;
        }
        const isArray = Array.isArray(color);
        if (isArray && color.length) {
          this.colors = color.map(_ref => {
            let {
              color: c,
              percent
            } = _ref;
            return {
              color: new AggregationColor(c),
              percent
            };
          });
          this.metaColor = new Color(this.colors[0].color.metaColor);
        } else {
          this.metaColor = new Color(isArray ? '' : color);
        }
        if (!color || isArray && !this.colors) {
          this.metaColor = this.metaColor.setA(0);
          this.cleared = true;
        }
      }
      return _createClass(AggregationColor, [{
        key: "toHsb",
        value: function toHsb() {
          return this.metaColor.toHsb();
        }
      }, {
        key: "toHsbString",
        value: function toHsbString() {
          return this.metaColor.toHsbString();
        }
      }, {
        key: "toHex",
        value: function toHex() {
          return getHex(this.toHexString(), this.metaColor.a < 1);
        }
      }, {
        key: "toHexString",
        value: function toHexString() {
          return this.metaColor.toHexString();
        }
      }, {
        key: "toRgb",
        value: function toRgb() {
          return this.metaColor.toRgb();
        }
      }, {
        key: "toRgbString",
        value: function toRgbString() {
          return this.metaColor.toRgbString();
        }
      }, {
        key: "isGradient",
        value: function isGradient() {
          return !!this.colors && !this.cleared;
        }
      }, {
        key: "getColors",
        value: function getColors() {
          return this.colors || [{
            color: this,
            percent: 0
          }];
        }
      }, {
        key: "toCssString",
        value: function toCssString() {
          const {
            colors
          } = this;
          // CSS line-gradient
          if (colors) {
            const colorsStr = colors.map(c => `${c.color.toRgbString()} ${c.percent}%`).join(', ');
            return `linear-gradient(90deg, ${colorsStr})`;
          }
          return this.metaColor.toRgbString();
        }
      }, {
        key: "equals",
        value: function equals(color) {
          if (!color || this.isGradient() !== color.isGradient()) {
            return false;
          }
          if (!this.isGradient()) {
            return this.toHexString() === color.toHexString();
          }
          return this.colors.length === color.colors.length && this.colors.every((c, i) => {
            const target = color.colors[i];
            return c.percent === target.percent && c.color.equals(target.color);
          });
        }
      }]);
    }();

    const isBright = (value, bgColorToken) => {
      const {
        r,
        g,
        b,
        a
      } = value.toRgb();
      const hsv = new Color(value.toRgbString()).onBackground(bgColorToken).toHsv();
      if (a <= 0.5) {
        // Adapted to dark mode
        return hsv.v > 0.5;
      }
      return r * 0.299 + g * 0.587 + b * 0.114 > 192;
    };

    const prepareToken = token => {
      const {
        paddingInline,
        onlyIconSize
      } = token;
      const buttonToken = merge$1(token, {
        buttonPaddingHorizontal: paddingInline,
        buttonPaddingVertical: 0,
        buttonIconOnlyFontSize: onlyIconSize
      });
      return buttonToken;
    };
    const prepareComponentToken$1 = token => {
      var _a, _b, _c, _d, _e, _f;
      const contentFontSize = (_a = token.contentFontSize) !== null && _a !== void 0 ? _a : token.fontSize;
      const contentFontSizeSM = (_b = token.contentFontSizeSM) !== null && _b !== void 0 ? _b : token.fontSize;
      const contentFontSizeLG = (_c = token.contentFontSizeLG) !== null && _c !== void 0 ? _c : token.fontSizeLG;
      const contentLineHeight = (_d = token.contentLineHeight) !== null && _d !== void 0 ? _d : getLineHeight(contentFontSize);
      const contentLineHeightSM = (_e = token.contentLineHeightSM) !== null && _e !== void 0 ? _e : getLineHeight(contentFontSizeSM);
      const contentLineHeightLG = (_f = token.contentLineHeightLG) !== null && _f !== void 0 ? _f : getLineHeight(contentFontSizeLG);
      const solidTextColor = isBright(new AggregationColor(token.colorBgSolid), '#fff') ? '#000' : '#fff';
      return {
        fontWeight: 400,
        defaultShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlTmpOutline}`,
        primaryShadow: `0 ${token.controlOutlineWidth}px 0 ${token.controlOutline}`,
        dangerShadow: `0 ${token.controlOutlineWidth}px 0 ${token.colorErrorOutline}`,
        primaryColor: token.colorTextLightSolid,
        dangerColor: token.colorTextLightSolid,
        borderColorDisabled: token.colorBorder,
        defaultGhostColor: token.colorBgContainer,
        ghostBg: 'transparent',
        defaultGhostBorderColor: token.colorBgContainer,
        paddingInline: token.paddingContentHorizontal - token.lineWidth,
        paddingInlineLG: token.paddingContentHorizontal - token.lineWidth,
        paddingInlineSM: 8 - token.lineWidth,
        onlyIconSize: 'inherit',
        onlyIconSizeSM: 'inherit',
        onlyIconSizeLG: 'inherit',
        groupBorderColor: token.colorPrimaryHover,
        linkHoverBg: 'transparent',
        textTextColor: token.colorText,
        textTextHoverColor: token.colorText,
        textTextActiveColor: token.colorText,
        textHoverBg: token.colorFillTertiary,
        defaultColor: token.colorText,
        defaultBg: token.colorBgContainer,
        defaultBorderColor: token.colorBorder,
        defaultBorderColorDisabled: token.colorBorder,
        defaultHoverBg: token.colorBgContainer,
        defaultHoverColor: token.colorPrimaryHover,
        defaultHoverBorderColor: token.colorPrimaryHover,
        defaultActiveBg: token.colorBgContainer,
        defaultActiveColor: token.colorPrimaryActive,
        defaultActiveBorderColor: token.colorPrimaryActive,
        solidTextColor,
        contentFontSize,
        contentFontSizeSM,
        contentFontSizeLG,
        contentLineHeight,
        contentLineHeightSM,
        contentLineHeightLG,
        paddingBlock: Math.max((token.controlHeight - contentFontSize * contentLineHeight) / 2 - token.lineWidth, 0),
        paddingBlockSM: Math.max((token.controlHeightSM - contentFontSizeSM * contentLineHeightSM) / 2 - token.lineWidth, 0),
        paddingBlockLG: Math.max((token.controlHeightLG - contentFontSizeLG * contentLineHeightLG) / 2 - token.lineWidth, 0)
      };
    };

    // ============================== Shared ==============================
    const genSharedButtonStyle = token => {
      const {
        componentCls,
        iconCls,
        fontWeight,
        opacityLoading,
        motionDurationSlow,
        motionEaseInOut,
        marginXS,
        calc
      } = token;
      return {
        [componentCls]: {
          outline: 'none',
          position: 'relative',
          display: 'inline-flex',
          gap: token.marginXS,
          alignItems: 'center',
          justifyContent: 'center',
          fontWeight,
          whiteSpace: 'nowrap',
          textAlign: 'center',
          backgroundImage: 'none',
          background: 'transparent',
          border: `${unit$1(token.lineWidth)} ${token.lineType} transparent`,
          cursor: 'pointer',
          transition: `all ${token.motionDurationMid} ${token.motionEaseInOut}`,
          userSelect: 'none',
          touchAction: 'manipulation',
          color: token.colorText,
          '&:disabled > *': {
            pointerEvents: 'none'
          },
          // https://github.com/ant-design/ant-design/issues/51380
          [`${componentCls}-icon > svg`]: resetIcon(),
          '> a': {
            color: 'currentColor'
          },
          '&:not(:disabled)': genFocusStyle(token),
          [`&${componentCls}-two-chinese-chars::first-letter`]: {
            letterSpacing: '0.34em'
          },
          [`&${componentCls}-two-chinese-chars > *:not(${iconCls})`]: {
            marginInlineEnd: '-0.34em',
            letterSpacing: '0.34em'
          },
          [`&${componentCls}-icon-only`]: {
            paddingInline: 0,
            // make `btn-icon-only` not too narrow
            [`&${componentCls}-compact-item`]: {
              flex: 'none'
            },
            [`&${componentCls}-round`]: {
              width: 'auto'
            }
          },
          // Loading
          [`&${componentCls}-loading`]: {
            opacity: opacityLoading,
            cursor: 'default'
          },
          [`${componentCls}-loading-icon`]: {
            transition: ['width', 'opacity', 'margin'].map(transition => `${transition} ${motionDurationSlow} ${motionEaseInOut}`).join(',')
          },
          // iconPosition
          [`&:not(${componentCls}-icon-end)`]: {
            [`${componentCls}-loading-icon-motion`]: {
              '&-appear-start, &-enter-start': {
                marginInlineEnd: calc(marginXS).mul(-1).equal()
              },
              '&-appear-active, &-enter-active': {
                marginInlineEnd: 0
              },
              '&-leave-start': {
                marginInlineEnd: 0
              },
              '&-leave-active': {
                marginInlineEnd: calc(marginXS).mul(-1).equal()
              }
            }
          },
          '&-icon-end': {
            flexDirection: 'row-reverse',
            [`${componentCls}-loading-icon-motion`]: {
              '&-appear-start, &-enter-start': {
                marginInlineStart: calc(marginXS).mul(-1).equal()
              },
              '&-appear-active, &-enter-active': {
                marginInlineStart: 0
              },
              '&-leave-start': {
                marginInlineStart: 0
              },
              '&-leave-active': {
                marginInlineStart: calc(marginXS).mul(-1).equal()
              }
            }
          }
        }
      };
    };
    const genHoverActiveButtonStyle = (btnCls, hoverStyle, activeStyle) => ({
      [`&:not(:disabled):not(${btnCls}-disabled)`]: {
        '&:hover': hoverStyle,
        '&:active': activeStyle
      }
    });
    // ============================== Shape ===============================
    const genCircleButtonStyle = token => ({
      minWidth: token.controlHeight,
      paddingInlineStart: 0,
      paddingInlineEnd: 0,
      borderRadius: '50%'
    });
    const genRoundButtonStyle = token => ({
      borderRadius: token.controlHeight,
      paddingInlineStart: token.calc(token.controlHeight).div(2).equal(),
      paddingInlineEnd: token.calc(token.controlHeight).div(2).equal()
    });
    const genDisabledStyle$1 = token => ({
      cursor: 'not-allowed',
      borderColor: token.borderColorDisabled,
      color: token.colorTextDisabled,
      background: token.colorBgContainerDisabled,
      boxShadow: 'none'
    });
    const genGhostButtonStyle = (btnCls, background, textColor, borderColor, textColorDisabled, borderColorDisabled, hoverStyle, activeStyle) => ({
      [`&${btnCls}-background-ghost`]: Object.assign(Object.assign({
        color: textColor || undefined,
        background,
        borderColor: borderColor || undefined,
        boxShadow: 'none'
      }, genHoverActiveButtonStyle(btnCls, Object.assign({
        background
      }, hoverStyle), Object.assign({
        background
      }, activeStyle))), {
        '&:disabled': {
          cursor: 'not-allowed',
          color: textColorDisabled || undefined,
          borderColor: borderColorDisabled || undefined
        }
      })
    });
    const genSolidDisabledButtonStyle = token => ({
      [`&:disabled, &${token.componentCls}-disabled`]: Object.assign({}, genDisabledStyle$1(token))
    });
    const genPureDisabledButtonStyle = token => ({
      [`&:disabled, &${token.componentCls}-disabled`]: {
        cursor: 'not-allowed',
        color: token.colorTextDisabled
      }
    });
    // ============================== Variant =============================
    const genVariantButtonStyle = (token, hoverStyle, activeStyle, variant) => {
      const isPureDisabled = variant && ['link', 'text'].includes(variant);
      const genDisabledButtonStyle = isPureDisabled ? genPureDisabledButtonStyle : genSolidDisabledButtonStyle;
      return Object.assign(Object.assign({}, genDisabledButtonStyle(token)), genHoverActiveButtonStyle(token.componentCls, hoverStyle, activeStyle));
    };
    const genSolidButtonStyle = (token, textColor, background, hoverStyle, activeStyle) => ({
      [`&${token.componentCls}-variant-solid`]: Object.assign({
        color: textColor,
        background
      }, genVariantButtonStyle(token, hoverStyle, activeStyle))
    });
    const genOutlinedDashedButtonStyle = (token, borderColor, background, hoverStyle, activeStyle) => ({
      [`&${token.componentCls}-variant-outlined, &${token.componentCls}-variant-dashed`]: Object.assign({
        borderColor,
        background
      }, genVariantButtonStyle(token, hoverStyle, activeStyle))
    });
    const genDashedButtonStyle = token => ({
      [`&${token.componentCls}-variant-dashed`]: {
        borderStyle: 'dashed'
      }
    });
    const genFilledButtonStyle = (token, background, hoverStyle, activeStyle) => ({
      [`&${token.componentCls}-variant-filled`]: Object.assign({
        boxShadow: 'none',
        background
      }, genVariantButtonStyle(token, hoverStyle, activeStyle))
    });
    const genTextLinkButtonStyle = (token, textColor, variant, hoverStyle, activeStyle) => ({
      [`&${token.componentCls}-variant-${variant}`]: Object.assign({
        color: textColor,
        boxShadow: 'none'
      }, genVariantButtonStyle(token, hoverStyle, activeStyle, variant))
    });
    // =============================== Color ==============================
    const genPresetColorStyle = token => {
      const {
        componentCls
      } = token;
      return PresetColors.reduce((prev, colorKey) => {
        const darkColor = token[`${colorKey}6`];
        const lightColor = token[`${colorKey}1`];
        const hoverColor = token[`${colorKey}5`];
        const lightHoverColor = token[`${colorKey}2`];
        const lightBorderColor = token[`${colorKey}3`];
        const activeColor = token[`${colorKey}7`];
        const boxShadow = `0 ${unit$1(token.controlOutlineWidth)} 0 ${token[`${colorKey}1`]}`;
        return Object.assign(Object.assign({}, prev), {
          [`&${componentCls}-color-${colorKey}`]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
            color: darkColor,
            boxShadow
          }, genSolidButtonStyle(token, token.colorTextLightSolid, darkColor, {
            background: hoverColor
          }, {
            background: activeColor
          })), genOutlinedDashedButtonStyle(token, darkColor, token.colorBgContainer, {
            color: hoverColor,
            borderColor: hoverColor,
            background: token.colorBgContainer
          }, {
            color: activeColor,
            borderColor: activeColor,
            background: token.colorBgContainer
          })), genDashedButtonStyle(token)), genFilledButtonStyle(token, lightColor, {
            background: lightHoverColor
          }, {
            background: lightBorderColor
          })), genTextLinkButtonStyle(token, darkColor, 'link', {
            color: hoverColor
          }, {
            color: activeColor
          })), genTextLinkButtonStyle(token, darkColor, 'text', {
            color: hoverColor,
            background: lightColor
          }, {
            color: activeColor,
            background: lightBorderColor
          }))
        });
      }, {});
    };
    const genDefaultButtonStyle = token => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token.defaultColor,
      boxShadow: token.defaultShadow
    }, genSolidButtonStyle(token, token.solidTextColor, token.colorBgSolid, {
      color: token.solidTextColor,
      background: token.colorBgSolidHover
    }, {
      color: token.solidTextColor,
      background: token.colorBgSolidActive
    })), genDashedButtonStyle(token)), genFilledButtonStyle(token, token.colorFillTertiary, {
      background: token.colorFillSecondary
    }, {
      background: token.colorFill
    })), genTextLinkButtonStyle(token, token.textTextColor, 'link', {
      color: token.colorLinkHover,
      background: token.linkHoverBg
    }, {
      color: token.colorLinkActive
    })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.defaultGhostColor, token.defaultGhostBorderColor, token.colorTextDisabled, token.colorBorder));
    const genPrimaryButtonStyle = token => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token.colorPrimary,
      boxShadow: token.primaryShadow
    }, genOutlinedDashedButtonStyle(token, token.colorPrimary, token.colorBgContainer, {
      color: token.colorPrimaryTextHover,
      borderColor: token.colorPrimaryHover,
      background: token.colorBgContainer
    }, {
      color: token.colorPrimaryTextActive,
      borderColor: token.colorPrimaryActive,
      background: token.colorBgContainer
    })), genDashedButtonStyle(token)), genFilledButtonStyle(token, token.colorPrimaryBg, {
      background: token.colorPrimaryBgHover
    }, {
      background: token.colorPrimaryBorder
    })), genTextLinkButtonStyle(token, token.colorLink, 'text', {
      color: token.colorPrimaryTextHover,
      background: token.colorPrimaryBg
    }, {
      color: token.colorPrimaryTextActive,
      background: token.colorPrimaryBorder
    })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.colorPrimary, token.colorPrimary, token.colorTextDisabled, token.colorBorder, {
      color: token.colorPrimaryHover,
      borderColor: token.colorPrimaryHover
    }, {
      color: token.colorPrimaryActive,
      borderColor: token.colorPrimaryActive
    }));
    const genDangerousStyle = token => Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
      color: token.colorError,
      boxShadow: token.dangerShadow
    }, genSolidButtonStyle(token, token.dangerColor, token.colorError, {
      background: token.colorErrorHover
    }, {
      background: token.colorErrorActive
    })), genOutlinedDashedButtonStyle(token, token.colorError, token.colorBgContainer, {
      color: token.colorErrorHover,
      borderColor: token.colorErrorBorderHover
    }, {
      color: token.colorErrorActive,
      borderColor: token.colorErrorActive
    })), genDashedButtonStyle(token)), genFilledButtonStyle(token, token.colorErrorBg, {
      background: token.colorErrorBgFilledHover
    }, {
      background: token.colorErrorBgActive
    })), genTextLinkButtonStyle(token, token.colorError, 'text', {
      color: token.colorErrorHover,
      background: token.colorErrorBg
    }, {
      color: token.colorErrorHover,
      background: token.colorErrorBgActive
    })), genTextLinkButtonStyle(token, token.colorError, 'link', {
      color: token.colorErrorHover
    }, {
      color: token.colorErrorActive
    })), genGhostButtonStyle(token.componentCls, token.ghostBg, token.colorError, token.colorError, token.colorTextDisabled, token.colorBorder, {
      color: token.colorErrorHover,
      borderColor: token.colorErrorHover
    }, {
      color: token.colorErrorActive,
      borderColor: token.colorErrorActive
    }));
    const genColorButtonStyle = token => {
      const {
        componentCls
      } = token;
      return Object.assign({
        [`${componentCls}-color-default`]: genDefaultButtonStyle(token),
        [`${componentCls}-color-primary`]: genPrimaryButtonStyle(token),
        [`${componentCls}-color-dangerous`]: genDangerousStyle(token)
      }, genPresetColorStyle(token));
    };
    // =========== Compatible with versions earlier than 5.21.0 ===========
    const genCompatibleButtonStyle = token => Object.assign(Object.assign(Object.assign(Object.assign({}, genOutlinedDashedButtonStyle(token, token.defaultBorderColor, token.defaultBg, {
      color: token.defaultHoverColor,
      borderColor: token.defaultHoverBorderColor,
      background: token.defaultHoverBg
    }, {
      color: token.defaultActiveColor,
      borderColor: token.defaultActiveBorderColor,
      background: token.defaultActiveBg
    })), genTextLinkButtonStyle(token, token.textTextColor, 'text', {
      color: token.textTextHoverColor,
      background: token.textHoverBg
    }, {
      color: token.textTextActiveColor,
      background: token.colorBgTextActive
    })), genSolidButtonStyle(token, token.primaryColor, token.colorPrimary, {
      background: token.colorPrimaryHover,
      color: token.primaryColor
    }, {
      background: token.colorPrimaryActive,
      color: token.primaryColor
    })), genTextLinkButtonStyle(token, token.colorLink, 'link', {
      color: token.colorLinkHover,
      background: token.linkHoverBg
    }, {
      color: token.colorLinkActive
    }));
    // =============================== Size ===============================
    const genButtonStyle = function (token) {
      let prefixCls = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
      const {
        componentCls,
        controlHeight,
        fontSize,
        borderRadius,
        buttonPaddingHorizontal,
        iconCls,
        buttonPaddingVertical,
        buttonIconOnlyFontSize
      } = token;
      return [{
        [prefixCls]: {
          fontSize,
          height: controlHeight,
          padding: `${unit$1(buttonPaddingVertical)} ${unit$1(buttonPaddingHorizontal)}`,
          borderRadius,
          [`&${componentCls}-icon-only`]: {
            width: controlHeight,
            [iconCls]: {
              fontSize: buttonIconOnlyFontSize
            }
          }
        }
      },
      // Shape - patch prefixCls again to override solid border radius style
      {
        [`${componentCls}${componentCls}-circle${prefixCls}`]: genCircleButtonStyle(token)
      }, {
        [`${componentCls}${componentCls}-round${prefixCls}`]: genRoundButtonStyle(token)
      }];
    };
    const genSizeBaseButtonStyle = token => {
      const baseToken = merge$1(token, {
        fontSize: token.contentFontSize
      });
      return genButtonStyle(baseToken, token.componentCls);
    };
    const genSizeSmallButtonStyle = token => {
      const smallToken = merge$1(token, {
        controlHeight: token.controlHeightSM,
        fontSize: token.contentFontSizeSM,
        padding: token.paddingXS,
        buttonPaddingHorizontal: token.paddingInlineSM,
        buttonPaddingVertical: 0,
        borderRadius: token.borderRadiusSM,
        buttonIconOnlyFontSize: token.onlyIconSizeSM
      });
      return genButtonStyle(smallToken, `${token.componentCls}-sm`);
    };
    const genSizeLargeButtonStyle = token => {
      const largeToken = merge$1(token, {
        controlHeight: token.controlHeightLG,
        fontSize: token.contentFontSizeLG,
        buttonPaddingHorizontal: token.paddingInlineLG,
        buttonPaddingVertical: 0,
        borderRadius: token.borderRadiusLG,
        buttonIconOnlyFontSize: token.onlyIconSizeLG
      });
      return genButtonStyle(largeToken, `${token.componentCls}-lg`);
    };
    const genBlockButtonStyle = token => {
      const {
        componentCls
      } = token;
      return {
        [componentCls]: {
          [`&${componentCls}-block`]: {
            width: '100%'
          }
        }
      };
    };
    // ============================== Export ==============================
    var useStyle$3 = genStyleHooks('Button', token => {
      const buttonToken = prepareToken(token);
      return [
      // Shared
      genSharedButtonStyle(buttonToken),
      // Size
      genSizeBaseButtonStyle(buttonToken), genSizeSmallButtonStyle(buttonToken), genSizeLargeButtonStyle(buttonToken),
      // Block
      genBlockButtonStyle(buttonToken),
      // Color
      genColorButtonStyle(buttonToken),
      // https://github.com/ant-design/ant-design/issues/50969
      genCompatibleButtonStyle(buttonToken),
      // Button Group
      genGroupStyle$1(buttonToken)];
    }, prepareComponentToken$1, {
      unitless: {
        fontWeight: true,
        contentLineHeight: true,
        contentLineHeightSM: true,
        contentLineHeightLG: true
      }
    });

    // handle border collapse
    function compactItemBorder(token, parentCls, options) {
      const {
        focusElCls,
        focus,
        borderElCls
      } = options;
      const childCombinator = borderElCls ? '> *' : '';
      const hoverEffects = ['hover', focus ? 'focus' : null, 'active'].filter(Boolean).map(n => `&:${n} ${childCombinator}`).join(',');
      return {
        [`&-item:not(${parentCls}-last-item)`]: {
          marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal()
        },
        '&-item': Object.assign(Object.assign({
          [hoverEffects]: {
            zIndex: 2
          }
        }, focusElCls ? {
          [`&${focusElCls}`]: {
            zIndex: 2
          }
        } : {}), {
          [`&[disabled] ${childCombinator}`]: {
            zIndex: 0
          }
        })
      };
    }
    // handle border-radius
    function compactItemBorderRadius(prefixCls, parentCls, options) {
      const {
        borderElCls
      } = options;
      const childCombinator = borderElCls ? `> ${borderElCls}` : '';
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item) ${childCombinator}`]: {
          borderRadius: 0
        },
        [`&-item:not(${parentCls}-last-item)${parentCls}-first-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`&-item:not(${parentCls}-first-item)${parentCls}-last-item`]: {
          [`& ${childCombinator}, &${prefixCls}-sm ${childCombinator}, &${prefixCls}-lg ${childCombinator}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        }
      };
    }
    function genCompactItemStyle(token) {
      let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        focus: true
      };
      const {
        componentCls
      } = token;
      const compactCls = `${componentCls}-compact`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemBorder(token, compactCls, options)), compactItemBorderRadius(componentCls, compactCls, options))
      };
    }

    function compactItemVerticalBorder(token, parentCls) {
      return {
        // border collapse
        [`&-item:not(${parentCls}-last-item)`]: {
          marginBottom: token.calc(token.lineWidth).mul(-1).equal()
        },
        '&-item': {
          '&:hover,&:focus,&:active': {
            zIndex: 2
          },
          '&[disabled]': {
            zIndex: 0
          }
        }
      };
    }
    function compactItemBorderVerticalRadius(prefixCls, parentCls) {
      return {
        [`&-item:not(${parentCls}-first-item):not(${parentCls}-last-item)`]: {
          borderRadius: 0
        },
        [`&-item${parentCls}-first-item:not(${parentCls}-last-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderEndEndRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&-item${parentCls}-last-item:not(${parentCls}-first-item)`]: {
          [`&, &${prefixCls}-sm, &${prefixCls}-lg`]: {
            borderStartStartRadius: 0,
            borderStartEndRadius: 0
          }
        }
      };
    }
    function genCompactItemVerticalStyle(token) {
      const compactCls = `${token.componentCls}-compact-vertical`;
      return {
        [compactCls]: Object.assign(Object.assign({}, compactItemVerticalBorder(token, compactCls)), compactItemBorderVerticalRadius(token.componentCls, compactCls))
      };
    }

    const genButtonCompactStyle = token => {
      const {
        componentCls,
        colorPrimaryHover,
        lineWidth,
        calc
      } = token;
      const insetOffset = calc(lineWidth).mul(-1).equal();
      const getCompactBorderStyle = vertical => ({
        [`${componentCls}-compact${vertical ? '-vertical' : ''}-item${componentCls}-primary:not([disabled])`]: {
          '& + &::before': {
            position: 'absolute',
            top: vertical ? insetOffset : 0,
            insetInlineStart: vertical ? 0 : insetOffset,
            backgroundColor: colorPrimaryHover,
            content: '""',
            width: vertical ? '100%' : lineWidth,
            height: vertical ? lineWidth : '100%'
          }
        }
      });
      // Special styles for Primary Button
      return Object.assign(Object.assign({}, getCompactBorderStyle()), getCompactBorderStyle(true));
    };
    // ============================== Export ==============================
    var Compact = genSubStyleComponent(['Button', 'compact'], token => {
      const buttonToken = prepareToken(token);
      return [
      // Space Compact
      genCompactItemStyle(buttonToken), genCompactItemVerticalStyle(buttonToken), genButtonCompactStyle(buttonToken)];
    }, prepareComponentToken$1);

    var __rest$7 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    function getLoadingConfig(loading) {
      if (typeof loading === 'object' && loading) {
        let delay = loading === null || loading === void 0 ? void 0 : loading.delay;
        delay = !Number.isNaN(delay) && typeof delay === 'number' ? delay : 0;
        return {
          loading: delay <= 0,
          delay
        };
      }
      return {
        loading: !!loading,
        delay: 0
      };
    }
    const ButtonTypeMap = {
      default: ['default', 'outlined'],
      primary: ['primary', 'solid'],
      dashed: ['default', 'dashed'],
      link: ['primary', 'link'],
      text: ['default', 'text']
    };
    const InternalCompoundedButton = /*#__PURE__*/React.forwardRef((props, ref) => {
      var _a, _b, _c, _d;
      const {
          loading = false,
          prefixCls: customizePrefixCls,
          color,
          variant,
          type,
          danger = false,
          shape = 'default',
          size: customizeSize,
          styles,
          disabled: customDisabled,
          className,
          rootClassName,
          children,
          icon,
          iconPosition = 'start',
          ghost = false,
          block = false,
          // React does not recognize the `htmlType` prop on a DOM element. Here we pick it out of `rest`.
          htmlType = 'button',
          classNames: customClassNames,
          style: customStyle = {},
          autoInsertSpace,
          autoFocus
        } = props,
        rest = __rest$7(props, ["loading", "prefixCls", "color", "variant", "type", "danger", "shape", "size", "styles", "disabled", "className", "rootClassName", "children", "icon", "iconPosition", "ghost", "block", "htmlType", "classNames", "style", "autoInsertSpace", "autoFocus"]);
      // https://github.com/ant-design/ant-design/issues/47605
      // Compatible with original `type` behavior
      const mergedType = type || 'default';
      const [mergedColor, mergedVariant] = reactExports.useMemo(() => {
        if (color && variant) {
          return [color, variant];
        }
        const colorVariantPair = ButtonTypeMap[mergedType] || [];
        if (danger) {
          return ['danger', colorVariantPair[1]];
        }
        return colorVariantPair;
      }, [type, color, variant, danger]);
      const isDanger = mergedColor === 'danger';
      const mergedColorText = isDanger ? 'dangerous' : mergedColor;
      const {
        getPrefixCls,
        direction,
        button
      } = reactExports.useContext(ConfigContext);
      const mergedInsertSpace = (_a = autoInsertSpace !== null && autoInsertSpace !== void 0 ? autoInsertSpace : button === null || button === void 0 ? void 0 : button.autoInsertSpace) !== null && _a !== void 0 ? _a : true;
      const prefixCls = getPrefixCls('btn', customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$3(prefixCls);
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const groupSize = reactExports.useContext(GroupSizeContext);
      const loadingOrDelay = reactExports.useMemo(() => getLoadingConfig(loading), [loading]);
      const [innerLoading, setLoading] = reactExports.useState(loadingOrDelay.loading);
      const [hasTwoCNChar, setHasTwoCNChar] = reactExports.useState(false);
      const buttonRef = reactExports.useRef(null);
      const mergedRef = useComposeRef(ref, buttonRef);
      const needInserted = reactExports.Children.count(children) === 1 && !icon && !isUnBorderedButtonVariant(mergedVariant);
      // ========================= Mount ==========================
      // Record for mount status.
      // This will help to no to show the animation of loading on the first mount.
      const isMountRef = reactExports.useRef(true);
      React.useEffect(() => {
        isMountRef.current = false;
        return () => {
          isMountRef.current = true;
        };
      }, []);
      // ========================= Effect =========================
      // Loading
      reactExports.useEffect(() => {
        let delayTimer = null;
        if (loadingOrDelay.delay > 0) {
          delayTimer = setTimeout(() => {
            delayTimer = null;
            setLoading(true);
          }, loadingOrDelay.delay);
        } else {
          setLoading(loadingOrDelay.loading);
        }
        function cleanupTimer() {
          if (delayTimer) {
            clearTimeout(delayTimer);
            delayTimer = null;
          }
        }
        return cleanupTimer;
      }, [loadingOrDelay]);
      // Two chinese characters check
      reactExports.useEffect(() => {
        // FIXME: for HOC usage like <FormatMessage />
        if (!buttonRef.current || !mergedInsertSpace) {
          return;
        }
        const buttonText = buttonRef.current.textContent || '';
        if (needInserted && isTwoCNChar(buttonText)) {
          if (!hasTwoCNChar) {
            setHasTwoCNChar(true);
          }
        } else if (hasTwoCNChar) {
          setHasTwoCNChar(false);
        }
      });
      // Auto focus
      reactExports.useEffect(() => {
        if (autoFocus && buttonRef.current) {
          buttonRef.current.focus();
        }
      }, []);
      // ========================= Events =========================
      const handleClick = React.useCallback(e => {
        var _a;
        // FIXME: https://github.com/ant-design/ant-design/issues/30207
        if (innerLoading || mergedDisabled) {
          e.preventDefault();
          return;
        }
        (_a = props.onClick) === null || _a === void 0 ? void 0 : _a.call(props, e);
      }, [props.onClick, innerLoading, mergedDisabled]);
      // ========================== Size ==========================
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      const sizeClassNameMap = {
        large: 'lg',
        small: 'sm',
        middle: undefined
      };
      const sizeFullName = useSize(ctxSize => {
        var _a, _b;
        return (_b = (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : groupSize) !== null && _b !== void 0 ? _b : ctxSize;
      });
      const sizeCls = sizeFullName ? (_b = sizeClassNameMap[sizeFullName]) !== null && _b !== void 0 ? _b : '' : '';
      const iconType = innerLoading ? 'loading' : icon;
      const linkButtonRestProps = omit(rest, ['navigate']);
      // ========================= Render =========================
      const classes = classNames(prefixCls, hashId, cssVarCls, {
        [`${prefixCls}-${shape}`]: shape !== 'default' && shape,
        // line(253 - 254): Compatible with versions earlier than 5.21.0
        [`${prefixCls}-${mergedType}`]: mergedType,
        [`${prefixCls}-dangerous`]: danger,
        [`${prefixCls}-color-${mergedColorText}`]: mergedColorText,
        [`${prefixCls}-variant-${mergedVariant}`]: mergedVariant,
        [`${prefixCls}-${sizeCls}`]: sizeCls,
        [`${prefixCls}-icon-only`]: !children && children !== 0 && !!iconType,
        [`${prefixCls}-background-ghost`]: ghost && !isUnBorderedButtonVariant(mergedVariant),
        [`${prefixCls}-loading`]: innerLoading,
        [`${prefixCls}-two-chinese-chars`]: hasTwoCNChar && mergedInsertSpace && !innerLoading,
        [`${prefixCls}-block`]: block,
        [`${prefixCls}-rtl`]: direction === 'rtl',
        [`${prefixCls}-icon-end`]: iconPosition === 'end'
      }, compactItemClassnames, className, rootClassName, button === null || button === void 0 ? void 0 : button.className);
      const fullStyle = Object.assign(Object.assign({}, button === null || button === void 0 ? void 0 : button.style), customStyle);
      const iconClasses = classNames(customClassNames === null || customClassNames === void 0 ? void 0 : customClassNames.icon, (_c = button === null || button === void 0 ? void 0 : button.classNames) === null || _c === void 0 ? void 0 : _c.icon);
      const iconStyle = Object.assign(Object.assign({}, (styles === null || styles === void 0 ? void 0 : styles.icon) || {}), ((_d = button === null || button === void 0 ? void 0 : button.styles) === null || _d === void 0 ? void 0 : _d.icon) || {});
      const iconNode = icon && !innerLoading ? (/*#__PURE__*/React.createElement(IconWrapper, {
        prefixCls: prefixCls,
        className: iconClasses,
        style: iconStyle
      }, icon)) : typeof loading === 'object' && loading.icon ? (/*#__PURE__*/React.createElement(IconWrapper, {
        prefixCls: prefixCls,
        className: iconClasses,
        style: iconStyle
      }, loading.icon)) : (/*#__PURE__*/React.createElement(DefaultLoadingIcon, {
        existIcon: !!icon,
        prefixCls: prefixCls,
        loading: innerLoading,
        mount: isMountRef.current
      }));
      const kids = children || children === 0 ? spaceChildren(children, needInserted && mergedInsertSpace) : null;
      if (linkButtonRestProps.href !== undefined) {
        return wrapCSSVar(/*#__PURE__*/React.createElement("a", Object.assign({}, linkButtonRestProps, {
          className: classNames(classes, {
            [`${prefixCls}-disabled`]: mergedDisabled
          }),
          href: mergedDisabled ? undefined : linkButtonRestProps.href,
          style: fullStyle,
          onClick: handleClick,
          ref: mergedRef,
          tabIndex: mergedDisabled ? -1 : 0
        }), iconNode, kids));
      }
      let buttonNode = /*#__PURE__*/React.createElement("button", Object.assign({}, rest, {
        type: htmlType,
        className: classes,
        style: fullStyle,
        onClick: handleClick,
        disabled: mergedDisabled,
        ref: mergedRef
      }), iconNode, kids, compactItemClassnames && /*#__PURE__*/React.createElement(Compact, {
        prefixCls: prefixCls
      }));
      if (!isUnBorderedButtonVariant(mergedVariant)) {
        buttonNode = /*#__PURE__*/React.createElement(Wave, {
          component: "Button",
          disabled: innerLoading
        }, buttonNode);
      }
      return wrapCSSVar(buttonNode);
    });
    const Button = InternalCompoundedButton;
    Button.Group = ButtonGroup;
    Button.__ANT_BUTTON = true;

    var HOOK_MARK = 'RC_FORM_INTERNAL_HOOKS';

    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    var warningFunc = function warningFunc() {
      warningOnce(false, 'Can not find FormContext. Please make sure you wrap Field under Form.');
    };
    var Context = /*#__PURE__*/reactExports.createContext({
      getFieldValue: warningFunc,
      getFieldsValue: warningFunc,
      getFieldError: warningFunc,
      getFieldWarning: warningFunc,
      getFieldsError: warningFunc,
      isFieldsTouched: warningFunc,
      isFieldTouched: warningFunc,
      isFieldValidating: warningFunc,
      isFieldsValidating: warningFunc,
      resetFields: warningFunc,
      setFields: warningFunc,
      setFieldValue: warningFunc,
      setFieldsValue: warningFunc,
      validateFields: warningFunc,
      submit: warningFunc,
      getInternalHooks: function getInternalHooks() {
        warningFunc();
        return {
          dispatch: warningFunc,
          initEntityValue: warningFunc,
          registerField: warningFunc,
          useSubscribe: warningFunc,
          setInitialValues: warningFunc,
          destroyForm: warningFunc,
          setCallbacks: warningFunc,
          registerWatch: warningFunc,
          getFields: warningFunc,
          setValidateMessages: warningFunc,
          setPreserve: warningFunc,
          getInitialValue: warningFunc
        };
      }
    });

    var ListContext = /*#__PURE__*/reactExports.createContext(null);

    function toArray$1(value) {
      if (value === undefined || value === null) {
        return [];
      }
      return Array.isArray(value) ? value : [value];
    }
    function isFormInstance(form) {
      return form && !!form._init;
    }

    function newMessages() {
      return {
        default: 'Validation error on field %s',
        required: '%s is required',
        enum: '%s must be one of %s',
        whitespace: '%s cannot be empty',
        date: {
          format: '%s date %s is invalid for format %s',
          parse: '%s date could not be parsed, %s is invalid ',
          invalid: '%s date %s is invalid'
        },
        types: {
          string: '%s is not a %s',
          method: '%s is not a %s (function)',
          array: '%s is not an %s',
          object: '%s is not an %s',
          number: '%s is not a %s',
          date: '%s is not a %s',
          boolean: '%s is not a %s',
          integer: '%s is not an %s',
          float: '%s is not a %s',
          regexp: '%s is not a valid %s',
          email: '%s is not a valid %s',
          url: '%s is not a valid %s',
          hex: '%s is not a valid %s'
        },
        string: {
          len: '%s must be exactly %s characters',
          min: '%s must be at least %s characters',
          max: '%s cannot be longer than %s characters',
          range: '%s must be between %s and %s characters'
        },
        number: {
          len: '%s must equal %s',
          min: '%s cannot be less than %s',
          max: '%s cannot be greater than %s',
          range: '%s must be between %s and %s'
        },
        array: {
          len: '%s must be exactly %s in length',
          min: '%s cannot be less than %s in length',
          max: '%s cannot be greater than %s in length',
          range: '%s must be between %s and %s in length'
        },
        pattern: {
          mismatch: '%s value %s does not match pattern %s'
        },
        clone: function clone() {
          var cloned = JSON.parse(JSON.stringify(this));
          cloned.clone = this.clone;
          return cloned;
        }
      };
    }
    var messages = newMessages();

    function _isNativeFunction(t) {
      try {
        return -1 !== Function.toString.call(t).indexOf("[native code]");
      } catch (n) {
        return "function" == typeof t;
      }
    }

    function _construct(t, e, r) {
      if (_isNativeReflectConstruct()) return Reflect.construct.apply(null, arguments);
      var o = [null];
      o.push.apply(o, e);
      var p = new (t.bind.apply(t, o))();
      return r && _setPrototypeOf(p, r.prototype), p;
    }

    function _wrapNativeSuper(t) {
      var r = "function" == typeof Map ? new Map() : void 0;
      return _wrapNativeSuper = function _wrapNativeSuper(t) {
        if (null === t || !_isNativeFunction(t)) return t;
        if ("function" != typeof t) throw new TypeError("Super expression must either be null or a function");
        if (void 0 !== r) {
          if (r.has(t)) return r.get(t);
          r.set(t, Wrapper);
        }
        function Wrapper() {
          return _construct(t, arguments, _getPrototypeOf(this).constructor);
        }
        return Wrapper.prototype = Object.create(t.prototype, {
          constructor: {
            value: Wrapper,
            enumerable: false,
            writable: true,
            configurable: true
          }
        }), _setPrototypeOf(Wrapper, t);
      }, _wrapNativeSuper(t);
    }

    /* eslint no-console:0 */

    var formatRegExp = /%[sdj%]/g;
    var warning = function warning() {};

    // don't print warning message when in production env or node runtime
    if (typeof process !== 'undefined' && process.env && "production" !== 'production') ;
    function convertFieldsError(errors) {
      if (!errors || !errors.length) return null;
      var fields = {};
      errors.forEach(function (error) {
        var field = error.field;
        fields[field] = fields[field] || [];
        fields[field].push(error);
      });
      return fields;
    }
    function format(template) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      var i = 0;
      var len = args.length;
      if (typeof template === 'function') {
        // eslint-disable-next-line prefer-spread
        return template.apply(null, args);
      }
      if (typeof template === 'string') {
        var str = template.replace(formatRegExp, function (x) {
          if (x === '%%') {
            return '%';
          }
          if (i >= len) {
            return x;
          }
          switch (x) {
            case '%s':
              return String(args[i++]);
            case '%d':
              return Number(args[i++]);
            case '%j':
              try {
                return JSON.stringify(args[i++]);
              } catch (_) {
                return '[Circular]';
              }
              break;
            default:
              return x;
          }
        });
        return str;
      }
      return template;
    }
    function isNativeStringType(type) {
      return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
    }
    function isEmptyValue(value, type) {
      if (value === undefined || value === null) {
        return true;
      }
      if (type === 'array' && Array.isArray(value) && !value.length) {
        return true;
      }
      if (isNativeStringType(type) && typeof value === 'string' && !value) {
        return true;
      }
      return false;
    }
    function asyncParallelArray(arr, func, callback) {
      var results = [];
      var total = 0;
      var arrLength = arr.length;
      function count(errors) {
        results.push.apply(results, _toConsumableArray(errors || []));
        total++;
        if (total === arrLength) {
          callback(results);
        }
      }
      arr.forEach(function (a) {
        func(a, count);
      });
    }
    function asyncSerialArray(arr, func, callback) {
      var index = 0;
      var arrLength = arr.length;
      function next(errors) {
        if (errors && errors.length) {
          callback(errors);
          return;
        }
        var original = index;
        index = index + 1;
        if (original < arrLength) {
          func(arr[original], next);
        } else {
          callback([]);
        }
      }
      next([]);
    }
    function flattenObjArr(objArr) {
      var ret = [];
      Object.keys(objArr).forEach(function (k) {
        ret.push.apply(ret, _toConsumableArray(objArr[k] || []));
      });
      return ret;
    }
    var AsyncValidationError = /*#__PURE__*/function (_Error) {
      _inherits(AsyncValidationError, _Error);
      var _super = _createSuper(AsyncValidationError);
      function AsyncValidationError(errors, fields) {
        var _this;
        _classCallCheck(this, AsyncValidationError);
        _this = _super.call(this, 'Async Validation Error');
        _defineProperty(_assertThisInitialized(_this), "errors", void 0);
        _defineProperty(_assertThisInitialized(_this), "fields", void 0);
        _this.errors = errors;
        _this.fields = fields;
        return _this;
      }
      return _createClass(AsyncValidationError);
    }( /*#__PURE__*/_wrapNativeSuper(Error));
    function asyncMap(objArr, option, func, callback, source) {
      if (option.first) {
        var _pending = new Promise(function (resolve, reject) {
          var next = function next(errors) {
            callback(errors);
            return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve(source);
          };
          var flattenArr = flattenObjArr(objArr);
          asyncSerialArray(flattenArr, func, next);
        });
        _pending.catch(function (e) {
          return e;
        });
        return _pending;
      }
      var firstFields = option.firstFields === true ? Object.keys(objArr) : option.firstFields || [];
      var objArrKeys = Object.keys(objArr);
      var objArrLength = objArrKeys.length;
      var total = 0;
      var results = [];
      var pending = new Promise(function (resolve, reject) {
        var next = function next(errors) {
          // eslint-disable-next-line prefer-spread
          results.push.apply(results, errors);
          total++;
          if (total === objArrLength) {
            callback(results);
            return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve(source);
          }
        };
        if (!objArrKeys.length) {
          callback(results);
          resolve(source);
        }
        objArrKeys.forEach(function (key) {
          var arr = objArr[key];
          if (firstFields.indexOf(key) !== -1) {
            asyncSerialArray(arr, func, next);
          } else {
            asyncParallelArray(arr, func, next);
          }
        });
      });
      pending.catch(function (e) {
        return e;
      });
      return pending;
    }
    function isErrorObj(obj) {
      return !!(obj && obj.message !== undefined);
    }
    function getValue(value, path) {
      var v = value;
      for (var i = 0; i < path.length; i++) {
        if (v == undefined) {
          return v;
        }
        v = v[path[i]];
      }
      return v;
    }
    function complementError(rule, source) {
      return function (oe) {
        var fieldValue;
        if (rule.fullFields) {
          fieldValue = getValue(source, rule.fullFields);
        } else {
          fieldValue = source[oe.field || rule.fullField];
        }
        if (isErrorObj(oe)) {
          oe.field = oe.field || rule.fullField;
          oe.fieldValue = fieldValue;
          return oe;
        }
        return {
          message: typeof oe === 'function' ? oe() : oe,
          fieldValue: fieldValue,
          field: oe.field || rule.fullField
        };
      };
    }
    function deepMerge(target, source) {
      if (source) {
        for (var s in source) {
          if (source.hasOwnProperty(s)) {
            var value = source[s];
            if (_typeof(value) === 'object' && _typeof(target[s]) === 'object') {
              target[s] = _objectSpread2(_objectSpread2({}, target[s]), value);
            } else {
              target[s] = value;
            }
          }
        }
      }
      return target;
    }

    var ENUM$1 = 'enum';
    var enumerable$1 = function enumerable(rule, value, source, errors, options) {
      rule[ENUM$1] = Array.isArray(rule[ENUM$1]) ? rule[ENUM$1] : [];
      if (rule[ENUM$1].indexOf(value) === -1) {
        errors.push(format(options.messages[ENUM$1], rule.fullField, rule[ENUM$1].join(', ')));
      }
    };

    var pattern$2 = function pattern(rule, value, source, errors, options) {
      if (rule.pattern) {
        if (rule.pattern instanceof RegExp) {
          // if a RegExp instance is passed, reset `lastIndex` in case its `global`
          // flag is accidentally set to `true`, which in a validation scenario
          // is not necessary and the result might be misleading
          rule.pattern.lastIndex = 0;
          if (!rule.pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        } else if (typeof rule.pattern === 'string') {
          var _pattern = new RegExp(rule.pattern);
          if (!_pattern.test(value)) {
            errors.push(format(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
          }
        }
      }
    };

    var range = function range(rule, value, source, errors, options) {
      var len = typeof rule.len === 'number';
      var min = typeof rule.min === 'number';
      var max = typeof rule.max === 'number';
      // U+010000U+10FFFFSupplementary Plane
      var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
      var val = value;
      var key = null;
      var num = typeof value === 'number';
      var str = typeof value === 'string';
      var arr = Array.isArray(value);
      if (num) {
        key = 'number';
      } else if (str) {
        key = 'string';
      } else if (arr) {
        key = 'array';
      }
      // if the value is not of a supported type for range validation
      // the validation rule rule should use the
      // type property to also test for a particular type
      if (!key) {
        return false;
      }
      if (arr) {
        val = value.length;
      }
      if (str) {
        // U+010000lengthbug"".length !== 3
        val = value.replace(spRegexp, '_').length;
      }
      if (len) {
        if (val !== rule.len) {
          errors.push(format(options.messages[key].len, rule.fullField, rule.len));
        }
      } else if (min && !max && val < rule.min) {
        errors.push(format(options.messages[key].min, rule.fullField, rule.min));
      } else if (max && !min && val > rule.max) {
        errors.push(format(options.messages[key].max, rule.fullField, rule.max));
      } else if (min && max && (val < rule.min || val > rule.max)) {
        errors.push(format(options.messages[key].range, rule.fullField, rule.min, rule.max));
      }
    };

    var required$1 = function required(rule, value, source, errors, options, type) {
      if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
        errors.push(format(options.messages.required, rule.fullField));
      }
    };

    // https://github.com/kevva/url-regex/blob/master/index.js
    var urlReg;
    var getUrlRegex = (function () {
      if (urlReg) {
        return urlReg;
      }
      var word = '[a-fA-F\\d:]';
      var b = function b(options) {
        return options && options.includeBoundaries ? "(?:(?<=\\s|^)(?=".concat(word, ")|(?<=").concat(word, ")(?=\\s|$))") : '';
      };
      var v4 = '(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}';
      var v6seg = '[a-fA-F\\d]{1,4}';
      var v6List = ["(?:".concat(v6seg, ":){7}(?:").concat(v6seg, "|:)"), // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
      "(?:".concat(v6seg, ":){6}(?:").concat(v4, "|:").concat(v6seg, "|:)"), // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::
      "(?:".concat(v6seg, ":){5}(?::").concat(v4, "|(?::").concat(v6seg, "){1,2}|:)"), // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::
      "(?:".concat(v6seg, ":){4}(?:(?::").concat(v6seg, "){0,1}:").concat(v4, "|(?::").concat(v6seg, "){1,3}|:)"), // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::
      "(?:".concat(v6seg, ":){3}(?:(?::").concat(v6seg, "){0,2}:").concat(v4, "|(?::").concat(v6seg, "){1,4}|:)"), // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::
      "(?:".concat(v6seg, ":){2}(?:(?::").concat(v6seg, "){0,3}:").concat(v4, "|(?::").concat(v6seg, "){1,5}|:)"), // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::
      "(?:".concat(v6seg, ":){1}(?:(?::").concat(v6seg, "){0,4}:").concat(v4, "|(?::").concat(v6seg, "){1,6}|:)"), // 1::              1::3:4:5:6:7:8   1::8            1::
      "(?::(?:(?::".concat(v6seg, "){0,5}:").concat(v4, "|(?::").concat(v6seg, "){1,7}|:))") // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::
      ];
      var v6Eth0 = "(?:%[0-9a-zA-Z]{1,})?"; // %eth0            %1

      var v6 = "(?:".concat(v6List.join('|'), ")").concat(v6Eth0);

      // Pre-compile only the exact regexes because adding a global flag make regexes stateful
      var v46Exact = new RegExp("(?:^".concat(v4, "$)|(?:^").concat(v6, "$)"));
      var v4exact = new RegExp("^".concat(v4, "$"));
      var v6exact = new RegExp("^".concat(v6, "$"));
      var ip = function ip(options) {
        return options && options.exact ? v46Exact : new RegExp("(?:".concat(b(options)).concat(v4).concat(b(options), ")|(?:").concat(b(options)).concat(v6).concat(b(options), ")"), 'g');
      };
      ip.v4 = function (options) {
        return options && options.exact ? v4exact : new RegExp("".concat(b(options)).concat(v4).concat(b(options)), 'g');
      };
      ip.v6 = function (options) {
        return options && options.exact ? v6exact : new RegExp("".concat(b(options)).concat(v6).concat(b(options)), 'g');
      };
      var protocol = "(?:(?:[a-z]+:)?//)";
      var auth = '(?:\\S+(?::\\S*)?@)?';
      var ipv4 = ip.v4().source;
      var ipv6 = ip.v6().source;
      var host = "(?:(?:[a-z\\u00a1-\\uffff0-9][-_]*)*[a-z\\u00a1-\\uffff0-9]+)";
      var domain = "(?:\\.(?:[a-z\\u00a1-\\uffff0-9]-*)*[a-z\\u00a1-\\uffff0-9]+)*";
      var tld = "(?:\\.(?:[a-z\\u00a1-\\uffff]{2,}))";
      var port = '(?::\\d{2,5})?';
      var path = '(?:[/?#][^\\s"]*)?';
      var regex = "(?:".concat(protocol, "|www\\.)").concat(auth, "(?:localhost|").concat(ipv4, "|").concat(ipv6, "|").concat(host).concat(domain).concat(tld, ")").concat(port).concat(path);
      urlReg = new RegExp("(?:^".concat(regex, "$)"), 'i');
      return urlReg;
    });

    /* eslint max-len:0 */

    var pattern$1 = {
      // http://emailregex.com/
      email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+\.)+[a-zA-Z\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]{2,}))$/,
      // url: new RegExp(
      //   '^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$',
      //   'i',
      // ),
      hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
    };
    var types = {
      integer: function integer(value) {
        return types.number(value) && parseInt(value, 10) === value;
      },
      float: function float(value) {
        return types.number(value) && !types.integer(value);
      },
      array: function array(value) {
        return Array.isArray(value);
      },
      regexp: function regexp(value) {
        if (value instanceof RegExp) {
          return true;
        }
        try {
          return !!new RegExp(value);
        } catch (e) {
          return false;
        }
      },
      date: function date(value) {
        return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
      },
      number: function number(value) {
        if (isNaN(value)) {
          return false;
        }
        return typeof value === 'number';
      },
      object: function object(value) {
        return _typeof(value) === 'object' && !types.array(value);
      },
      method: function method(value) {
        return typeof value === 'function';
      },
      email: function email(value) {
        return typeof value === 'string' && value.length <= 320 && !!value.match(pattern$1.email);
      },
      url: function url(value) {
        return typeof value === 'string' && value.length <= 2048 && !!value.match(getUrlRegex());
      },
      hex: function hex(value) {
        return typeof value === 'string' && !!value.match(pattern$1.hex);
      }
    };
    var type$1 = function type(rule, value, source, errors, options) {
      if (rule.required && value === undefined) {
        required$1(rule, value, source, errors, options);
        return;
      }
      var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
      var ruleType = rule.type;
      if (custom.indexOf(ruleType) > -1) {
        if (!types[ruleType](value)) {
          errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
        }
        // straight typeof check
      } else if (ruleType && _typeof(value) !== rule.type) {
        errors.push(format(options.messages.types[ruleType], rule.fullField, rule.type));
      }
    };

    /**
     *  Rule for validating whitespace.
     *
     *  @param rule The validation rule.
     *  @param value The value of the field on the source object.
     *  @param source The source object being validated.
     *  @param errors An array of errors that this rule may add
     *  validation errors to.
     *  @param options The validation options.
     *  @param options.messages The validation messages.
     */
    var whitespace = function whitespace(rule, value, source, errors, options) {
      if (/^\s+$/.test(value) || value === '') {
        errors.push(format(options.messages.whitespace, rule.fullField));
      }
    };

    var rules = {
      required: required$1,
      whitespace: whitespace,
      type: type$1,
      range: range,
      enum: enumerable$1,
      pattern: pattern$2
    };

    var any = function any(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
      }
      callback(errors);
    };

    var array = function array(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if ((value === undefined || value === null) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, 'array');
        if (value !== undefined && value !== null) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var boolean = function boolean(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var date = function date(rule, value, callback, source, options) {
      // console.log('integer rule called %j', rule);
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      // console.log('validate on %s value', value);
      if (validate) {
        if (isEmptyValue(value, 'date') && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, 'date')) {
          var dateObject;
          if (value instanceof Date) {
            dateObject = value;
          } else {
            dateObject = new Date(value);
          }
          rules.type(rule, dateObject, source, errors, options);
          if (dateObject) {
            rules.range(rule, dateObject.getTime(), source, errors, options);
          }
        }
      }
      callback(errors);
    };

    var ENUM = 'enum';
    var enumerable = function enumerable(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules[ENUM](rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var floatFn = function floatFn(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var integer = function integer(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var method = function method(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var number = function number(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (value === '') {
          // eslint-disable-next-line no-param-reassign
          value = undefined;
        }
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var object = function object(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (value !== undefined) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var pattern = function pattern(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, 'string') && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value, 'string')) {
          rules.pattern(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var regexp = function regexp(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options);
        if (!isEmptyValue(value)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var required = function required(rule, value, callback, source, options) {
      var errors = [];
      var type = Array.isArray(value) ? 'array' : _typeof(value);
      rules.required(rule, value, source, errors, options, type);
      callback(errors);
    };

    var string = function string(rule, value, callback, source, options) {
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, 'string') && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, 'string');
        if (!isEmptyValue(value, 'string')) {
          rules.type(rule, value, source, errors, options);
          rules.range(rule, value, source, errors, options);
          rules.pattern(rule, value, source, errors, options);
          if (rule.whitespace === true) {
            rules.whitespace(rule, value, source, errors, options);
          }
        }
      }
      callback(errors);
    };

    var type = function type(rule, value, callback, source, options) {
      var ruleType = rule.type;
      var errors = [];
      var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);
      if (validate) {
        if (isEmptyValue(value, ruleType) && !rule.required) {
          return callback();
        }
        rules.required(rule, value, source, errors, options, ruleType);
        if (!isEmptyValue(value, ruleType)) {
          rules.type(rule, value, source, errors, options);
        }
      }
      callback(errors);
    };

    var validators$2 = {
      string: string,
      method: method,
      number: number,
      boolean: boolean,
      regexp: regexp,
      integer: integer,
      float: floatFn,
      array: array,
      object: object,
      enum: enumerable,
      pattern: pattern,
      date: date,
      url: type,
      hex: type,
      email: type,
      required: required,
      any: any
    };

    /**
     *  Encapsulates a validation schema.
     *
     *  @param descriptor An object declaring validation rules
     *  for this schema.
     */
    var Schema = /*#__PURE__*/function () {
      function Schema(descriptor) {
        _classCallCheck(this, Schema);
        // ======================== Instance ========================
        _defineProperty(this, "rules", null);
        _defineProperty(this, "_messages", messages);
        this.define(descriptor);
      }
      _createClass(Schema, [{
        key: "define",
        value: function define(rules) {
          var _this = this;
          if (!rules) {
            throw new Error('Cannot configure a schema with no rules');
          }
          if (_typeof(rules) !== 'object' || Array.isArray(rules)) {
            throw new Error('Rules must be an object');
          }
          this.rules = {};
          Object.keys(rules).forEach(function (name) {
            var item = rules[name];
            _this.rules[name] = Array.isArray(item) ? item : [item];
          });
        }
      }, {
        key: "messages",
        value: function messages(_messages) {
          if (_messages) {
            this._messages = deepMerge(newMessages(), _messages);
          }
          return this._messages;
        }
      }, {
        key: "validate",
        value: function validate(source_) {
          var _this2 = this;
          var o = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
          var oc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : function () {};
          var source = source_;
          var options = o;
          var callback = oc;
          if (typeof options === 'function') {
            callback = options;
            options = {};
          }
          if (!this.rules || Object.keys(this.rules).length === 0) {
            if (callback) {
              callback(null, source);
            }
            return Promise.resolve(source);
          }
          function complete(results) {
            var errors = [];
            var fields = {};
            function add(e) {
              if (Array.isArray(e)) {
                var _errors;
                errors = (_errors = errors).concat.apply(_errors, _toConsumableArray(e));
              } else {
                errors.push(e);
              }
            }
            for (var i = 0; i < results.length; i++) {
              add(results[i]);
            }
            if (!errors.length) {
              callback(null, source);
            } else {
              fields = convertFieldsError(errors);
              callback(errors, fields);
            }
          }
          if (options.messages) {
            var messages$1 = this.messages();
            if (messages$1 === messages) {
              messages$1 = newMessages();
            }
            deepMerge(messages$1, options.messages);
            options.messages = messages$1;
          } else {
            options.messages = this.messages();
          }
          var series = {};
          var keys = options.keys || Object.keys(this.rules);
          keys.forEach(function (z) {
            var arr = _this2.rules[z];
            var value = source[z];
            arr.forEach(function (r) {
              var rule = r;
              if (typeof rule.transform === 'function') {
                if (source === source_) {
                  source = _objectSpread2({}, source);
                }
                value = source[z] = rule.transform(value);
                if (value !== undefined && value !== null) {
                  rule.type = rule.type || (Array.isArray(value) ? 'array' : _typeof(value));
                }
              }
              if (typeof rule === 'function') {
                rule = {
                  validator: rule
                };
              } else {
                rule = _objectSpread2({}, rule);
              }

              // Fill validator. Skip if nothing need to validate
              rule.validator = _this2.getValidationMethod(rule);
              if (!rule.validator) {
                return;
              }
              rule.field = z;
              rule.fullField = rule.fullField || z;
              rule.type = _this2.getType(rule);
              series[z] = series[z] || [];
              series[z].push({
                rule: rule,
                value: value,
                source: source,
                field: z
              });
            });
          });
          var errorFields = {};
          return asyncMap(series, options, function (data, doIt) {
            var rule = data.rule;
            var deep = (rule.type === 'object' || rule.type === 'array') && (_typeof(rule.fields) === 'object' || _typeof(rule.defaultField) === 'object');
            deep = deep && (rule.required || !rule.required && data.value);
            rule.field = data.field;
            function addFullField(key, schema) {
              return _objectSpread2(_objectSpread2({}, schema), {}, {
                fullField: "".concat(rule.fullField, ".").concat(key),
                fullFields: rule.fullFields ? [].concat(_toConsumableArray(rule.fullFields), [key]) : [key]
              });
            }
            function cb() {
              var e = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
              var errorList = Array.isArray(e) ? e : [e];
              if (!options.suppressWarning && errorList.length) {
                Schema.warning('async-validator:', errorList);
              }
              if (errorList.length && rule.message !== undefined) {
                errorList = [].concat(rule.message);
              }

              // Fill error info
              var filledErrors = errorList.map(complementError(rule, source));
              if (options.first && filledErrors.length) {
                errorFields[rule.field] = 1;
                return doIt(filledErrors);
              }
              if (!deep) {
                doIt(filledErrors);
              } else {
                // if rule is required but the target object
                // does not exist fail at the rule level and don't
                // go deeper
                if (rule.required && !data.value) {
                  if (rule.message !== undefined) {
                    filledErrors = [].concat(rule.message).map(complementError(rule, source));
                  } else if (options.error) {
                    filledErrors = [options.error(rule, format(options.messages.required, rule.field))];
                  }
                  return doIt(filledErrors);
                }
                var fieldsSchema = {};
                if (rule.defaultField) {
                  Object.keys(data.value).map(function (key) {
                    fieldsSchema[key] = rule.defaultField;
                  });
                }
                fieldsSchema = _objectSpread2(_objectSpread2({}, fieldsSchema), data.rule.fields);
                var paredFieldsSchema = {};
                Object.keys(fieldsSchema).forEach(function (field) {
                  var fieldSchema = fieldsSchema[field];
                  var fieldSchemaList = Array.isArray(fieldSchema) ? fieldSchema : [fieldSchema];
                  paredFieldsSchema[field] = fieldSchemaList.map(addFullField.bind(null, field));
                });
                var schema = new Schema(paredFieldsSchema);
                schema.messages(options.messages);
                if (data.rule.options) {
                  data.rule.options.messages = options.messages;
                  data.rule.options.error = options.error;
                }
                schema.validate(data.value, data.rule.options || options, function (errs) {
                  var finalErrors = [];
                  if (filledErrors && filledErrors.length) {
                    finalErrors.push.apply(finalErrors, _toConsumableArray(filledErrors));
                  }
                  if (errs && errs.length) {
                    finalErrors.push.apply(finalErrors, _toConsumableArray(errs));
                  }
                  doIt(finalErrors.length ? finalErrors : null);
                });
              }
            }
            var res;
            if (rule.asyncValidator) {
              res = rule.asyncValidator(rule, data.value, cb, data.source, options);
            } else if (rule.validator) {
              try {
                res = rule.validator(rule, data.value, cb, data.source, options);
              } catch (error) {
                var _console$error, _console;
                (_console$error = (_console = console).error) === null || _console$error === void 0 || _console$error.call(_console, error);
                // rethrow to report error
                if (!options.suppressValidatorError) {
                  setTimeout(function () {
                    throw error;
                  }, 0);
                }
                cb(error.message);
              }
              if (res === true) {
                cb();
              } else if (res === false) {
                cb(typeof rule.message === 'function' ? rule.message(rule.fullField || rule.field) : rule.message || "".concat(rule.fullField || rule.field, " fails"));
              } else if (res instanceof Array) {
                cb(res);
              } else if (res instanceof Error) {
                cb(res.message);
              }
            }
            if (res && res.then) {
              res.then(function () {
                return cb();
              }, function (e) {
                return cb(e);
              });
            }
          }, function (results) {
            complete(results);
          }, source);
        }
      }, {
        key: "getType",
        value: function getType(rule) {
          if (rule.type === undefined && rule.pattern instanceof RegExp) {
            rule.type = 'pattern';
          }
          if (typeof rule.validator !== 'function' && rule.type && !validators$2.hasOwnProperty(rule.type)) {
            throw new Error(format('Unknown rule type %s', rule.type));
          }
          return rule.type || 'string';
        }
      }, {
        key: "getValidationMethod",
        value: function getValidationMethod(rule) {
          if (typeof rule.validator === 'function') {
            return rule.validator;
          }
          var keys = Object.keys(rule);
          var messageIndex = keys.indexOf('message');
          if (messageIndex !== -1) {
            keys.splice(messageIndex, 1);
          }
          if (keys.length === 1 && keys[0] === 'required') {
            return validators$2.required;
          }
          return validators$2[this.getType(rule)] || undefined;
        }
      }]);
      return Schema;
    }();
    // ========================= Static =========================
    _defineProperty(Schema, "register", function register(type, validator) {
      if (typeof validator !== 'function') {
        throw new Error('Cannot register a validator by type, validator is not a function');
      }
      validators$2[type] = validator;
    });
    _defineProperty(Schema, "warning", warning);
    _defineProperty(Schema, "messages", messages);
    _defineProperty(Schema, "validators", validators$2);

    var typeTemplate = "'${name}' is not a valid ${type}";
    var defaultValidateMessages = {
      default: "Validation error on field '${name}'",
      required: "'${name}' is required",
      enum: "'${name}' must be one of [${enum}]",
      whitespace: "'${name}' cannot be empty",
      date: {
        format: "'${name}' is invalid for format date",
        parse: "'${name}' could not be parsed as date",
        invalid: "'${name}' is invalid date"
      },
      types: {
        string: typeTemplate,
        method: typeTemplate,
        array: typeTemplate,
        object: typeTemplate,
        number: typeTemplate,
        date: typeTemplate,
        boolean: typeTemplate,
        integer: typeTemplate,
        float: typeTemplate,
        regexp: typeTemplate,
        email: typeTemplate,
        url: typeTemplate,
        hex: typeTemplate
      },
      string: {
        len: "'${name}' must be exactly ${len} characters",
        min: "'${name}' must be at least ${min} characters",
        max: "'${name}' cannot be longer than ${max} characters",
        range: "'${name}' must be between ${min} and ${max} characters"
      },
      number: {
        len: "'${name}' must equal ${len}",
        min: "'${name}' cannot be less than ${min}",
        max: "'${name}' cannot be greater than ${max}",
        range: "'${name}' must be between ${min} and ${max}"
      },
      array: {
        len: "'${name}' must be exactly ${len} in length",
        min: "'${name}' cannot be less than ${min} in length",
        max: "'${name}' cannot be greater than ${max} in length",
        range: "'${name}' must be between ${min} and ${max} in length"
      },
      pattern: {
        mismatch: "'${name}' does not match pattern ${pattern}"
      }
    };

    // Remove incorrect original ts define
    var AsyncValidator = Schema;

    /**
     * Replace with template.
     *   `I'm ${name}` + { name: 'bamboo' } = I'm bamboo
     */
    function replaceMessage(template, kv) {
      return template.replace(/\\?\$\{\w+\}/g, function (str) {
        if (str.startsWith('\\')) {
          return str.slice(1);
        }
        var key = str.slice(2, -1);
        return kv[key];
      });
    }
    var CODE_LOGIC_ERROR = 'CODE_LOGIC_ERROR';
    function validateRule(_x, _x2, _x3, _x4, _x5) {
      return _validateRule.apply(this, arguments);
    }
    /**
     * We use `async-validator` to validate the value.
     * But only check one value in a time to avoid namePath validate issue.
     */
    function _validateRule() {
      _validateRule = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(name, value, rule, options, messageVariables) {
        var cloneRule, originValidator, subRuleField, validator, messages, result, subResults, kv, fillVariableResult;
        return _regeneratorRuntime().wrap(function _callee2$(_context2) {
          while (1) switch (_context2.prev = _context2.next) {
            case 0:
              cloneRule = _objectSpread2({}, rule); // Bug of `async-validator`
              // https://github.com/react-component/field-form/issues/316
              // https://github.com/react-component/field-form/issues/313
              delete cloneRule.ruleIndex;

              // https://github.com/ant-design/ant-design/issues/40497#issuecomment-1422282378
              AsyncValidator.warning = function () {
                return void 0;
              };
              if (cloneRule.validator) {
                originValidator = cloneRule.validator;
                cloneRule.validator = function () {
                  try {
                    return originValidator.apply(void 0, arguments);
                  } catch (error) {
                    console.error(error);
                    return Promise.reject(CODE_LOGIC_ERROR);
                  }
                };
              }

              // We should special handle array validate
              subRuleField = null;
              if (cloneRule && cloneRule.type === 'array' && cloneRule.defaultField) {
                subRuleField = cloneRule.defaultField;
                delete cloneRule.defaultField;
              }
              validator = new AsyncValidator(_defineProperty({}, name, [cloneRule]));
              messages = merge$2(defaultValidateMessages, options.validateMessages);
              validator.messages(messages);
              result = [];
              _context2.prev = 10;
              _context2.next = 13;
              return Promise.resolve(validator.validate(_defineProperty({}, name, value), _objectSpread2({}, options)));
            case 13:
              _context2.next = 18;
              break;
            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](10);
              if (_context2.t0.errors) {
                result = _context2.t0.errors.map(function (_ref4, index) {
                  var message = _ref4.message;
                  var mergedMessage = message === CODE_LOGIC_ERROR ? messages.default : message;
                  return /*#__PURE__*/reactExports.isValidElement(mergedMessage) ?
                  /*#__PURE__*/
                  // Wrap ReactNode with `key`
                  reactExports.cloneElement(mergedMessage, {
                    key: "error_".concat(index)
                  }) : mergedMessage;
                });
              }
            case 18:
              if (!(!result.length && subRuleField)) {
                _context2.next = 23;
                break;
              }
              _context2.next = 21;
              return Promise.all(value.map(function (subValue, i) {
                return validateRule("".concat(name, ".").concat(i), subValue, subRuleField, options, messageVariables);
              }));
            case 21:
              subResults = _context2.sent;
              return _context2.abrupt("return", subResults.reduce(function (prev, errors) {
                return [].concat(_toConsumableArray(prev), _toConsumableArray(errors));
              }, []));
            case 23:
              // Replace message with variables
              kv = _objectSpread2(_objectSpread2({}, rule), {}, {
                name: name,
                enum: (rule.enum || []).join(', ')
              }, messageVariables);
              fillVariableResult = result.map(function (error) {
                if (typeof error === 'string') {
                  return replaceMessage(error, kv);
                }
                return error;
              });
              return _context2.abrupt("return", fillVariableResult);
            case 26:
            case "end":
              return _context2.stop();
          }
        }, _callee2, null, [[10, 15]]);
      }));
      return _validateRule.apply(this, arguments);
    }
    function validateRules(namePath, value, rules, options, validateFirst, messageVariables) {
      var name = namePath.join('.');

      // Fill rule with context
      var filledRules = rules.map(function (currentRule, ruleIndex) {
        var originValidatorFunc = currentRule.validator;
        var cloneRule = _objectSpread2(_objectSpread2({}, currentRule), {}, {
          ruleIndex: ruleIndex
        });

        // Replace validator if needed
        if (originValidatorFunc) {
          cloneRule.validator = function (rule, val, callback) {
            var hasPromise = false;

            // Wrap callback only accept when promise not provided
            var wrappedCallback = function wrappedCallback() {
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              // Wait a tick to make sure return type is a promise
              Promise.resolve().then(function () {
                warningOnce(!hasPromise, 'Your validator function has already return a promise. `callback` will be ignored.');
                if (!hasPromise) {
                  callback.apply(void 0, args);
                }
              });
            };

            // Get promise
            var promise = originValidatorFunc(rule, val, wrappedCallback);
            hasPromise = promise && typeof promise.then === 'function' && typeof promise.catch === 'function';

            /**
             * 1. Use promise as the first priority.
             * 2. If promise not exist, use callback with warning instead
             */
            warningOnce(hasPromise, '`callback` is deprecated. Please return a promise instead.');
            if (hasPromise) {
              promise.then(function () {
                callback();
              }).catch(function (err) {
                callback(err || ' ');
              });
            }
          };
        }
        return cloneRule;
      }).sort(function (_ref, _ref2) {
        var w1 = _ref.warningOnly,
          i1 = _ref.ruleIndex;
        var w2 = _ref2.warningOnly,
          i2 = _ref2.ruleIndex;
        if (!!w1 === !!w2) {
          // Let keep origin order
          return i1 - i2;
        }
        if (w1) {
          return 1;
        }
        return -1;
      });

      // Do validate rules
      var summaryPromise;
      if (validateFirst === true) {
        // >>>>> Validate by serialization
        summaryPromise = new Promise( /*#__PURE__*/function () {
          var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(resolve, reject) {
            var i, rule, errors;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  i = 0;
                case 1:
                  if (!(i < filledRules.length)) {
                    _context.next = 12;
                    break;
                  }
                  rule = filledRules[i];
                  _context.next = 5;
                  return validateRule(name, value, rule, options, messageVariables);
                case 5:
                  errors = _context.sent;
                  if (!errors.length) {
                    _context.next = 9;
                    break;
                  }
                  reject([{
                    errors: errors,
                    rule: rule
                  }]);
                  return _context.abrupt("return");
                case 9:
                  i += 1;
                  _context.next = 1;
                  break;
                case 12:
                  /* eslint-enable */

                  resolve([]);
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          }));
          return function (_x6, _x7) {
            return _ref3.apply(this, arguments);
          };
        }());
      } else {
        // >>>>> Validate by parallel
        var rulePromises = filledRules.map(function (rule) {
          return validateRule(name, value, rule, options, messageVariables).then(function (errors) {
            return {
              errors: errors,
              rule: rule
            };
          });
        });
        summaryPromise = (validateFirst ? finishOnFirstFailed(rulePromises) : finishOnAllFailed(rulePromises)).then(function (errors) {
          // Always change to rejection for Field to catch
          return Promise.reject(errors);
        });
      }

      // Internal catch error to avoid console error log.
      summaryPromise.catch(function (e) {
        return e;
      });
      return summaryPromise;
    }
    function finishOnAllFailed(_x8) {
      return _finishOnAllFailed.apply(this, arguments);
    }
    function _finishOnAllFailed() {
      _finishOnAllFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3(rulePromises) {
        return _regeneratorRuntime().wrap(function _callee3$(_context3) {
          while (1) switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.abrupt("return", Promise.all(rulePromises).then(function (errorsList) {
                var _ref5;
                var errors = (_ref5 = []).concat.apply(_ref5, _toConsumableArray(errorsList));
                return errors;
              }));
            case 1:
            case "end":
              return _context3.stop();
          }
        }, _callee3);
      }));
      return _finishOnAllFailed.apply(this, arguments);
    }
    function finishOnFirstFailed(_x9) {
      return _finishOnFirstFailed.apply(this, arguments);
    }
    function _finishOnFirstFailed() {
      _finishOnFirstFailed = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(rulePromises) {
        var count;
        return _regeneratorRuntime().wrap(function _callee4$(_context4) {
          while (1) switch (_context4.prev = _context4.next) {
            case 0:
              count = 0;
              return _context4.abrupt("return", new Promise(function (resolve) {
                rulePromises.forEach(function (promise) {
                  promise.then(function (ruleError) {
                    if (ruleError.errors.length) {
                      resolve([ruleError]);
                    }
                    count += 1;
                    if (count === rulePromises.length) {
                      resolve([]);
                    }
                  });
                });
              }));
            case 2:
            case "end":
              return _context4.stop();
          }
        }, _callee4);
      }));
      return _finishOnFirstFailed.apply(this, arguments);
    }

    /**
     * Convert name to internal supported format.
     * This function should keep since we still thinking if need support like `a.b.c` format.
     * 'a' => ['a']
     * 123 => [123]
     * ['a', 123] => ['a', 123]
     */
    function getNamePath(path) {
      return toArray$1(path);
    }
    function cloneByNamePathList(store, namePathList) {
      var newStore = {};
      namePathList.forEach(function (namePath) {
        var value = get(store, namePath);
        newStore = set(newStore, namePath, value);
      });
      return newStore;
    }

    /**
     * Check if `namePathList` includes `namePath`.
     * @param namePathList A list of `InternalNamePath[]`
     * @param namePath Compare `InternalNamePath`
     * @param partialMatch True will make `[a, b]` match `[a, b, c]`
     */
    function containsNamePath(namePathList, namePath) {
      var partialMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return namePathList && namePathList.some(function (path) {
        return matchNamePath(namePath, path, partialMatch);
      });
    }

    /**
     * Check if `namePath` is super set or equal of `subNamePath`.
     * @param namePath A list of `InternalNamePath[]`
     * @param subNamePath Compare `InternalNamePath`
     * @param partialMatch True will make `[a, b]` match `[a, b, c]`
     */
    function matchNamePath(namePath, subNamePath) {
      var partialMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      if (!namePath || !subNamePath) {
        return false;
      }
      if (!partialMatch && namePath.length !== subNamePath.length) {
        return false;
      }
      return subNamePath.every(function (nameUnit, i) {
        return namePath[i] === nameUnit;
      });
    }

    // Like `shallowEqual`, but we not check the data which may cause re-render

    function isSimilar(source, target) {
      if (source === target) {
        return true;
      }
      if (!source && target || source && !target) {
        return false;
      }
      if (!source || !target || _typeof(source) !== 'object' || _typeof(target) !== 'object') {
        return false;
      }
      var sourceKeys = Object.keys(source);
      var targetKeys = Object.keys(target);
      var keys = new Set([].concat(sourceKeys, targetKeys));
      return _toConsumableArray(keys).every(function (key) {
        var sourceValue = source[key];
        var targetValue = target[key];
        if (typeof sourceValue === 'function' && typeof targetValue === 'function') {
          return true;
        }
        return sourceValue === targetValue;
      });
    }
    function defaultGetValueFromEvent(valuePropName) {
      var event = arguments.length <= 1 ? undefined : arguments[1];
      if (event && event.target && _typeof(event.target) === 'object' && valuePropName in event.target) {
        return event.target[valuePropName];
      }
      return event;
    }

    /**
     * Moves an array item from one position in an array to another.
     *
     * Note: This is a pure function so a new array will be returned, instead
     * of altering the array argument.
     *
     * @param array         Array in which to move an item.         (required)
     * @param moveIndex     The index of the item to move.          (required)
     * @param toIndex       The index to move item at moveIndex to. (required)
     */
    function move(array, moveIndex, toIndex) {
      var length = array.length;
      if (moveIndex < 0 || moveIndex >= length || toIndex < 0 || toIndex >= length) {
        return array;
      }
      var item = array[moveIndex];
      var diff = moveIndex - toIndex;
      if (diff > 0) {
        // move left
        return [].concat(_toConsumableArray(array.slice(0, toIndex)), [item], _toConsumableArray(array.slice(toIndex, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, length)));
      }
      if (diff < 0) {
        // move right
        return [].concat(_toConsumableArray(array.slice(0, moveIndex)), _toConsumableArray(array.slice(moveIndex + 1, toIndex + 1)), [item], _toConsumableArray(array.slice(toIndex + 1, length)));
      }
      return array;
    }

    var _excluded$6 = ["name"];
    var EMPTY_ERRORS = [];
    function requireUpdate(shouldUpdate, prev, next, prevValue, nextValue, info) {
      if (typeof shouldUpdate === 'function') {
        return shouldUpdate(prev, next, 'source' in info ? {
          source: info.source
        } : {});
      }
      return prevValue !== nextValue;
    }

    // eslint-disable-next-line @typescript-eslint/consistent-indexed-object-style
    // We use Class instead of Hooks here since it will cost much code by using Hooks.
    var Field = /*#__PURE__*/function (_React$Component) {
      _inherits(Field, _React$Component);
      var _super = _createSuper(Field);
      // ============================== Subscriptions ==============================
      function Field(props) {
        var _this;
        _classCallCheck(this, Field);
        _this = _super.call(this, props);

        // Register on init
        _defineProperty(_assertThisInitialized(_this), "state", {
          resetCount: 0
        });
        _defineProperty(_assertThisInitialized(_this), "cancelRegisterFunc", null);
        _defineProperty(_assertThisInitialized(_this), "mounted", false);
        /**
         * Follow state should not management in State since it will async update by React.
         * This makes first render of form can not get correct state value.
         */
        _defineProperty(_assertThisInitialized(_this), "touched", false);
        /**
         * Mark when touched & validated. Currently only used for `dependencies`.
         * Note that we do not think field with `initialValue` is dirty
         * but this will be by `isFieldDirty` func.
         */
        _defineProperty(_assertThisInitialized(_this), "dirty", false);
        _defineProperty(_assertThisInitialized(_this), "validatePromise", void 0);
        _defineProperty(_assertThisInitialized(_this), "prevValidating", void 0);
        _defineProperty(_assertThisInitialized(_this), "errors", EMPTY_ERRORS);
        _defineProperty(_assertThisInitialized(_this), "warnings", EMPTY_ERRORS);
        _defineProperty(_assertThisInitialized(_this), "cancelRegister", function () {
          var _this$props = _this.props,
            preserve = _this$props.preserve,
            isListField = _this$props.isListField,
            name = _this$props.name;
          if (_this.cancelRegisterFunc) {
            _this.cancelRegisterFunc(isListField, preserve, getNamePath(name));
          }
          _this.cancelRegisterFunc = null;
        });
        // ================================== Utils ==================================
        _defineProperty(_assertThisInitialized(_this), "getNamePath", function () {
          var _this$props2 = _this.props,
            name = _this$props2.name,
            fieldContext = _this$props2.fieldContext;
          var _fieldContext$prefixN = fieldContext.prefixName,
            prefixName = _fieldContext$prefixN === void 0 ? [] : _fieldContext$prefixN;
          return name !== undefined ? [].concat(_toConsumableArray(prefixName), _toConsumableArray(name)) : [];
        });
        _defineProperty(_assertThisInitialized(_this), "getRules", function () {
          var _this$props3 = _this.props,
            _this$props3$rules = _this$props3.rules,
            rules = _this$props3$rules === void 0 ? [] : _this$props3$rules,
            fieldContext = _this$props3.fieldContext;
          return rules.map(function (rule) {
            if (typeof rule === 'function') {
              return rule(fieldContext);
            }
            return rule;
          });
        });
        _defineProperty(_assertThisInitialized(_this), "refresh", function () {
          if (!_this.mounted) return;

          /**
           * Clean up current node.
           */
          _this.setState(function (_ref) {
            var resetCount = _ref.resetCount;
            return {
              resetCount: resetCount + 1
            };
          });
        });
        // Event should only trigger when meta changed
        _defineProperty(_assertThisInitialized(_this), "metaCache", null);
        _defineProperty(_assertThisInitialized(_this), "triggerMetaEvent", function (destroy) {
          var onMetaChange = _this.props.onMetaChange;
          if (onMetaChange) {
            var _meta = _objectSpread2(_objectSpread2({}, _this.getMeta()), {}, {
              destroy: destroy
            });
            if (!isEqual(_this.metaCache, _meta)) {
              onMetaChange(_meta);
            }
            _this.metaCache = _meta;
          } else {
            _this.metaCache = null;
          }
        });
        // ========================= Field Entity Interfaces =========================
        // Trigger by store update. Check if need update the component
        _defineProperty(_assertThisInitialized(_this), "onStoreChange", function (prevStore, namePathList, info) {
          var _this$props4 = _this.props,
            shouldUpdate = _this$props4.shouldUpdate,
            _this$props4$dependen = _this$props4.dependencies,
            dependencies = _this$props4$dependen === void 0 ? [] : _this$props4$dependen,
            onReset = _this$props4.onReset;
          var store = info.store;
          var namePath = _this.getNamePath();
          var prevValue = _this.getValue(prevStore);
          var curValue = _this.getValue(store);
          var namePathMatch = namePathList && containsNamePath(namePathList, namePath);

          // `setFieldsValue` is a quick access to update related status
          if (info.type === 'valueUpdate' && info.source === 'external' && !isEqual(prevValue, curValue)) {
            _this.touched = true;
            _this.dirty = true;
            _this.validatePromise = null;
            _this.errors = EMPTY_ERRORS;
            _this.warnings = EMPTY_ERRORS;
            _this.triggerMetaEvent();
          }
          switch (info.type) {
            case 'reset':
              if (!namePathList || namePathMatch) {
                // Clean up state
                _this.touched = false;
                _this.dirty = false;
                _this.validatePromise = undefined;
                _this.errors = EMPTY_ERRORS;
                _this.warnings = EMPTY_ERRORS;
                _this.triggerMetaEvent();
                onReset === null || onReset === void 0 || onReset();
                _this.refresh();
                return;
              }
              break;

            /**
             * In case field with `preserve = false` nest deps like:
             * - A = 1 => show B
             * - B = 1 => show C
             * - Reset A, need clean B, C
             */
            case 'remove':
              {
                if (shouldUpdate && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                  _this.reRender();
                  return;
                }
                break;
              }
            case 'setField':
              {
                var data = info.data;
                if (namePathMatch) {
                  if ('touched' in data) {
                    _this.touched = data.touched;
                  }
                  if ('validating' in data && !('originRCField' in data)) {
                    _this.validatePromise = data.validating ? Promise.resolve([]) : null;
                  }
                  if ('errors' in data) {
                    _this.errors = data.errors || EMPTY_ERRORS;
                  }
                  if ('warnings' in data) {
                    _this.warnings = data.warnings || EMPTY_ERRORS;
                  }
                  _this.dirty = true;
                  _this.triggerMetaEvent();
                  _this.reRender();
                  return;
                } else if ('value' in data && containsNamePath(namePathList, namePath, true)) {
                  // Contains path with value should also check
                  _this.reRender();
                  return;
                }

                // Handle update by `setField` with `shouldUpdate`
                if (shouldUpdate && !namePath.length && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                  _this.reRender();
                  return;
                }
                break;
              }
            case 'dependenciesUpdate':
              {
                /**
                 * Trigger when marked `dependencies` updated. Related fields will all update
                 */
                var dependencyList = dependencies.map(getNamePath);
                // No need for `namePathMath` check and `shouldUpdate` check, since `valueUpdate` will be
                // emitted earlier and they will work there
                // If set it may cause unnecessary twice rerendering
                if (dependencyList.some(function (dependency) {
                  return containsNamePath(info.relatedFields, dependency);
                })) {
                  _this.reRender();
                  return;
                }
                break;
              }
            default:
              // 1. If `namePath` exists in `namePathList`, means it's related value and should update
              //      For example <List name="list"><Field name={['list', 0]}></List>
              //      If `namePathList` is [['list']] (List value update), Field should be updated
              //      If `namePathList` is [['list', 0]] (Field value update), List shouldn't be updated
              // 2.
              //   2.1 If `dependencies` is set, `name` is not set and `shouldUpdate` is not set,
              //       don't use `shouldUpdate`. `dependencies` is view as a shortcut if `shouldUpdate`
              //       is not provided
              //   2.2 If `shouldUpdate` provided, use customize logic to update the field
              //       else to check if value changed
              if (namePathMatch || (!dependencies.length || namePath.length || shouldUpdate) && requireUpdate(shouldUpdate, prevStore, store, prevValue, curValue, info)) {
                _this.reRender();
                return;
              }
              break;
          }
          if (shouldUpdate === true) {
            _this.reRender();
          }
        });
        _defineProperty(_assertThisInitialized(_this), "validateRules", function (options) {
          // We should fixed namePath & value to avoid developer change then by form function
          var namePath = _this.getNamePath();
          var currentValue = _this.getValue();
          var _ref2 = options || {},
            triggerName = _ref2.triggerName,
            _ref2$validateOnly = _ref2.validateOnly,
            validateOnly = _ref2$validateOnly === void 0 ? false : _ref2$validateOnly;

          // Force change to async to avoid rule OOD under renderProps field
          var rootPromise = Promise.resolve().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
            var _this$props5, _this$props5$validate, validateFirst, messageVariables, validateDebounce, filteredRules, promise;
            return _regeneratorRuntime().wrap(function _callee$(_context) {
              while (1) switch (_context.prev = _context.next) {
                case 0:
                  if (_this.mounted) {
                    _context.next = 2;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 2:
                  _this$props5 = _this.props, _this$props5$validate = _this$props5.validateFirst, validateFirst = _this$props5$validate === void 0 ? false : _this$props5$validate, messageVariables = _this$props5.messageVariables, validateDebounce = _this$props5.validateDebounce; // Start validate
                  filteredRules = _this.getRules();
                  if (triggerName) {
                    filteredRules = filteredRules.filter(function (rule) {
                      return rule;
                    }).filter(function (rule) {
                      var validateTrigger = rule.validateTrigger;
                      if (!validateTrigger) {
                        return true;
                      }
                      var triggerList = toArray$1(validateTrigger);
                      return triggerList.includes(triggerName);
                    });
                  }

                  // Wait for debounce. Skip if no `triggerName` since its from `validateFields / submit`
                  if (!(validateDebounce && triggerName)) {
                    _context.next = 10;
                    break;
                  }
                  _context.next = 8;
                  return new Promise(function (resolve) {
                    setTimeout(resolve, validateDebounce);
                  });
                case 8:
                  if (!(_this.validatePromise !== rootPromise)) {
                    _context.next = 10;
                    break;
                  }
                  return _context.abrupt("return", []);
                case 10:
                  promise = validateRules(namePath, currentValue, filteredRules, options, validateFirst, messageVariables);
                  promise.catch(function (e) {
                    return e;
                  }).then(function () {
                    var ruleErrors = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : EMPTY_ERRORS;
                    if (_this.validatePromise === rootPromise) {
                      var _ruleErrors$forEach;
                      _this.validatePromise = null;

                      // Get errors & warnings
                      var nextErrors = [];
                      var nextWarnings = [];
                      (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function (_ref4) {
                        var warningOnly = _ref4.rule.warningOnly,
                          _ref4$errors = _ref4.errors,
                          errors = _ref4$errors === void 0 ? EMPTY_ERRORS : _ref4$errors;
                        if (warningOnly) {
                          nextWarnings.push.apply(nextWarnings, _toConsumableArray(errors));
                        } else {
                          nextErrors.push.apply(nextErrors, _toConsumableArray(errors));
                        }
                      });
                      _this.errors = nextErrors;
                      _this.warnings = nextWarnings;
                      _this.triggerMetaEvent();
                      _this.reRender();
                    }
                  });
                  return _context.abrupt("return", promise);
                case 13:
                case "end":
                  return _context.stop();
              }
            }, _callee);
          })));
          if (validateOnly) {
            return rootPromise;
          }
          _this.validatePromise = rootPromise;
          _this.dirty = true;
          _this.errors = EMPTY_ERRORS;
          _this.warnings = EMPTY_ERRORS;
          _this.triggerMetaEvent();

          // Force trigger re-render since we need sync renderProps with new meta
          _this.reRender();
          return rootPromise;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldValidating", function () {
          return !!_this.validatePromise;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldTouched", function () {
          return _this.touched;
        });
        _defineProperty(_assertThisInitialized(_this), "isFieldDirty", function () {
          // Touched or validate or has initialValue
          if (_this.dirty || _this.props.initialValue !== undefined) {
            return true;
          }

          // Form set initialValue
          var fieldContext = _this.props.fieldContext;
          var _fieldContext$getInte = fieldContext.getInternalHooks(HOOK_MARK),
            getInitialValue = _fieldContext$getInte.getInitialValue;
          if (getInitialValue(_this.getNamePath()) !== undefined) {
            return true;
          }
          return false;
        });
        _defineProperty(_assertThisInitialized(_this), "getErrors", function () {
          return _this.errors;
        });
        _defineProperty(_assertThisInitialized(_this), "getWarnings", function () {
          return _this.warnings;
        });
        _defineProperty(_assertThisInitialized(_this), "isListField", function () {
          return _this.props.isListField;
        });
        _defineProperty(_assertThisInitialized(_this), "isList", function () {
          return _this.props.isList;
        });
        _defineProperty(_assertThisInitialized(_this), "isPreserve", function () {
          return _this.props.preserve;
        });
        // ============================= Child Component =============================
        _defineProperty(_assertThisInitialized(_this), "getMeta", function () {
          // Make error & validating in cache to save perf
          _this.prevValidating = _this.isFieldValidating();
          var meta = {
            touched: _this.isFieldTouched(),
            validating: _this.prevValidating,
            errors: _this.errors,
            warnings: _this.warnings,
            name: _this.getNamePath(),
            validated: _this.validatePromise === null
          };
          return meta;
        });
        // Only return validate child node. If invalidate, will do nothing about field.
        _defineProperty(_assertThisInitialized(_this), "getOnlyChild", function (children) {
          // Support render props
          if (typeof children === 'function') {
            var _meta2 = _this.getMeta();
            return _objectSpread2(_objectSpread2({}, _this.getOnlyChild(children(_this.getControlled(), _meta2, _this.props.fieldContext))), {}, {
              isFunction: true
            });
          }

          // Filed element only
          var childList = toArray$2(children);
          if (childList.length !== 1 || ! /*#__PURE__*/reactExports.isValidElement(childList[0])) {
            return {
              child: childList,
              isFunction: false
            };
          }
          return {
            child: childList[0],
            isFunction: false
          };
        });
        // ============================== Field Control ==============================
        _defineProperty(_assertThisInitialized(_this), "getValue", function (store) {
          var getFieldsValue = _this.props.fieldContext.getFieldsValue;
          var namePath = _this.getNamePath();
          return get(store || getFieldsValue(true), namePath);
        });
        _defineProperty(_assertThisInitialized(_this), "getControlled", function () {
          var childProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          var _this$props6 = _this.props,
            name = _this$props6.name,
            trigger = _this$props6.trigger,
            validateTrigger = _this$props6.validateTrigger,
            getValueFromEvent = _this$props6.getValueFromEvent,
            normalize = _this$props6.normalize,
            valuePropName = _this$props6.valuePropName,
            getValueProps = _this$props6.getValueProps,
            fieldContext = _this$props6.fieldContext;
          var mergedValidateTrigger = validateTrigger !== undefined ? validateTrigger : fieldContext.validateTrigger;
          var namePath = _this.getNamePath();
          var getInternalHooks = fieldContext.getInternalHooks,
            getFieldsValue = fieldContext.getFieldsValue;
          var _getInternalHooks = getInternalHooks(HOOK_MARK),
            dispatch = _getInternalHooks.dispatch;
          var value = _this.getValue();
          var mergedGetValueProps = getValueProps || function (val) {
            return _defineProperty({}, valuePropName, val);
          };
          var originTriggerFunc = childProps[trigger];
          var valueProps = name !== undefined ? mergedGetValueProps(value) : {};
          var control = _objectSpread2(_objectSpread2({}, childProps), valueProps);

          // Add trigger
          control[trigger] = function () {
            // Mark as touched
            _this.touched = true;
            _this.dirty = true;
            _this.triggerMetaEvent();
            var newValue;
            for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }
            if (getValueFromEvent) {
              newValue = getValueFromEvent.apply(void 0, args);
            } else {
              newValue = defaultGetValueFromEvent.apply(void 0, [valuePropName].concat(args));
            }
            if (normalize) {
              newValue = normalize(newValue, value, getFieldsValue(true));
            }
            if (newValue !== value) {
              dispatch({
                type: 'updateValue',
                namePath: namePath,
                value: newValue
              });
            }
            if (originTriggerFunc) {
              originTriggerFunc.apply(void 0, args);
            }
          };

          // Add validateTrigger
          var validateTriggerList = toArray$1(mergedValidateTrigger || []);
          validateTriggerList.forEach(function (triggerName) {
            // Wrap additional function of component, so that we can get latest value from store
            var originTrigger = control[triggerName];
            control[triggerName] = function () {
              if (originTrigger) {
                originTrigger.apply(void 0, arguments);
              }

              // Always use latest rules
              var rules = _this.props.rules;
              if (rules && rules.length) {
                // We dispatch validate to root,
                // since it will update related data with other field with same name
                dispatch({
                  type: 'validateField',
                  namePath: namePath,
                  triggerName: triggerName
                });
              }
            };
          });
          return control;
        });
        if (props.fieldContext) {
          var getInternalHooks = props.fieldContext.getInternalHooks;
          var _getInternalHooks2 = getInternalHooks(HOOK_MARK),
            initEntityValue = _getInternalHooks2.initEntityValue;
          initEntityValue(_assertThisInitialized(_this));
        }
        return _this;
      }
      _createClass(Field, [{
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props7 = this.props,
            shouldUpdate = _this$props7.shouldUpdate,
            fieldContext = _this$props7.fieldContext;
          this.mounted = true;

          // Register on init
          if (fieldContext) {
            var getInternalHooks = fieldContext.getInternalHooks;
            var _getInternalHooks3 = getInternalHooks(HOOK_MARK),
              registerField = _getInternalHooks3.registerField;
            this.cancelRegisterFunc = registerField(this);
          }

          // One more render for component in case fields not ready
          if (shouldUpdate === true) {
            this.reRender();
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          this.cancelRegister();
          this.triggerMetaEvent(true);
          this.mounted = false;
        }
      }, {
        key: "reRender",
        value: function reRender() {
          if (!this.mounted) return;
          this.forceUpdate();
        }
      }, {
        key: "render",
        value: function render() {
          var resetCount = this.state.resetCount;
          var children = this.props.children;
          var _this$getOnlyChild = this.getOnlyChild(children),
            child = _this$getOnlyChild.child,
            isFunction = _this$getOnlyChild.isFunction;

          // Not need to `cloneElement` since user can handle this in render function self
          var returnChildNode;
          if (isFunction) {
            returnChildNode = child;
          } else if ( /*#__PURE__*/reactExports.isValidElement(child)) {
            returnChildNode = /*#__PURE__*/reactExports.cloneElement(child, this.getControlled(child.props));
          } else {
            warningOnce(!child, '`children` of Field is not validate ReactElement.');
            returnChildNode = child;
          }
          return /*#__PURE__*/reactExports.createElement(reactExports.Fragment, {
            key: resetCount
          }, returnChildNode);
        }
      }]);
      return Field;
    }(reactExports.Component);
    _defineProperty(Field, "contextType", Context);
    _defineProperty(Field, "defaultProps", {
      trigger: 'onChange',
      valuePropName: 'value'
    });
    function WrapperField(_ref6) {
      var _restProps$isListFiel;
      var name = _ref6.name,
        restProps = _objectWithoutProperties(_ref6, _excluded$6);
      var fieldContext = reactExports.useContext(Context);
      var listContext = reactExports.useContext(ListContext);
      var namePath = name !== undefined ? getNamePath(name) : undefined;
      var isMergedListField = (_restProps$isListFiel = restProps.isListField) !== null && _restProps$isListFiel !== void 0 ? _restProps$isListFiel : !!listContext;
      var key = 'keep';
      if (!isMergedListField) {
        key = "_".concat((namePath || []).join('_'));
      }
      return /*#__PURE__*/reactExports.createElement(Field, _extends({
        key: key,
        name: namePath,
        isListField: isMergedListField
      }, restProps, {
        fieldContext: fieldContext
      }));
    }

    function List(_ref) {
      var name = _ref.name,
        initialValue = _ref.initialValue,
        children = _ref.children,
        rules = _ref.rules,
        validateTrigger = _ref.validateTrigger,
        isListField = _ref.isListField;
      var context = reactExports.useContext(Context);
      var wrapperListContext = reactExports.useContext(ListContext);
      var keyRef = reactExports.useRef({
        keys: [],
        id: 0
      });
      var keyManager = keyRef.current;
      var prefixName = reactExports.useMemo(function () {
        var parentPrefixName = getNamePath(context.prefixName) || [];
        return [].concat(_toConsumableArray(parentPrefixName), _toConsumableArray(getNamePath(name)));
      }, [context.prefixName, name]);
      var fieldContext = reactExports.useMemo(function () {
        return _objectSpread2(_objectSpread2({}, context), {}, {
          prefixName: prefixName
        });
      }, [context, prefixName]);

      // List context
      var listContext = reactExports.useMemo(function () {
        return {
          getKey: function getKey(namePath) {
            var len = prefixName.length;
            var pathName = namePath[len];
            return [keyManager.keys[pathName], namePath.slice(len + 1)];
          }
        };
      }, [prefixName]);

      // User should not pass `children` as other type.
      if (typeof children !== 'function') {
        warningOnce(false, 'Form.List only accepts function as children.');
        return null;
      }
      var shouldUpdate = function shouldUpdate(prevValue, nextValue, _ref2) {
        var source = _ref2.source;
        if (source === 'internal') {
          return false;
        }
        return prevValue !== nextValue;
      };
      return /*#__PURE__*/reactExports.createElement(ListContext.Provider, {
        value: listContext
      }, /*#__PURE__*/reactExports.createElement(Context.Provider, {
        value: fieldContext
      }, /*#__PURE__*/reactExports.createElement(WrapperField, {
        name: [],
        shouldUpdate: shouldUpdate,
        rules: rules,
        validateTrigger: validateTrigger,
        initialValue: initialValue,
        isList: true,
        isListField: isListField !== null && isListField !== void 0 ? isListField : !!wrapperListContext
      }, function (_ref3, meta) {
        var _ref3$value = _ref3.value,
          value = _ref3$value === void 0 ? [] : _ref3$value,
          onChange = _ref3.onChange;
        var getFieldValue = context.getFieldValue;
        var getNewValue = function getNewValue() {
          var values = getFieldValue(prefixName || []);
          return values || [];
        };
        /**
         * Always get latest value in case user update fields by `form` api.
         */
        var operations = {
          add: function add(defaultValue, index) {
            // Mapping keys
            var newValue = getNewValue();
            if (index >= 0 && index <= newValue.length) {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys.slice(0, index)), [keyManager.id], _toConsumableArray(keyManager.keys.slice(index)));
              onChange([].concat(_toConsumableArray(newValue.slice(0, index)), [defaultValue], _toConsumableArray(newValue.slice(index))));
            } else {
              keyManager.keys = [].concat(_toConsumableArray(keyManager.keys), [keyManager.id]);
              onChange([].concat(_toConsumableArray(newValue), [defaultValue]));
            }
            keyManager.id += 1;
          },
          remove: function remove(index) {
            var newValue = getNewValue();
            var indexSet = new Set(Array.isArray(index) ? index : [index]);
            if (indexSet.size <= 0) {
              return;
            }
            keyManager.keys = keyManager.keys.filter(function (_, keysIndex) {
              return !indexSet.has(keysIndex);
            });

            // Trigger store change
            onChange(newValue.filter(function (_, valueIndex) {
              return !indexSet.has(valueIndex);
            }));
          },
          move: function move$1(from, to) {
            if (from === to) {
              return;
            }
            var newValue = getNewValue();

            // Do not handle out of range
            if (from < 0 || from >= newValue.length || to < 0 || to >= newValue.length) {
              return;
            }
            keyManager.keys = move(keyManager.keys, from, to);

            // Trigger store change
            onChange(move(newValue, from, to));
          }
        };
        var listValue = value || [];
        if (!Array.isArray(listValue)) {
          listValue = [];
        }
        return children(listValue.map(function (__, index) {
          var key = keyManager.keys[index];
          if (key === undefined) {
            keyManager.keys[index] = keyManager.id;
            key = keyManager.keys[index];
            keyManager.id += 1;
          }
          return {
            name: index,
            key: key,
            isListField: true
          };
        }), operations, meta);
      })));
    }

    function allPromiseFinish(promiseList) {
      var hasError = false;
      var count = promiseList.length;
      var results = [];
      if (!promiseList.length) {
        return Promise.resolve([]);
      }
      return new Promise(function (resolve, reject) {
        promiseList.forEach(function (promise, index) {
          promise.catch(function (e) {
            hasError = true;
            return e;
          }).then(function (result) {
            count -= 1;
            results[index] = result;
            if (count > 0) {
              return;
            }
            if (hasError) {
              reject(results);
            }
            resolve(results);
          });
        });
      });
    }

    var SPLIT = '__@field_split__';

    /**
     * Convert name path into string to fast the fetch speed of Map.
     */
    function normalize(namePath) {
      return namePath.map(function (cell) {
        return "".concat(_typeof(cell), ":").concat(cell);
      })
      // Magic split
      .join(SPLIT);
    }

    /**
     * NameMap like a `Map` but accepts `string[]` as key.
     */
    var NameMap = /*#__PURE__*/function () {
      function NameMap() {
        _classCallCheck(this, NameMap);
        _defineProperty(this, "kvs", new Map());
      }
      _createClass(NameMap, [{
        key: "set",
        value: function set(key, value) {
          this.kvs.set(normalize(key), value);
        }
      }, {
        key: "get",
        value: function get(key) {
          return this.kvs.get(normalize(key));
        }
      }, {
        key: "update",
        value: function update(key, updater) {
          var origin = this.get(key);
          var next = updater(origin);
          if (!next) {
            this.delete(key);
          } else {
            this.set(key, next);
          }
        }
      }, {
        key: "delete",
        value: function _delete(key) {
          this.kvs.delete(normalize(key));
        }

        // Since we only use this in test, let simply realize this
      }, {
        key: "map",
        value: function map(callback) {
          return _toConsumableArray(this.kvs.entries()).map(function (_ref) {
            var _ref2 = _slicedToArray(_ref, 2),
              key = _ref2[0],
              value = _ref2[1];
            var cells = key.split(SPLIT);
            return callback({
              key: cells.map(function (cell) {
                var _cell$match = cell.match(/^([^:]*):(.*)$/),
                  _cell$match2 = _slicedToArray(_cell$match, 3),
                  type = _cell$match2[1],
                  unit = _cell$match2[2];
                return type === 'number' ? Number(unit) : unit;
              }),
              value: value
            });
          });
        }
      }, {
        key: "toJSON",
        value: function toJSON() {
          var json = {};
          this.map(function (_ref3) {
            var key = _ref3.key,
              value = _ref3.value;
            json[key.join('.')] = value;
            return null;
          });
          return json;
        }
      }]);
      return NameMap;
    }();

    var _excluded$5 = ["name"];
    var FormStore = /*#__PURE__*/_createClass(function FormStore(forceRootUpdate) {
      var _this = this;
      _classCallCheck(this, FormStore);
      _defineProperty(this, "formHooked", false);
      _defineProperty(this, "forceRootUpdate", void 0);
      _defineProperty(this, "subscribable", true);
      _defineProperty(this, "store", {});
      _defineProperty(this, "fieldEntities", []);
      _defineProperty(this, "initialValues", {});
      _defineProperty(this, "callbacks", {});
      _defineProperty(this, "validateMessages", null);
      _defineProperty(this, "preserve", null);
      _defineProperty(this, "lastValidatePromise", null);
      _defineProperty(this, "getForm", function () {
        return {
          getFieldValue: _this.getFieldValue,
          getFieldsValue: _this.getFieldsValue,
          getFieldError: _this.getFieldError,
          getFieldWarning: _this.getFieldWarning,
          getFieldsError: _this.getFieldsError,
          isFieldsTouched: _this.isFieldsTouched,
          isFieldTouched: _this.isFieldTouched,
          isFieldValidating: _this.isFieldValidating,
          isFieldsValidating: _this.isFieldsValidating,
          resetFields: _this.resetFields,
          setFields: _this.setFields,
          setFieldValue: _this.setFieldValue,
          setFieldsValue: _this.setFieldsValue,
          validateFields: _this.validateFields,
          submit: _this.submit,
          _init: true,
          getInternalHooks: _this.getInternalHooks
        };
      });
      // ======================== Internal Hooks ========================
      _defineProperty(this, "getInternalHooks", function (key) {
        if (key === HOOK_MARK) {
          _this.formHooked = true;
          return {
            dispatch: _this.dispatch,
            initEntityValue: _this.initEntityValue,
            registerField: _this.registerField,
            useSubscribe: _this.useSubscribe,
            setInitialValues: _this.setInitialValues,
            destroyForm: _this.destroyForm,
            setCallbacks: _this.setCallbacks,
            setValidateMessages: _this.setValidateMessages,
            getFields: _this.getFields,
            setPreserve: _this.setPreserve,
            getInitialValue: _this.getInitialValue,
            registerWatch: _this.registerWatch
          };
        }
        warningOnce(false, '`getInternalHooks` is internal usage. Should not call directly.');
        return null;
      });
      _defineProperty(this, "useSubscribe", function (subscribable) {
        _this.subscribable = subscribable;
      });
      /**
       * Record prev Form unmount fieldEntities which config preserve false.
       * This need to be refill with initialValues instead of store value.
       */
      _defineProperty(this, "prevWithoutPreserves", null);
      /**
       * First time `setInitialValues` should update store with initial value
       */
      _defineProperty(this, "setInitialValues", function (initialValues, init) {
        _this.initialValues = initialValues || {};
        if (init) {
          var _this$prevWithoutPres;
          var nextStore = merge$2(initialValues, _this.store);

          // We will take consider prev form unmount fields.
          // When the field is not `preserve`, we need fill this with initialValues instead of store.
          // eslint-disable-next-line array-callback-return
          (_this$prevWithoutPres = _this.prevWithoutPreserves) === null || _this$prevWithoutPres === void 0 || _this$prevWithoutPres.map(function (_ref) {
            var namePath = _ref.key;
            nextStore = set(nextStore, namePath, get(initialValues, namePath));
          });
          _this.prevWithoutPreserves = null;
          _this.updateStore(nextStore);
        }
      });
      _defineProperty(this, "destroyForm", function (clearOnDestroy) {
        if (clearOnDestroy) {
          // destroy form reset store
          _this.updateStore({});
        } else {
          // Fill preserve fields
          var prevWithoutPreserves = new NameMap();
          _this.getFieldEntities(true).forEach(function (entity) {
            if (!_this.isMergedPreserve(entity.isPreserve())) {
              prevWithoutPreserves.set(entity.getNamePath(), true);
            }
          });
          _this.prevWithoutPreserves = prevWithoutPreserves;
        }
      });
      _defineProperty(this, "getInitialValue", function (namePath) {
        var initValue = get(_this.initialValues, namePath);

        // Not cloneDeep when without `namePath`
        return namePath.length ? merge$2(initValue) : initValue;
      });
      _defineProperty(this, "setCallbacks", function (callbacks) {
        _this.callbacks = callbacks;
      });
      _defineProperty(this, "setValidateMessages", function (validateMessages) {
        _this.validateMessages = validateMessages;
      });
      _defineProperty(this, "setPreserve", function (preserve) {
        _this.preserve = preserve;
      });
      // ============================= Watch ============================
      _defineProperty(this, "watchList", []);
      _defineProperty(this, "registerWatch", function (callback) {
        _this.watchList.push(callback);
        return function () {
          _this.watchList = _this.watchList.filter(function (fn) {
            return fn !== callback;
          });
        };
      });
      _defineProperty(this, "notifyWatch", function () {
        var namePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        // No need to cost perf when nothing need to watch
        if (_this.watchList.length) {
          var values = _this.getFieldsValue();
          var allValues = _this.getFieldsValue(true);
          _this.watchList.forEach(function (callback) {
            callback(values, allValues, namePath);
          });
        }
      });
      // ========================== Dev Warning =========================
      _defineProperty(this, "timeoutId", null);
      _defineProperty(this, "warningUnhooked", function () {
      });
      // ============================ Store =============================
      _defineProperty(this, "updateStore", function (nextStore) {
        _this.store = nextStore;
      });
      // ============================ Fields ============================
      /**
       * Get registered field entities.
       * @param pure Only return field which has a `name`. Default: false
       */
      _defineProperty(this, "getFieldEntities", function () {
        var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        if (!pure) {
          return _this.fieldEntities;
        }
        return _this.fieldEntities.filter(function (field) {
          return field.getNamePath().length;
        });
      });
      _defineProperty(this, "getFieldsMap", function () {
        var pure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
        var cache = new NameMap();
        _this.getFieldEntities(pure).forEach(function (field) {
          var namePath = field.getNamePath();
          cache.set(namePath, field);
        });
        return cache;
      });
      _defineProperty(this, "getFieldEntitiesForNamePathList", function (nameList) {
        if (!nameList) {
          return _this.getFieldEntities(true);
        }
        var cache = _this.getFieldsMap(true);
        return nameList.map(function (name) {
          var namePath = getNamePath(name);
          return cache.get(namePath) || {
            INVALIDATE_NAME_PATH: getNamePath(name)
          };
        });
      });
      _defineProperty(this, "getFieldsValue", function (nameList, filterFunc) {
        _this.warningUnhooked();

        // Fill args
        var mergedNameList;
        var mergedFilterFunc;
        var mergedStrict;
        if (nameList === true || Array.isArray(nameList)) {
          mergedNameList = nameList;
          mergedFilterFunc = filterFunc;
        } else if (nameList && _typeof(nameList) === 'object') {
          mergedStrict = nameList.strict;
          mergedFilterFunc = nameList.filter;
        }
        if (mergedNameList === true && !mergedFilterFunc) {
          return _this.store;
        }
        var fieldEntities = _this.getFieldEntitiesForNamePathList(Array.isArray(mergedNameList) ? mergedNameList : null);
        var filteredNameList = [];
        fieldEntities.forEach(function (entity) {
          var _isListField, _ref3;
          var namePath = 'INVALIDATE_NAME_PATH' in entity ? entity.INVALIDATE_NAME_PATH : entity.getNamePath();

          // Ignore when it's a list item and not specific the namePath,
          // since parent field is already take in count
          if (mergedStrict) {
            var _isList, _ref2;
            if ((_isList = (_ref2 = entity).isList) !== null && _isList !== void 0 && _isList.call(_ref2)) {
              return;
            }
          } else if (!mergedNameList && (_isListField = (_ref3 = entity).isListField) !== null && _isListField !== void 0 && _isListField.call(_ref3)) {
            return;
          }
          if (!mergedFilterFunc) {
            filteredNameList.push(namePath);
          } else {
            var meta = 'getMeta' in entity ? entity.getMeta() : null;
            if (mergedFilterFunc(meta)) {
              filteredNameList.push(namePath);
            }
          }
        });
        return cloneByNamePathList(_this.store, filteredNameList.map(getNamePath));
      });
      _defineProperty(this, "getFieldValue", function (name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        return get(_this.store, namePath);
      });
      _defineProperty(this, "getFieldsError", function (nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntitiesForNamePathList(nameList);
        return fieldEntities.map(function (entity, index) {
          if (entity && !('INVALIDATE_NAME_PATH' in entity)) {
            return {
              name: entity.getNamePath(),
              errors: entity.getErrors(),
              warnings: entity.getWarnings()
            };
          }
          return {
            name: getNamePath(nameList[index]),
            errors: [],
            warnings: []
          };
        });
      });
      _defineProperty(this, "getFieldError", function (name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.errors;
      });
      _defineProperty(this, "getFieldWarning", function (name) {
        _this.warningUnhooked();
        var namePath = getNamePath(name);
        var fieldError = _this.getFieldsError([namePath])[0];
        return fieldError.warnings;
      });
      _defineProperty(this, "isFieldsTouched", function () {
        _this.warningUnhooked();
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        var arg0 = args[0],
          arg1 = args[1];
        var namePathList;
        var isAllFieldsTouched = false;
        if (args.length === 0) {
          namePathList = null;
        } else if (args.length === 1) {
          if (Array.isArray(arg0)) {
            namePathList = arg0.map(getNamePath);
            isAllFieldsTouched = false;
          } else {
            namePathList = null;
            isAllFieldsTouched = arg0;
          }
        } else {
          namePathList = arg0.map(getNamePath);
          isAllFieldsTouched = arg1;
        }
        var fieldEntities = _this.getFieldEntities(true);
        var isFieldTouched = function isFieldTouched(field) {
          return field.isFieldTouched();
        };

        // ===== Will get fully compare when not config namePathList =====
        if (!namePathList) {
          return isAllFieldsTouched ? fieldEntities.every(function (entity) {
            return isFieldTouched(entity) || entity.isList();
          }) : fieldEntities.some(isFieldTouched);
        }

        // Generate a nest tree for validate
        var map = new NameMap();
        namePathList.forEach(function (shortNamePath) {
          map.set(shortNamePath, []);
        });
        fieldEntities.forEach(function (field) {
          var fieldNamePath = field.getNamePath();

          // Find matched entity and put into list
          namePathList.forEach(function (shortNamePath) {
            if (shortNamePath.every(function (nameUnit, i) {
              return fieldNamePath[i] === nameUnit;
            })) {
              map.update(shortNamePath, function (list) {
                return [].concat(_toConsumableArray(list), [field]);
              });
            }
          });
        });

        // Check if NameMap value is touched
        var isNamePathListTouched = function isNamePathListTouched(entities) {
          return entities.some(isFieldTouched);
        };
        var namePathListEntities = map.map(function (_ref4) {
          var value = _ref4.value;
          return value;
        });
        return isAllFieldsTouched ? namePathListEntities.every(isNamePathListTouched) : namePathListEntities.some(isNamePathListTouched);
      });
      _defineProperty(this, "isFieldTouched", function (name) {
        _this.warningUnhooked();
        return _this.isFieldsTouched([name]);
      });
      _defineProperty(this, "isFieldsValidating", function (nameList) {
        _this.warningUnhooked();
        var fieldEntities = _this.getFieldEntities();
        if (!nameList) {
          return fieldEntities.some(function (testField) {
            return testField.isFieldValidating();
          });
        }
        var namePathList = nameList.map(getNamePath);
        return fieldEntities.some(function (testField) {
          var fieldNamePath = testField.getNamePath();
          return containsNamePath(namePathList, fieldNamePath) && testField.isFieldValidating();
        });
      });
      _defineProperty(this, "isFieldValidating", function (name) {
        _this.warningUnhooked();
        return _this.isFieldsValidating([name]);
      });
      /**
       * Reset Field with field `initialValue` prop.
       * Can pass `entities` or `namePathList` or just nothing.
       */
      _defineProperty(this, "resetWithFieldInitialValue", function () {
        var info = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        // Create cache
        var cache = new NameMap();
        var fieldEntities = _this.getFieldEntities(true);
        fieldEntities.forEach(function (field) {
          var initialValue = field.props.initialValue;
          var namePath = field.getNamePath();

          // Record only if has `initialValue`
          if (initialValue !== undefined) {
            var records = cache.get(namePath) || new Set();
            records.add({
              entity: field,
              value: initialValue
            });
            cache.set(namePath, records);
          }
        });

        // Reset
        var resetWithFields = function resetWithFields(entities) {
          entities.forEach(function (field) {
            var initialValue = field.props.initialValue;
            if (initialValue !== undefined) {
              var namePath = field.getNamePath();
              var formInitialValue = _this.getInitialValue(namePath);
              if (formInitialValue !== undefined) {
                // Warning if conflict with form initialValues and do not modify value
                warningOnce(false, "Form already set 'initialValues' with path '".concat(namePath.join('.'), "'. Field can not overwrite it."));
              } else {
                var records = cache.get(namePath);
                if (records && records.size > 1) {
                  // Warning if multiple field set `initialValue`and do not modify value
                  warningOnce(false, "Multiple Field with path '".concat(namePath.join('.'), "' set 'initialValue'. Can not decide which one to pick."));
                } else if (records) {
                  var originValue = _this.getFieldValue(namePath);
                  var isListField = field.isListField();

                  // Set `initialValue`
                  if (!isListField && (!info.skipExist || originValue === undefined)) {
                    _this.updateStore(set(_this.store, namePath, _toConsumableArray(records)[0].value));
                  }
                }
              }
            }
          });
        };
        var requiredFieldEntities;
        if (info.entities) {
          requiredFieldEntities = info.entities;
        } else if (info.namePathList) {
          requiredFieldEntities = [];
          info.namePathList.forEach(function (namePath) {
            var records = cache.get(namePath);
            if (records) {
              var _requiredFieldEntitie;
              (_requiredFieldEntitie = requiredFieldEntities).push.apply(_requiredFieldEntitie, _toConsumableArray(_toConsumableArray(records).map(function (r) {
                return r.entity;
              })));
            }
          });
        } else {
          requiredFieldEntities = fieldEntities;
        }
        resetWithFields(requiredFieldEntities);
      });
      _defineProperty(this, "resetFields", function (nameList) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (!nameList) {
          _this.updateStore(merge$2(_this.initialValues));
          _this.resetWithFieldInitialValue();
          _this.notifyObservers(prevStore, null, {
            type: 'reset'
          });
          _this.notifyWatch();
          return;
        }

        // Reset by `nameList`
        var namePathList = nameList.map(getNamePath);
        namePathList.forEach(function (namePath) {
          var initialValue = _this.getInitialValue(namePath);
          _this.updateStore(set(_this.store, namePath, initialValue));
        });
        _this.resetWithFieldInitialValue({
          namePathList: namePathList
        });
        _this.notifyObservers(prevStore, namePathList, {
          type: 'reset'
        });
        _this.notifyWatch(namePathList);
      });
      _defineProperty(this, "setFields", function (fields) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        var namePathList = [];
        fields.forEach(function (fieldData) {
          var name = fieldData.name,
            data = _objectWithoutProperties(fieldData, _excluded$5);
          var namePath = getNamePath(name);
          namePathList.push(namePath);

          // Value
          if ('value' in data) {
            _this.updateStore(set(_this.store, namePath, data.value));
          }
          _this.notifyObservers(prevStore, [namePath], {
            type: 'setField',
            data: fieldData
          });
        });
        _this.notifyWatch(namePathList);
      });
      _defineProperty(this, "getFields", function () {
        var entities = _this.getFieldEntities(true);
        var fields = entities.map(function (field) {
          var namePath = field.getNamePath();
          var meta = field.getMeta();
          var fieldData = _objectSpread2(_objectSpread2({}, meta), {}, {
            name: namePath,
            value: _this.getFieldValue(namePath)
          });
          Object.defineProperty(fieldData, 'originRCField', {
            value: true
          });
          return fieldData;
        });
        return fields;
      });
      // =========================== Observer ===========================
      /**
       * This only trigger when a field is on constructor to avoid we get initialValue too late
       */
      _defineProperty(this, "initEntityValue", function (entity) {
        var initialValue = entity.props.initialValue;
        if (initialValue !== undefined) {
          var namePath = entity.getNamePath();
          var prevValue = get(_this.store, namePath);
          if (prevValue === undefined) {
            _this.updateStore(set(_this.store, namePath, initialValue));
          }
        }
      });
      _defineProperty(this, "isMergedPreserve", function (fieldPreserve) {
        var mergedPreserve = fieldPreserve !== undefined ? fieldPreserve : _this.preserve;
        return mergedPreserve !== null && mergedPreserve !== void 0 ? mergedPreserve : true;
      });
      _defineProperty(this, "registerField", function (entity) {
        _this.fieldEntities.push(entity);
        var namePath = entity.getNamePath();
        _this.notifyWatch([namePath]);

        // Set initial values
        if (entity.props.initialValue !== undefined) {
          var prevStore = _this.store;
          _this.resetWithFieldInitialValue({
            entities: [entity],
            skipExist: true
          });
          _this.notifyObservers(prevStore, [entity.getNamePath()], {
            type: 'valueUpdate',
            source: 'internal'
          });
        }

        // un-register field callback
        return function (isListField, preserve) {
          var subNamePath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
          _this.fieldEntities = _this.fieldEntities.filter(function (item) {
            return item !== entity;
          });

          // Clean up store value if not preserve
          if (!_this.isMergedPreserve(preserve) && (!isListField || subNamePath.length > 1)) {
            var defaultValue = isListField ? undefined : _this.getInitialValue(namePath);
            if (namePath.length && _this.getFieldValue(namePath) !== defaultValue && _this.fieldEntities.every(function (field) {
              return (
                // Only reset when no namePath exist
                !matchNamePath(field.getNamePath(), namePath)
              );
            })) {
              var _prevStore = _this.store;
              _this.updateStore(set(_prevStore, namePath, defaultValue, true));

              // Notify that field is unmount
              _this.notifyObservers(_prevStore, [namePath], {
                type: 'remove'
              });

              // Dependencies update
              _this.triggerDependenciesUpdate(_prevStore, namePath);
            }
          }
          _this.notifyWatch([namePath]);
        };
      });
      _defineProperty(this, "dispatch", function (action) {
        switch (action.type) {
          case 'updateValue':
            {
              var namePath = action.namePath,
                value = action.value;
              _this.updateValue(namePath, value);
              break;
            }
          case 'validateField':
            {
              var _namePath = action.namePath,
                triggerName = action.triggerName;
              _this.validateFields([_namePath], {
                triggerName: triggerName
              });
              break;
            }
          // Currently we don't have other action. Do nothing.
        }
      });
      _defineProperty(this, "notifyObservers", function (prevStore, namePathList, info) {
        if (_this.subscribable) {
          var mergedInfo = _objectSpread2(_objectSpread2({}, info), {}, {
            store: _this.getFieldsValue(true)
          });
          _this.getFieldEntities().forEach(function (_ref5) {
            var onStoreChange = _ref5.onStoreChange;
            onStoreChange(prevStore, namePathList, mergedInfo);
          });
        } else {
          _this.forceRootUpdate();
        }
      });
      /**
       * Notify dependencies children with parent update
       * We need delay to trigger validate in case Field is under render props
       */
      _defineProperty(this, "triggerDependenciesUpdate", function (prevStore, namePath) {
        var childrenFields = _this.getDependencyChildrenFields(namePath);
        if (childrenFields.length) {
          _this.validateFields(childrenFields);
        }
        _this.notifyObservers(prevStore, childrenFields, {
          type: 'dependenciesUpdate',
          relatedFields: [namePath].concat(_toConsumableArray(childrenFields))
        });
        return childrenFields;
      });
      _defineProperty(this, "updateValue", function (name, value) {
        var namePath = getNamePath(name);
        var prevStore = _this.store;
        _this.updateStore(set(_this.store, namePath, value));
        _this.notifyObservers(prevStore, [namePath], {
          type: 'valueUpdate',
          source: 'internal'
        });
        _this.notifyWatch([namePath]);

        // Dependencies update
        var childrenFields = _this.triggerDependenciesUpdate(prevStore, namePath);

        // trigger callback function
        var onValuesChange = _this.callbacks.onValuesChange;
        if (onValuesChange) {
          var changedValues = cloneByNamePathList(_this.store, [namePath]);
          onValuesChange(changedValues, _this.getFieldsValue());
        }
        _this.triggerOnFieldsChange([namePath].concat(_toConsumableArray(childrenFields)));
      });
      // Let all child Field get update.
      _defineProperty(this, "setFieldsValue", function (store) {
        _this.warningUnhooked();
        var prevStore = _this.store;
        if (store) {
          var nextStore = merge$2(_this.store, store);
          _this.updateStore(nextStore);
        }
        _this.notifyObservers(prevStore, null, {
          type: 'valueUpdate',
          source: 'external'
        });
        _this.notifyWatch();
      });
      _defineProperty(this, "setFieldValue", function (name, value) {
        _this.setFields([{
          name: name,
          value: value,
          errors: [],
          warnings: []
        }]);
      });
      _defineProperty(this, "getDependencyChildrenFields", function (rootNamePath) {
        var children = new Set();
        var childrenFields = [];
        var dependencies2fields = new NameMap();

        /**
         * Generate maps
         * Can use cache to save perf if user report performance issue with this
         */
        _this.getFieldEntities().forEach(function (field) {
          var dependencies = field.props.dependencies;
          (dependencies || []).forEach(function (dependency) {
            var dependencyNamePath = getNamePath(dependency);
            dependencies2fields.update(dependencyNamePath, function () {
              var fields = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Set();
              fields.add(field);
              return fields;
            });
          });
        });
        var fillChildren = function fillChildren(namePath) {
          var fields = dependencies2fields.get(namePath) || new Set();
          fields.forEach(function (field) {
            if (!children.has(field)) {
              children.add(field);
              var fieldNamePath = field.getNamePath();
              if (field.isFieldDirty() && fieldNamePath.length) {
                childrenFields.push(fieldNamePath);
                fillChildren(fieldNamePath);
              }
            }
          });
        };
        fillChildren(rootNamePath);
        return childrenFields;
      });
      _defineProperty(this, "triggerOnFieldsChange", function (namePathList, filedErrors) {
        var onFieldsChange = _this.callbacks.onFieldsChange;
        if (onFieldsChange) {
          var fields = _this.getFields();

          /**
           * Fill errors since `fields` may be replaced by controlled fields
           */
          if (filedErrors) {
            var cache = new NameMap();
            filedErrors.forEach(function (_ref6) {
              var name = _ref6.name,
                errors = _ref6.errors;
              cache.set(name, errors);
            });
            fields.forEach(function (field) {
              // eslint-disable-next-line no-param-reassign
              field.errors = cache.get(field.name) || field.errors;
            });
          }
          var changedFields = fields.filter(function (_ref7) {
            var fieldName = _ref7.name;
            return containsNamePath(namePathList, fieldName);
          });
          if (changedFields.length) {
            onFieldsChange(changedFields, fields);
          }
        }
      });
      // =========================== Validate ===========================
      _defineProperty(this, "validateFields", function (arg1, arg2) {
        _this.warningUnhooked();
        var nameList;
        var options;
        if (Array.isArray(arg1) || typeof arg1 === 'string' || typeof arg2 === 'string') {
          nameList = arg1;
          options = arg2;
        } else {
          options = arg1;
        }
        var provideNameList = !!nameList;
        var namePathList = provideNameList ? nameList.map(getNamePath) : [];

        // Collect result in promise list
        var promiseList = [];

        // We temp save the path which need trigger for `onFieldsChange`
        var TMP_SPLIT = String(Date.now());
        var validateNamePathList = new Set();
        var _ref8 = options || {},
          recursive = _ref8.recursive,
          dirty = _ref8.dirty;
        _this.getFieldEntities(true).forEach(function (field) {
          // Add field if not provide `nameList`
          if (!provideNameList) {
            namePathList.push(field.getNamePath());
          }

          // Skip if without rule
          if (!field.props.rules || !field.props.rules.length) {
            return;
          }

          // Skip if only validate dirty field
          if (dirty && !field.isFieldDirty()) {
            return;
          }
          var fieldNamePath = field.getNamePath();
          validateNamePathList.add(fieldNamePath.join(TMP_SPLIT));

          // Add field validate rule in to promise list
          if (!provideNameList || containsNamePath(namePathList, fieldNamePath, recursive)) {
            var promise = field.validateRules(_objectSpread2({
              validateMessages: _objectSpread2(_objectSpread2({}, defaultValidateMessages), _this.validateMessages)
            }, options));

            // Wrap promise with field
            promiseList.push(promise.then(function () {
              return {
                name: fieldNamePath,
                errors: [],
                warnings: []
              };
            }).catch(function (ruleErrors) {
              var _ruleErrors$forEach;
              var mergedErrors = [];
              var mergedWarnings = [];
              (_ruleErrors$forEach = ruleErrors.forEach) === null || _ruleErrors$forEach === void 0 || _ruleErrors$forEach.call(ruleErrors, function (_ref9) {
                var warningOnly = _ref9.rule.warningOnly,
                  errors = _ref9.errors;
                if (warningOnly) {
                  mergedWarnings.push.apply(mergedWarnings, _toConsumableArray(errors));
                } else {
                  mergedErrors.push.apply(mergedErrors, _toConsumableArray(errors));
                }
              });
              if (mergedErrors.length) {
                return Promise.reject({
                  name: fieldNamePath,
                  errors: mergedErrors,
                  warnings: mergedWarnings
                });
              }
              return {
                name: fieldNamePath,
                errors: mergedErrors,
                warnings: mergedWarnings
              };
            }));
          }
        });
        var summaryPromise = allPromiseFinish(promiseList);
        _this.lastValidatePromise = summaryPromise;

        // Notify fields with rule that validate has finished and need update
        summaryPromise.catch(function (results) {
          return results;
        }).then(function (results) {
          var resultNamePathList = results.map(function (_ref10) {
            var name = _ref10.name;
            return name;
          });
          _this.notifyObservers(_this.store, resultNamePathList, {
            type: 'validateFinish'
          });
          _this.triggerOnFieldsChange(resultNamePathList, results);
        });
        var returnPromise = summaryPromise.then(function () {
          if (_this.lastValidatePromise === summaryPromise) {
            return Promise.resolve(_this.getFieldsValue(namePathList));
          }
          return Promise.reject([]);
        }).catch(function (results) {
          var errorList = results.filter(function (result) {
            return result && result.errors.length;
          });
          return Promise.reject({
            values: _this.getFieldsValue(namePathList),
            errorFields: errorList,
            outOfDate: _this.lastValidatePromise !== summaryPromise
          });
        });

        // Do not throw in console
        returnPromise.catch(function (e) {
          return e;
        });

        // `validating` changed. Trigger `onFieldsChange`
        var triggerNamePathList = namePathList.filter(function (namePath) {
          return validateNamePathList.has(namePath.join(TMP_SPLIT));
        });
        _this.triggerOnFieldsChange(triggerNamePathList);
        return returnPromise;
      });
      // ============================ Submit ============================
      _defineProperty(this, "submit", function () {
        _this.warningUnhooked();
        _this.validateFields().then(function (values) {
          var onFinish = _this.callbacks.onFinish;
          if (onFinish) {
            try {
              onFinish(values);
            } catch (err) {
              // Should print error if user `onFinish` callback failed
              console.error(err);
            }
          }
        }).catch(function (e) {
          var onFinishFailed = _this.callbacks.onFinishFailed;
          if (onFinishFailed) {
            onFinishFailed(e);
          }
        });
      });
      this.forceRootUpdate = forceRootUpdate;
    });
    function useForm(form) {
      var formRef = reactExports.useRef();
      var _React$useState = reactExports.useState({}),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        forceUpdate = _React$useState2[1];
      if (!formRef.current) {
        if (form) {
          formRef.current = form;
        } else {
          // Create a new FormStore if not provided
          var forceReRender = function forceReRender() {
            forceUpdate({});
          };
          var formStore = new FormStore(forceReRender);
          formRef.current = formStore.getForm();
        }
      }
      return [formRef.current];
    }

    var FormContext = /*#__PURE__*/reactExports.createContext({
      triggerFormChange: function triggerFormChange() {},
      triggerFormFinish: function triggerFormFinish() {},
      registerForm: function registerForm() {},
      unregisterForm: function unregisterForm() {}
    });
    var FormProvider = function FormProvider(_ref) {
      var validateMessages = _ref.validateMessages,
        onFormChange = _ref.onFormChange,
        onFormFinish = _ref.onFormFinish,
        children = _ref.children;
      var formContext = reactExports.useContext(FormContext);
      var formsRef = reactExports.useRef({});
      return /*#__PURE__*/reactExports.createElement(FormContext.Provider, {
        value: _objectSpread2(_objectSpread2({}, formContext), {}, {
          validateMessages: _objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages),
          // =========================================================
          // =                  Global Form Control                  =
          // =========================================================
          triggerFormChange: function triggerFormChange(name, changedFields) {
            if (onFormChange) {
              onFormChange(name, {
                changedFields: changedFields,
                forms: formsRef.current
              });
            }
            formContext.triggerFormChange(name, changedFields);
          },
          triggerFormFinish: function triggerFormFinish(name, values) {
            if (onFormFinish) {
              onFormFinish(name, {
                values: values,
                forms: formsRef.current
              });
            }
            formContext.triggerFormFinish(name, values);
          },
          registerForm: function registerForm(name, form) {
            if (name) {
              formsRef.current = _objectSpread2(_objectSpread2({}, formsRef.current), {}, _defineProperty({}, name, form));
            }
            formContext.registerForm(name, form);
          },
          unregisterForm: function unregisterForm(name) {
            var newForms = _objectSpread2({}, formsRef.current);
            delete newForms[name];
            formsRef.current = newForms;
            formContext.unregisterForm(name);
          }
        })
      }, children);
    };

    var _excluded$4 = ["name", "initialValues", "fields", "form", "preserve", "children", "component", "validateMessages", "validateTrigger", "onValuesChange", "onFieldsChange", "onFinish", "onFinishFailed", "clearOnDestroy"];
    var Form = function Form(_ref, ref) {
      var name = _ref.name,
        initialValues = _ref.initialValues,
        fields = _ref.fields,
        form = _ref.form,
        preserve = _ref.preserve,
        children = _ref.children,
        _ref$component = _ref.component,
        Component = _ref$component === void 0 ? 'form' : _ref$component,
        validateMessages = _ref.validateMessages,
        _ref$validateTrigger = _ref.validateTrigger,
        validateTrigger = _ref$validateTrigger === void 0 ? 'onChange' : _ref$validateTrigger,
        onValuesChange = _ref.onValuesChange,
        _onFieldsChange = _ref.onFieldsChange,
        _onFinish = _ref.onFinish,
        onFinishFailed = _ref.onFinishFailed,
        clearOnDestroy = _ref.clearOnDestroy,
        restProps = _objectWithoutProperties(_ref, _excluded$4);
      var nativeElementRef = reactExports.useRef(null);
      var formContext = reactExports.useContext(FormContext);

      // We customize handle event since Context will makes all the consumer re-render:
      // https://reactjs.org/docs/context.html#contextprovider
      var _useForm = useForm(form),
        _useForm2 = _slicedToArray(_useForm, 1),
        formInstance = _useForm2[0];
      var _getInternalHooks = formInstance.getInternalHooks(HOOK_MARK),
        useSubscribe = _getInternalHooks.useSubscribe,
        setInitialValues = _getInternalHooks.setInitialValues,
        setCallbacks = _getInternalHooks.setCallbacks,
        setValidateMessages = _getInternalHooks.setValidateMessages,
        setPreserve = _getInternalHooks.setPreserve,
        destroyForm = _getInternalHooks.destroyForm;

      // Pass ref with form instance
      reactExports.useImperativeHandle(ref, function () {
        return _objectSpread2(_objectSpread2({}, formInstance), {}, {
          nativeElement: nativeElementRef.current
        });
      });

      // Register form into Context
      reactExports.useEffect(function () {
        formContext.registerForm(name, formInstance);
        return function () {
          formContext.unregisterForm(name);
        };
      }, [formContext, formInstance, name]);

      // Pass props to store
      setValidateMessages(_objectSpread2(_objectSpread2({}, formContext.validateMessages), validateMessages));
      setCallbacks({
        onValuesChange: onValuesChange,
        onFieldsChange: function onFieldsChange(changedFields) {
          formContext.triggerFormChange(name, changedFields);
          if (_onFieldsChange) {
            for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              rest[_key - 1] = arguments[_key];
            }
            _onFieldsChange.apply(void 0, [changedFields].concat(rest));
          }
        },
        onFinish: function onFinish(values) {
          formContext.triggerFormFinish(name, values);
          if (_onFinish) {
            _onFinish(values);
          }
        },
        onFinishFailed: onFinishFailed
      });
      setPreserve(preserve);

      // Set initial value, init store value when first mount
      var mountRef = reactExports.useRef(null);
      setInitialValues(initialValues, !mountRef.current);
      if (!mountRef.current) {
        mountRef.current = true;
      }
      reactExports.useEffect(function () {
        return function () {
          return destroyForm(clearOnDestroy);
        };
      },
      // eslint-disable-next-line react-hooks/exhaustive-deps
      []);

      // Prepare children by `children` type
      var childrenNode;
      var childrenRenderProps = typeof children === 'function';
      if (childrenRenderProps) {
        var _values = formInstance.getFieldsValue(true);
        childrenNode = children(_values, formInstance);
      } else {
        childrenNode = children;
      }

      // Not use subscribe when using render props
      useSubscribe(!childrenRenderProps);

      // Listen if fields provided. We use ref to save prev data here to avoid additional render
      var prevFieldsRef = reactExports.useRef();
      reactExports.useEffect(function () {
        if (!isSimilar(prevFieldsRef.current || [], fields || [])) {
          formInstance.setFields(fields || []);
        }
        prevFieldsRef.current = fields;
      }, [fields, formInstance]);
      var formContextValue = reactExports.useMemo(function () {
        return _objectSpread2(_objectSpread2({}, formInstance), {}, {
          validateTrigger: validateTrigger
        });
      }, [formInstance, validateTrigger]);
      var wrapperNode = /*#__PURE__*/reactExports.createElement(ListContext.Provider, {
        value: null
      }, /*#__PURE__*/reactExports.createElement(Context.Provider, {
        value: formContextValue
      }, childrenNode));
      if (Component === false) {
        return wrapperNode;
      }
      return /*#__PURE__*/reactExports.createElement(Component, _extends({}, restProps, {
        ref: nativeElementRef,
        onSubmit: function onSubmit(event) {
          event.preventDefault();
          event.stopPropagation();
          formInstance.submit();
        },
        onReset: function onReset(event) {
          var _restProps$onReset;
          event.preventDefault();
          formInstance.resetFields();
          (_restProps$onReset = restProps.onReset) === null || _restProps$onReset === void 0 || _restProps$onReset.call(restProps, event);
        }
      }), wrapperNode);
    };

    function stringify(value) {
      try {
        return JSON.stringify(value);
      } catch (err) {
        return Math.random();
      }
    }

    // ------- selector type -------

    // ------- selector type end -------

    function useWatch() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      var dependencies = args[0],
        _args$ = args[1],
        _form = _args$ === void 0 ? {} : _args$;
      var options = isFormInstance(_form) ? {
        form: _form
      } : _form;
      var form = options.form;
      var _useState = reactExports.useState(),
        _useState2 = _slicedToArray(_useState, 2),
        value = _useState2[0],
        setValue = _useState2[1];
      var valueStr = reactExports.useMemo(function () {
        return stringify(value);
      }, [value]);
      var valueStrRef = reactExports.useRef(valueStr);
      valueStrRef.current = valueStr;
      var fieldContext = reactExports.useContext(Context);
      var formInstance = form || fieldContext;
      var isValidForm = formInstance && formInstance._init;
      var namePath = getNamePath(dependencies);
      var namePathRef = reactExports.useRef(namePath);
      namePathRef.current = namePath;
      reactExports.useEffect(function () {
        // Skip if not exist form instance
        if (!isValidForm) {
          return;
        }
        var getFieldsValue = formInstance.getFieldsValue,
          getInternalHooks = formInstance.getInternalHooks;
        var _getInternalHooks = getInternalHooks(HOOK_MARK),
          registerWatch = _getInternalHooks.registerWatch;
        var getWatchValue = function getWatchValue(values, allValues) {
          var watchValue = options.preserve ? allValues : values;
          return typeof dependencies === 'function' ? dependencies(watchValue) : get(watchValue, namePathRef.current);
        };
        var cancelRegister = registerWatch(function (values, allValues) {
          var newValue = getWatchValue(values, allValues);
          var nextValueStr = stringify(newValue);

          // Compare stringify in case it's nest object
          if (valueStrRef.current !== nextValueStr) {
            valueStrRef.current = nextValueStr;
            setValue(newValue);
          }
        });

        // TODO: We can improve this perf in future
        var initialValue = getWatchValue(getFieldsValue(), getFieldsValue(true));

        // React 18 has the bug that will queue update twice even the value is not changed
        // ref: https://github.com/facebook/react/issues/27213
        if (value !== initialValue) {
          setValue(initialValue);
        }
        return cancelRegister;
      },
      // We do not need re-register since namePath content is the same
      // eslint-disable-next-line react-hooks/exhaustive-deps
      [isValidForm]);
      return value;
    }

    var InternalForm = /*#__PURE__*/reactExports.forwardRef(Form);
    var RefForm = InternalForm;
    RefForm.FormProvider = FormProvider;
    RefForm.Field = WrapperField;
    RefForm.List = List;
    RefForm.useForm = useForm;
    RefForm.useWatch = useWatch;

    const FormItemInputContext = /*#__PURE__*/reactExports.createContext({});
    const NoFormStyle = _ref => {
      let {
        children,
        status,
        override
      } = _ref;
      const formItemInputContext = reactExports.useContext(FormItemInputContext);
      const newFormItemInputContext = reactExports.useMemo(() => {
        const newContext = Object.assign({}, formItemInputContext);
        if (override) {
          delete newContext.isFormItemInput;
        }
        if (status) {
          delete newContext.status;
          delete newContext.hasFeedback;
          delete newContext.feedbackIcon;
        }
        return newContext;
      }, [status, override, formItemInputContext]);
      return /*#__PURE__*/reactExports.createElement(FormItemInputContext.Provider, {
        value: newFormItemInputContext
      }, children);
    };
    const VariantContext = /*#__PURE__*/reactExports.createContext(undefined);

    const ContextIsolator = props => {
      const {
        space,
        form,
        children
      } = props;
      if (children === undefined || children === null) {
        return null;
      }
      let result = children;
      if (form) {
        result = /*#__PURE__*/React.createElement(NoFormStyle, {
          override: true,
          status: true
        }, result);
      }
      if (space) {
        result = /*#__PURE__*/React.createElement(NoCompactStyle, null, result);
      }
      return result;
    };

    const AppConfigContext = /*#__PURE__*/React.createContext({});

    function getStatusClassNames(prefixCls, status, hasFeedback) {
      return classNames({
        [`${prefixCls}-status-success`]: status === 'success',
        [`${prefixCls}-status-warning`]: status === 'warning',
        [`${prefixCls}-status-error`]: status === 'error',
        [`${prefixCls}-status-validating`]: status === 'validating',
        [`${prefixCls}-has-feedback`]: hasFeedback
      });
    }
    const getMergedStatus = (contextStatus, customStatus) => customStatus || contextStatus;

    /**
     * Compatible for legacy `bordered` prop.
     */
    const useVariant = function (component, variant) {
      let legacyBordered = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;
      var _a, _b;
      const {
        variant: configVariant,
        [component]: componentConfig
      } = reactExports.useContext(ConfigContext);
      const ctxVariant = reactExports.useContext(VariantContext);
      const configComponentVariant = componentConfig === null || componentConfig === void 0 ? void 0 : componentConfig.variant;
      let mergedVariant;
      if (typeof variant !== 'undefined') {
        mergedVariant = variant;
      } else if (legacyBordered === false) {
        mergedVariant = 'borderless';
      } else {
        // form variant > component global variant > global variant
        mergedVariant = (_b = (_a = ctxVariant !== null && ctxVariant !== void 0 ? ctxVariant : configComponentVariant) !== null && _a !== void 0 ? _a : configVariant) !== null && _b !== void 0 ? _b : 'outlined';
      }
      const enableVariantCls = Variants.includes(mergedVariant);
      return [mergedVariant, enableVariantCls];
    };

    // This icon file is generated automatically.
    var SearchOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M909.6 854.5L649.9 594.8C690.2 542.7 712 479 712 412c0-80.2-31.3-155.4-87.9-212.1-56.6-56.7-132-87.9-212.1-87.9s-155.5 31.3-212.1 87.9C143.2 256.5 112 331.8 112 412c0 80.1 31.3 155.5 87.9 212.1C256.5 680.8 331.8 712 412 712c67 0 130.6-21.8 182.7-62l259.7 259.6a8.2 8.2 0 0011.6 0l43.6-43.5a8.2 8.2 0 000-11.6zM570.4 570.4C528 612.7 471.8 636 412 636s-116-23.3-158.4-65.6C211.3 528 188 471.8 188 412s23.3-116.1 65.6-158.4C296 211.3 352.2 188 412 188s116.1 23.2 158.4 65.6S636 352.2 636 412s-23.3 116.1-65.6 158.4z" } }] }, "name": "search", "theme": "outlined" };

    var SearchOutlined = function SearchOutlined(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: SearchOutlined$1
      }));
    };

    /**![search](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTkwOS42IDg1NC41TDY0OS45IDU5NC44QzY5MC4yIDU0Mi43IDcxMiA0NzkgNzEyIDQxMmMwLTgwLjItMzEuMy0xNTUuNC04Ny45LTIxMi4xLTU2LjYtNTYuNy0xMzItODcuOS0yMTIuMS04Ny45cy0xNTUuNSAzMS4zLTIxMi4xIDg3LjlDMTQzLjIgMjU2LjUgMTEyIDMzMS44IDExMiA0MTJjMCA4MC4xIDMxLjMgMTU1LjUgODcuOSAyMTIuMUMyNTYuNSA2ODAuOCAzMzEuOCA3MTIgNDEyIDcxMmM2NyAwIDEzMC42LTIxLjggMTgyLjctNjJsMjU5LjcgMjU5LjZhOC4yIDguMiAwIDAwMTEuNiAwbDQzLjYtNDMuNWE4LjIgOC4yIDAgMDAwLTExLjZ6TTU3MC40IDU3MC40QzUyOCA2MTIuNyA0NzEuOCA2MzYgNDEyIDYzNnMtMTE2LTIzLjMtMTU4LjQtNjUuNkMyMTEuMyA1MjggMTg4IDQ3MS44IDE4OCA0MTJzMjMuMy0xMTYuMSA2NS42LTE1OC40QzI5NiAyMTEuMyAzNTIuMiAxODggNDEyIDE4OHMxMTYuMSAyMy4yIDE1OC40IDY1LjZTNjM2IDM1Mi4yIDYzNiA0MTJzLTIzLjMgMTE2LjEtNjUuNiAxNTguNHoiIC8+PC9zdmc+) */
    var RefIcon$2 = /*#__PURE__*/reactExports.forwardRef(SearchOutlined);

    function initInputToken(token) {
      return merge$1(token, {
        inputAffixPadding: token.paddingXXS
      });
    }
    const initComponentToken = token => {
      const {
        controlHeight,
        fontSize,
        lineHeight,
        lineWidth,
        controlHeightSM,
        controlHeightLG,
        fontSizeLG,
        lineHeightLG,
        paddingSM,
        controlPaddingHorizontalSM,
        controlPaddingHorizontal,
        colorFillAlter,
        colorPrimaryHover,
        colorPrimary,
        controlOutlineWidth,
        controlOutline,
        colorErrorOutline,
        colorWarningOutline,
        colorBgContainer
      } = token;
      return {
        paddingBlock: Math.max(Math.round((controlHeight - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
        paddingBlockSM: Math.max(Math.round((controlHeightSM - fontSize * lineHeight) / 2 * 10) / 10 - lineWidth, 0),
        paddingBlockLG: Math.ceil((controlHeightLG - fontSizeLG * lineHeightLG) / 2 * 10) / 10 - lineWidth,
        paddingInline: paddingSM - lineWidth,
        paddingInlineSM: controlPaddingHorizontalSM - lineWidth,
        paddingInlineLG: controlPaddingHorizontal - lineWidth,
        addonBg: colorFillAlter,
        activeBorderColor: colorPrimary,
        hoverBorderColor: colorPrimaryHover,
        activeShadow: `0 0 0 ${controlOutlineWidth}px ${controlOutline}`,
        errorActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorErrorOutline}`,
        warningActiveShadow: `0 0 0 ${controlOutlineWidth}px ${colorWarningOutline}`,
        hoverBg: colorBgContainer,
        activeBg: colorBgContainer,
        inputFontSize: fontSize,
        inputFontSizeLG: fontSizeLG,
        inputFontSizeSM: fontSize
      };
    };

    const genHoverStyle = token => ({
      borderColor: token.hoverBorderColor,
      backgroundColor: token.hoverBg
    });
    const genDisabledStyle = token => ({
      color: token.colorTextDisabled,
      backgroundColor: token.colorBgContainerDisabled,
      borderColor: token.colorBorder,
      boxShadow: 'none',
      cursor: 'not-allowed',
      opacity: 1,
      'input[disabled], textarea[disabled]': {
        cursor: 'not-allowed'
      },
      '&:hover:not([disabled])': Object.assign({}, genHoverStyle(merge$1(token, {
        hoverBorderColor: token.colorBorder,
        hoverBg: token.colorBgContainerDisabled
      })))
    });
    /* ============== Outlined ============== */
    const genBaseOutlinedStyle = (token, options) => ({
      background: token.colorBgContainer,
      borderWidth: token.lineWidth,
      borderStyle: token.lineType,
      borderColor: options.borderColor,
      '&:hover': {
        borderColor: options.hoverBorderColor,
        backgroundColor: token.hoverBg
      },
      '&:focus, &:focus-within': {
        borderColor: options.activeBorderColor,
        boxShadow: options.activeShadow,
        outline: 0,
        backgroundColor: token.activeBg
      }
    });
    const genOutlinedStatusStyle = (token, options) => ({
      [`&${token.componentCls}-status-${options.status}:not(${token.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseOutlinedStyle(token, options)), {
        [`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: {
          color: options.affixColor
        }
      }),
      [`&${token.componentCls}-status-${options.status}${token.componentCls}-disabled`]: {
        borderColor: options.borderColor
      }
    });
    const genOutlinedStyle = (token, extraStyles) => ({
      '&-outlined': Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseOutlinedStyle(token, {
        borderColor: token.colorBorder,
        hoverBorderColor: token.hoverBorderColor,
        activeBorderColor: token.activeBorderColor,
        activeShadow: token.activeShadow
      })), {
        [`&${token.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token))
      }), genOutlinedStatusStyle(token, {
        status: 'error',
        borderColor: token.colorError,
        hoverBorderColor: token.colorErrorBorderHover,
        activeBorderColor: token.colorError,
        activeShadow: token.errorActiveShadow,
        affixColor: token.colorError
      })), genOutlinedStatusStyle(token, {
        status: 'warning',
        borderColor: token.colorWarning,
        hoverBorderColor: token.colorWarningBorderHover,
        activeBorderColor: token.colorWarning,
        activeShadow: token.warningActiveShadow,
        affixColor: token.colorWarning
      })), extraStyles)
    });
    const genOutlinedGroupStatusStyle = (token, options) => ({
      [`&${token.componentCls}-group-wrapper-status-${options.status}`]: {
        [`${token.componentCls}-group-addon`]: {
          borderColor: options.addonBorderColor,
          color: options.addonColor
        }
      }
    });
    const genOutlinedGroupStyle = token => ({
      '&-outlined': Object.assign(Object.assign(Object.assign({
        [`${token.componentCls}-group`]: {
          '&-addon': {
            background: token.addonBg,
            border: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
          },
          '&-addon:first-child': {
            borderInlineEnd: 0
          },
          '&-addon:last-child': {
            borderInlineStart: 0
          }
        }
      }, genOutlinedGroupStatusStyle(token, {
        status: 'error',
        addonBorderColor: token.colorError,
        addonColor: token.colorErrorText
      })), genOutlinedGroupStatusStyle(token, {
        status: 'warning',
        addonBorderColor: token.colorWarning,
        addonColor: token.colorWarningText
      })), {
        [`&${token.componentCls}-group-wrapper-disabled`]: {
          [`${token.componentCls}-group-addon`]: Object.assign({}, genDisabledStyle(token))
        }
      })
    });
    /* ============ Borderless ============ */
    const genBorderlessStyle = (token, extraStyles) => {
      const {
        componentCls
      } = token;
      return {
        '&-borderless': Object.assign({
          background: 'transparent',
          border: 'none',
          '&:focus, &:focus-within': {
            outline: 'none'
          },
          // >>>>> Disabled
          [`&${componentCls}-disabled, &[disabled]`]: {
            color: token.colorTextDisabled,
            cursor: 'not-allowed'
          },
          // >>>>> Status
          [`&${componentCls}-status-error`]: {
            '&, & input, & textarea': {
              color: token.colorError
            }
          },
          [`&${componentCls}-status-warning`]: {
            '&, & input, & textarea': {
              color: token.colorWarning
            }
          }
        }, extraStyles)
      };
    };
    /* ============== Filled ============== */
    const genBaseFilledStyle = (token, options) => ({
      background: options.bg,
      borderWidth: token.lineWidth,
      borderStyle: token.lineType,
      borderColor: 'transparent',
      'input&, & input, textarea&, & textarea': {
        color: options === null || options === void 0 ? void 0 : options.inputColor
      },
      '&:hover': {
        background: options.hoverBg
      },
      '&:focus, &:focus-within': {
        outline: 0,
        borderColor: options.activeBorderColor,
        backgroundColor: token.activeBg
      }
    });
    const genFilledStatusStyle = (token, options) => ({
      [`&${token.componentCls}-status-${options.status}:not(${token.componentCls}-disabled)`]: Object.assign(Object.assign({}, genBaseFilledStyle(token, options)), {
        [`${token.componentCls}-prefix, ${token.componentCls}-suffix`]: {
          color: options.affixColor
        }
      })
    });
    const genFilledStyle = (token, extraStyles) => ({
      '&-filled': Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, genBaseFilledStyle(token, {
        bg: token.colorFillTertiary,
        hoverBg: token.colorFillSecondary,
        activeBorderColor: token.activeBorderColor
      })), {
        [`&${token.componentCls}-disabled, &[disabled]`]: Object.assign({}, genDisabledStyle(token))
      }), genFilledStatusStyle(token, {
        status: 'error',
        bg: token.colorErrorBg,
        hoverBg: token.colorErrorBgHover,
        activeBorderColor: token.colorError,
        inputColor: token.colorErrorText,
        affixColor: token.colorError
      })), genFilledStatusStyle(token, {
        status: 'warning',
        bg: token.colorWarningBg,
        hoverBg: token.colorWarningBgHover,
        activeBorderColor: token.colorWarning,
        inputColor: token.colorWarningText,
        affixColor: token.colorWarning
      })), extraStyles)
    });
    const genFilledGroupStatusStyle = (token, options) => ({
      [`&${token.componentCls}-group-wrapper-status-${options.status}`]: {
        [`${token.componentCls}-group-addon`]: {
          background: options.addonBg,
          color: options.addonColor
        }
      }
    });
    const genFilledGroupStyle = token => ({
      '&-filled': Object.assign(Object.assign(Object.assign({
        [`${token.componentCls}-group`]: {
          '&-addon': {
            background: token.colorFillTertiary
          },
          [`${token.componentCls}-filled:not(:focus):not(:focus-within)`]: {
            '&:not(:first-child)': {
              borderInlineStart: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
            },
            '&:not(:last-child)': {
              borderInlineEnd: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorSplit}`
            }
          }
        }
      }, genFilledGroupStatusStyle(token, {
        status: 'error',
        addonBg: token.colorErrorBg,
        addonColor: token.colorErrorText
      })), genFilledGroupStatusStyle(token, {
        status: 'warning',
        addonBg: token.colorWarningBg,
        addonColor: token.colorWarningText
      })), {
        [`&${token.componentCls}-group-wrapper-disabled`]: {
          [`${token.componentCls}-group`]: {
            '&-addon': {
              background: token.colorFillTertiary,
              color: token.colorTextDisabled
            },
            '&-addon:first-child': {
              borderInlineStart: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
              borderTop: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
              borderBottom: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
            },
            '&-addon:last-child': {
              borderInlineEnd: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
              borderTop: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`,
              borderBottom: `${unit$1(token.lineWidth)} ${token.lineType} ${token.colorBorder}`
            }
          }
        }
      })
    });

    const genPlaceholderStyle = color => ({
      // Firefox
      '&::-moz-placeholder': {
        opacity: 1
      },
      '&::placeholder': {
        color,
        userSelect: 'none' // https://github.com/ant-design/ant-design/pull/32639
      },
      '&:placeholder-shown': {
        textOverflow: 'ellipsis'
      }
    });
    const genInputLargeStyle = token => {
      const {
        paddingBlockLG,
        lineHeightLG,
        borderRadiusLG,
        paddingInlineLG
      } = token;
      return {
        padding: `${unit$1(paddingBlockLG)} ${unit$1(paddingInlineLG)}`,
        fontSize: token.inputFontSizeLG,
        lineHeight: lineHeightLG,
        borderRadius: borderRadiusLG
      };
    };
    const genInputSmallStyle = token => ({
      padding: `${unit$1(token.paddingBlockSM)} ${unit$1(token.paddingInlineSM)}`,
      fontSize: token.inputFontSizeSM,
      borderRadius: token.borderRadiusSM
    });
    const genBasicInputStyle = token => Object.assign(Object.assign({
      position: 'relative',
      display: 'inline-block',
      width: '100%',
      minWidth: 0,
      padding: `${unit$1(token.paddingBlock)} ${unit$1(token.paddingInline)}`,
      color: token.colorText,
      fontSize: token.inputFontSize,
      lineHeight: token.lineHeight,
      borderRadius: token.borderRadius,
      transition: `all ${token.motionDurationMid}`
    }, genPlaceholderStyle(token.colorTextPlaceholder)), {
      // Reset height for `textarea`s
      'textarea&': {
        maxWidth: '100%',
        // prevent textarea resize from coming out of its container
        height: 'auto',
        minHeight: token.controlHeight,
        lineHeight: token.lineHeight,
        verticalAlign: 'bottom',
        transition: `all ${token.motionDurationSlow}, height 0s`,
        resize: 'vertical'
      },
      // Size
      '&-lg': Object.assign({}, genInputLargeStyle(token)),
      '&-sm': Object.assign({}, genInputSmallStyle(token)),
      // RTL
      '&-rtl, &-textarea-rtl': {
        direction: 'rtl'
      }
    });
    const genInputGroupStyle = token => {
      const {
        componentCls,
        antCls
      } = token;
      return {
        position: 'relative',
        display: 'table',
        width: '100%',
        borderCollapse: 'separate',
        borderSpacing: 0,
        // Undo padding and float of grid classes
        "&[class*='col-']": {
          paddingInlineEnd: token.paddingXS,
          '&:last-child': {
            paddingInlineEnd: 0
          }
        },
        // Sizing options
        [`&-lg ${componentCls}, &-lg > ${componentCls}-group-addon`]: Object.assign({}, genInputLargeStyle(token)),
        [`&-sm ${componentCls}, &-sm > ${componentCls}-group-addon`]: Object.assign({}, genInputSmallStyle(token)),
        // Fix https://github.com/ant-design/ant-design/issues/5754
        [`&-lg ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token.controlHeightLG
        },
        [`&-sm ${antCls}-select-single ${antCls}-select-selector`]: {
          height: token.controlHeightSM
        },
        [`> ${componentCls}`]: {
          display: 'table-cell',
          '&:not(:first-child):not(:last-child)': {
            borderRadius: 0
          }
        },
        [`${componentCls}-group`]: {
          '&-addon, &-wrap': {
            display: 'table-cell',
            width: 1,
            whiteSpace: 'nowrap',
            verticalAlign: 'middle',
            '&:not(:first-child):not(:last-child)': {
              borderRadius: 0
            }
          },
          '&-wrap > *': {
            display: 'block !important'
          },
          '&-addon': {
            position: 'relative',
            padding: `0 ${unit$1(token.paddingInline)}`,
            color: token.colorText,
            fontWeight: 'normal',
            fontSize: token.inputFontSize,
            textAlign: 'center',
            borderRadius: token.borderRadius,
            transition: `all ${token.motionDurationSlow}`,
            lineHeight: 1,
            // Reset Select's style in addon
            [`${antCls}-select`]: {
              margin: `${unit$1(token.calc(token.paddingBlock).add(1).mul(-1).equal())} ${unit$1(token.calc(token.paddingInline).mul(-1).equal())}`,
              [`&${antCls}-select-single:not(${antCls}-select-customize-input):not(${antCls}-pagination-size-changer)`]: {
                [`${antCls}-select-selector`]: {
                  backgroundColor: 'inherit',
                  border: `${unit$1(token.lineWidth)} ${token.lineType} transparent`,
                  boxShadow: 'none'
                }
              }
            },
            // https://github.com/ant-design/ant-design/issues/31333
            [`${antCls}-cascader-picker`]: {
              margin: `-9px ${unit$1(token.calc(token.paddingInline).mul(-1).equal())}`,
              backgroundColor: 'transparent',
              [`${antCls}-cascader-input`]: {
                textAlign: 'start',
                border: 0,
                boxShadow: 'none'
              }
            }
          }
        },
        [componentCls]: {
          width: '100%',
          marginBottom: 0,
          textAlign: 'inherit',
          '&:focus': {
            zIndex: 1,
            // Fix https://gw.alipayobjects.com/zos/rmsportal/DHNpoqfMXSfrSnlZvhsJ.png
            borderInlineEndWidth: 1
          },
          '&:hover': {
            zIndex: 1,
            borderInlineEndWidth: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          }
        },
        // Reset rounded corners
        [`> ${componentCls}:first-child, ${componentCls}-group-addon:first-child`]: {
          borderStartEndRadius: 0,
          borderEndEndRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}-affix-wrapper`]: {
          [`&:not(:first-child) ${componentCls}`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          },
          [`&:not(:last-child) ${componentCls}`]: {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0
          }
        },
        [`> ${componentCls}:last-child, ${componentCls}-group-addon:last-child`]: {
          borderStartStartRadius: 0,
          borderEndStartRadius: 0,
          // Reset Select's style in addon
          [`${antCls}-select ${antCls}-select-selector`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`${componentCls}-affix-wrapper`]: {
          '&:not(:last-child)': {
            borderStartEndRadius: 0,
            borderEndEndRadius: 0,
            [`${componentCls}-search &`]: {
              borderStartStartRadius: token.borderRadius,
              borderEndStartRadius: token.borderRadius
            }
          },
          [`&:not(:first-child), ${componentCls}-search &:not(:first-child)`]: {
            borderStartStartRadius: 0,
            borderEndStartRadius: 0
          }
        },
        [`&${componentCls}-group-compact`]: Object.assign(Object.assign({
          display: 'block'
        }, clearFix()), {
          [`${componentCls}-group-addon, ${componentCls}-group-wrap, > ${componentCls}`]: {
            '&:not(:first-child):not(:last-child)': {
              borderInlineEndWidth: token.lineWidth,
              '&:hover, &:focus': {
                zIndex: 1
              }
            }
          },
          '& > *': {
            display: 'inline-flex',
            float: 'none',
            verticalAlign: 'top',
            // https://github.com/ant-design/ant-design-pro/issues/139
            borderRadius: 0
          },
          [`
        & > ${componentCls}-affix-wrapper,
        & > ${componentCls}-number-affix-wrapper,
        & > ${antCls}-picker-range
      `]: {
            display: 'inline-flex'
          },
          '& > *:not(:last-child)': {
            marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal(),
            borderInlineEndWidth: token.lineWidth
          },
          // Undo float for .ant-input-group .ant-input
          [componentCls]: {
            float: 'none'
          },
          // reset border for Select, DatePicker, AutoComplete, Cascader, Mention, TimePicker, Input
          [`& > ${antCls}-select > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete ${componentCls},
      & > ${antCls}-cascader-picker ${componentCls},
      & > ${componentCls}-group-wrapper ${componentCls}`]: {
            borderInlineEndWidth: token.lineWidth,
            borderRadius: 0,
            '&:hover, &:focus': {
              zIndex: 1
            }
          },
          [`& > ${antCls}-select-focused`]: {
            zIndex: 1
          },
          // update z-index for arrow icon
          [`& > ${antCls}-select > ${antCls}-select-arrow`]: {
            zIndex: 1 // https://github.com/ant-design/ant-design/issues/20371
          },
          [`& > *:first-child,
      & > ${antCls}-select:first-child > ${antCls}-select-selector,
      & > ${antCls}-select-auto-complete:first-child ${componentCls},
      & > ${antCls}-cascader-picker:first-child ${componentCls}`]: {
            borderStartStartRadius: token.borderRadius,
            borderEndStartRadius: token.borderRadius
          },
          [`& > *:last-child,
      & > ${antCls}-select:last-child > ${antCls}-select-selector,
      & > ${antCls}-cascader-picker:last-child ${componentCls},
      & > ${antCls}-cascader-picker-focused:last-child ${componentCls}`]: {
            borderInlineEndWidth: token.lineWidth,
            borderStartEndRadius: token.borderRadius,
            borderEndEndRadius: token.borderRadius
          },
          // https://github.com/ant-design/ant-design/issues/12493
          [`& > ${antCls}-select-auto-complete ${componentCls}`]: {
            verticalAlign: 'top'
          },
          [`${componentCls}-group-wrapper + ${componentCls}-group-wrapper`]: {
            marginInlineStart: token.calc(token.lineWidth).mul(-1).equal(),
            [`${componentCls}-affix-wrapper`]: {
              borderRadius: 0
            }
          },
          [`${componentCls}-group-wrapper:not(:last-child)`]: {
            [`&${componentCls}-search > ${componentCls}-group`]: {
              [`& > ${componentCls}-group-addon > ${componentCls}-search-button`]: {
                borderRadius: 0
              },
              [`& > ${componentCls}`]: {
                borderStartStartRadius: token.borderRadius,
                borderStartEndRadius: 0,
                borderEndEndRadius: 0,
                borderEndStartRadius: token.borderRadius
              }
            }
          }
        })
      };
    };
    const genInputStyle = token => {
      const {
        componentCls,
        controlHeightSM,
        lineWidth,
        calc
      } = token;
      const FIXED_CHROME_COLOR_HEIGHT = 16;
      const colorSmallPadding = calc(controlHeightSM).sub(calc(lineWidth).mul(2)).sub(FIXED_CHROME_COLOR_HEIGHT).div(2).equal();
      return {
        [componentCls]: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, resetComponent(token)), genBasicInputStyle(token)), genOutlinedStyle(token)), genFilledStyle(token)), genBorderlessStyle(token)), {
          '&[type="color"]': {
            height: token.controlHeight,
            [`&${componentCls}-lg`]: {
              height: token.controlHeightLG
            },
            [`&${componentCls}-sm`]: {
              height: controlHeightSM,
              paddingTop: colorSmallPadding,
              paddingBottom: colorSmallPadding
            }
          },
          '&[type="search"]::-webkit-search-cancel-button, &[type="search"]::-webkit-search-decoration': {
            '-webkit-appearance': 'none'
          }
        })
      };
    };
    const genAllowClearStyle = token => {
      const {
        componentCls
      } = token;
      return {
        // ========================= Input =========================
        [`${componentCls}-clear-icon`]: {
          margin: 0,
          lineHeight: 0,
          color: token.colorTextQuaternary,
          fontSize: token.fontSizeIcon,
          verticalAlign: -1,
          // https://github.com/ant-design/ant-design/pull/18151
          // https://codesandbox.io/s/wizardly-sun-u10br
          cursor: 'pointer',
          transition: `color ${token.motionDurationSlow}`,
          border: 'none',
          outline: 'none',
          backgroundColor: 'transparent',
          '&:hover': {
            color: token.colorTextTertiary
          },
          '&:active': {
            color: token.colorText
          },
          '&-hidden': {
            visibility: 'hidden'
          },
          '&-has-suffix': {
            margin: `0 ${unit$1(token.inputAffixPadding)}`
          }
        }
      };
    };
    const genAffixStyle = token => {
      const {
        componentCls,
        inputAffixPadding,
        colorTextDescription,
        motionDurationSlow,
        colorIcon,
        colorIconHover,
        iconCls
      } = token;
      const affixCls = `${componentCls}-affix-wrapper`;
      const affixClsDisabled = `${componentCls}-affix-wrapper-disabled`;
      return {
        [affixCls]: Object.assign(Object.assign(Object.assign(Object.assign({}, genBasicInputStyle(token)), {
          display: 'inline-flex',
          [`&:not(${componentCls}-disabled):hover`]: {
            zIndex: 1,
            [`${componentCls}-search-with-button &`]: {
              zIndex: 0
            }
          },
          '&-focused, &:focus': {
            zIndex: 1
          },
          [`> input${componentCls}`]: {
            padding: 0
          },
          [`> input${componentCls}, > textarea${componentCls}`]: {
            fontSize: 'inherit',
            border: 'none',
            borderRadius: 0,
            outline: 'none',
            background: 'transparent',
            color: 'inherit',
            '&::-ms-reveal': {
              display: 'none'
            },
            '&:focus': {
              boxShadow: 'none !important'
            }
          },
          '&::before': {
            display: 'inline-block',
            width: 0,
            visibility: 'hidden',
            content: '"\\a0"'
          },
          [componentCls]: {
            '&-prefix, &-suffix': {
              display: 'flex',
              flex: 'none',
              alignItems: 'center',
              '> *:not(:last-child)': {
                marginInlineEnd: token.paddingXS
              }
            },
            '&-show-count-suffix': {
              color: colorTextDescription
            },
            '&-show-count-has-suffix': {
              marginInlineEnd: token.paddingXXS
            },
            '&-prefix': {
              marginInlineEnd: inputAffixPadding
            },
            '&-suffix': {
              marginInlineStart: inputAffixPadding
            }
          }
        }), genAllowClearStyle(token)), {
          // password
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: 'pointer',
            transition: `all ${motionDurationSlow}`,
            '&:hover': {
              color: colorIconHover
            }
          }
        }),
        [affixClsDisabled]: {
          // password disabled
          [`${iconCls}${componentCls}-password-icon`]: {
            color: colorIcon,
            cursor: 'not-allowed',
            '&:hover': {
              color: colorIcon
            }
          }
        }
      };
    };
    const genGroupStyle = token => {
      const {
        componentCls,
        borderRadiusLG,
        borderRadiusSM
      } = token;
      return {
        [`${componentCls}-group`]: Object.assign(Object.assign(Object.assign({}, resetComponent(token)), genInputGroupStyle(token)), {
          '&-rtl': {
            direction: 'rtl'
          },
          '&-wrapper': Object.assign(Object.assign(Object.assign({
            display: 'inline-block',
            width: '100%',
            textAlign: 'start',
            verticalAlign: 'top',
            '&-rtl': {
              direction: 'rtl'
            },
            // Size
            '&-lg': {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusLG,
                fontSize: token.inputFontSizeLG
              }
            },
            '&-sm': {
              [`${componentCls}-group-addon`]: {
                borderRadius: borderRadiusSM
              }
            }
          }, genOutlinedGroupStyle(token)), genFilledGroupStyle(token)), {
            // '&-disabled': {
            //   [`${componentCls}-group-addon`]: {
            //     ...genDisabledStyle(token),
            //   },
            // },
            // Fix the issue of using icons in Space Compact mode
            // https://github.com/ant-design/ant-design/issues/42122
            [`&:not(${componentCls}-compact-first-item):not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-first-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            },
            [`&:not(${componentCls}-compact-first-item)${componentCls}-compact-last-item`]: {
              [`${componentCls}, ${componentCls}-group-addon`]: {
                borderStartStartRadius: 0,
                borderEndStartRadius: 0
              }
            },
            // Fix the issue of input use show-count param in space compact mode
            // https://github.com/ant-design/ant-design/issues/46872
            [`&:not(${componentCls}-compact-last-item)${componentCls}-compact-item`]: {
              [`${componentCls}-affix-wrapper`]: {
                borderStartEndRadius: 0,
                borderEndEndRadius: 0
              }
            }
          })
        })
      };
    };
    const genSearchInputStyle = token => {
      const {
        componentCls,
        antCls
      } = token;
      const searchPrefixCls = `${componentCls}-search`;
      return {
        [searchPrefixCls]: {
          [componentCls]: {
            '&:hover, &:focus': {
              [`+ ${componentCls}-group-addon ${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                borderInlineStartColor: token.colorPrimaryHover
              }
            }
          },
          [`${componentCls}-affix-wrapper`]: {
            height: token.controlHeight,
            borderRadius: 0
          },
          // fix slight height diff in Firefox:
          // https://ant.design/components/auto-complete-cn/#auto-complete-demo-certain-category
          [`${componentCls}-lg`]: {
            lineHeight: token.calc(token.lineHeightLG).sub(0.0002).equal()
          },
          [`> ${componentCls}-group`]: {
            [`> ${componentCls}-group-addon:last-child`]: {
              insetInlineStart: -1,
              padding: 0,
              border: 0,
              [`${searchPrefixCls}-button`]: {
                // Fix https://github.com/ant-design/ant-design/issues/47150
                marginInlineEnd: -1,
                borderStartStartRadius: 0,
                borderEndStartRadius: 0,
                boxShadow: 'none'
              },
              [`${searchPrefixCls}-button:not(${antCls}-btn-primary)`]: {
                color: token.colorTextDescription,
                '&:hover': {
                  color: token.colorPrimaryHover
                },
                '&:active': {
                  color: token.colorPrimaryActive
                },
                [`&${antCls}-btn-loading::before`]: {
                  insetInlineStart: 0,
                  insetInlineEnd: 0,
                  insetBlockStart: 0,
                  insetBlockEnd: 0
                }
              }
            }
          },
          [`${searchPrefixCls}-button`]: {
            height: token.controlHeight,
            '&:hover, &:focus': {
              zIndex: 1
            }
          },
          '&-large': {
            [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
              height: token.controlHeightLG
            }
          },
          '&-small': {
            [`${componentCls}-affix-wrapper, ${searchPrefixCls}-button`]: {
              height: token.controlHeightSM
            }
          },
          '&-rtl': {
            direction: 'rtl'
          },
          // ===================== Compact Item Customized Styles =====================
          [`&${componentCls}-compact-item`]: {
            [`&:not(${componentCls}-compact-last-item)`]: {
              [`${componentCls}-group-addon`]: {
                [`${componentCls}-search-button`]: {
                  marginInlineEnd: token.calc(token.lineWidth).mul(-1).equal(),
                  borderRadius: 0
                }
              }
            },
            [`&:not(${componentCls}-compact-first-item)`]: {
              [`${componentCls},${componentCls}-affix-wrapper`]: {
                borderRadius: 0
              }
            },
            [`> ${componentCls}-group-addon ${componentCls}-search-button,
        > ${componentCls},
        ${componentCls}-affix-wrapper`]: {
              '&:hover, &:focus, &:active': {
                zIndex: 2
              }
            },
            [`> ${componentCls}-affix-wrapper-focused`]: {
              zIndex: 2
            }
          }
        }
      };
    };
    const genTextAreaStyle = token => {
      const {
        componentCls,
        paddingLG
      } = token;
      const textareaPrefixCls = `${componentCls}-textarea`;
      return {
        [textareaPrefixCls]: {
          position: 'relative',
          '&-show-count': {
            // https://github.com/ant-design/ant-design/issues/33049
            [`> ${componentCls}`]: {
              height: '100%'
            },
            [`${componentCls}-data-count`]: {
              position: 'absolute',
              bottom: token.calc(token.fontSize).mul(token.lineHeight).mul(-1).equal(),
              insetInlineEnd: 0,
              color: token.colorTextDescription,
              whiteSpace: 'nowrap',
              pointerEvents: 'none'
            }
          },
          [`
        &-allow-clear > ${componentCls},
        &-affix-wrapper${textareaPrefixCls}-has-feedback ${componentCls}
      `]: {
            paddingInlineEnd: paddingLG
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper`]: {
            padding: 0,
            [`> textarea${componentCls}`]: {
              fontSize: 'inherit',
              border: 'none',
              outline: 'none',
              background: 'transparent',
              '&:focus': {
                boxShadow: 'none !important'
              }
            },
            [`${componentCls}-suffix`]: {
              margin: 0,
              '> *:not(:last-child)': {
                marginInline: 0
              },
              // Clear Icon
              [`${componentCls}-clear-icon`]: {
                position: 'absolute',
                insetInlineEnd: token.paddingInline,
                insetBlockStart: token.paddingXS
              },
              // Feedback Icon
              [`${textareaPrefixCls}-suffix`]: {
                position: 'absolute',
                top: 0,
                insetInlineEnd: token.paddingInline,
                bottom: 0,
                zIndex: 1,
                display: 'inline-flex',
                alignItems: 'center',
                margin: 'auto',
                pointerEvents: 'none'
              }
            }
          },
          [`&-affix-wrapper${componentCls}-affix-wrapper-sm`]: {
            [`${componentCls}-suffix`]: {
              [`${componentCls}-clear-icon`]: {
                insetInlineEnd: token.paddingInlineSM
              }
            }
          }
        }
      };
    };
    // ============================== Range ===============================
    const genRangeStyle = token => {
      const {
        componentCls
      } = token;
      return {
        [`${componentCls}-out-of-range`]: {
          [`&, & input, & textarea, ${componentCls}-show-count-suffix, ${componentCls}-data-count`]: {
            color: token.colorError
          }
        }
      };
    };
    // ============================== Export ==============================
    var useStyle$2 = genStyleHooks('Input', token => {
      const inputToken = merge$1(token, initInputToken(token));
      return [genInputStyle(inputToken), genTextAreaStyle(inputToken), genAffixStyle(inputToken), genGroupStyle(inputToken), genSearchInputStyle(inputToken), genRangeStyle(inputToken),
      // =====================================================
      // ==             Space Compact                       ==
      // =====================================================
      genCompactItemStyle(inputToken)];
    }, initComponentToken, {
      resetFont: false
    });

    function hasAddon(props) {
      return !!(props.addonBefore || props.addonAfter);
    }
    function hasPrefixSuffix$1(props) {
      return !!(props.prefix || props.suffix || props.allowClear);
    }

    // TODO: It's better to use `Proxy` replace the `element.value`. But we still need support IE11.
    function cloneEvent(event, target, value) {
      // A bug report filed on WebKit's Bugzilla tracker, dating back to 2009, specifically addresses the issue of cloneNode() not copying files of <input type="file"> elements.
      // As of the last update, this bug was still marked as "NEW," indicating that it might not have been resolved yet.
      // https://bugs.webkit.org/show_bug.cgi?id=28123
      var currentTarget = target.cloneNode(true);

      // click clear icon
      var newEvent = Object.create(event, {
        target: {
          value: currentTarget
        },
        currentTarget: {
          value: currentTarget
        }
      });

      // Fill data
      currentTarget.value = value;

      // Fill selection. Some type like `email` not support selection
      // https://github.com/ant-design/ant-design/issues/47833
      if (typeof target.selectionStart === 'number' && typeof target.selectionEnd === 'number') {
        currentTarget.selectionStart = target.selectionStart;
        currentTarget.selectionEnd = target.selectionEnd;
      }
      currentTarget.setSelectionRange = function () {
        target.setSelectionRange.apply(target, arguments);
      };
      return newEvent;
    }
    function resolveOnChange(target, e, onChange, targetValue) {
      if (!onChange) {
        return;
      }
      var event = e;
      if (e.type === 'click') {
        // Clone a new target for event.
        // Avoid the following usage, the setQuery method gets the original value.
        //
        // const [query, setQuery] = React.useState('');
        // <Input
        //   allowClear
        //   value={query}
        //   onChange={(e)=> {
        //     setQuery((prevStatus) => e.target.value);
        //   }}
        // />

        event = cloneEvent(e, target, '');
        onChange(event);
        return;
      }

      // Trigger by composition event, this means we need force change the input value
      // https://github.com/ant-design/ant-design/issues/45737
      // https://github.com/ant-design/ant-design/issues/46598
      if (target.type !== 'file' && targetValue !== undefined) {
        event = cloneEvent(e, target, targetValue);
        onChange(event);
        return;
      }
      onChange(event);
    }
    function triggerFocus(element, option) {
      if (!element) return;
      element.focus(option);

      // Selection content
      var _ref = option || {},
        cursor = _ref.cursor;
      if (cursor) {
        var len = element.value.length;
        switch (cursor) {
          case 'start':
            element.setSelectionRange(0, 0);
            break;
          case 'end':
            element.setSelectionRange(len, len);
            break;
          default:
            element.setSelectionRange(0, len);
        }
      }
    }

    var BaseInput = /*#__PURE__*/React.forwardRef(function (props, ref) {
      var _props, _props2, _props3;
      var inputEl = props.inputElement,
        children = props.children,
        prefixCls = props.prefixCls,
        prefix = props.prefix,
        suffix = props.suffix,
        addonBefore = props.addonBefore,
        addonAfter = props.addonAfter,
        className = props.className,
        style = props.style,
        disabled = props.disabled,
        readOnly = props.readOnly,
        focused = props.focused,
        triggerFocus = props.triggerFocus,
        allowClear = props.allowClear,
        value = props.value,
        handleReset = props.handleReset,
        hidden = props.hidden,
        classes = props.classes,
        classNames$1 = props.classNames,
        dataAttrs = props.dataAttrs,
        styles = props.styles,
        components = props.components,
        onClear = props.onClear;
      var inputElement = children !== null && children !== void 0 ? children : inputEl;
      var AffixWrapperComponent = (components === null || components === void 0 ? void 0 : components.affixWrapper) || 'span';
      var GroupWrapperComponent = (components === null || components === void 0 ? void 0 : components.groupWrapper) || 'span';
      var WrapperComponent = (components === null || components === void 0 ? void 0 : components.wrapper) || 'span';
      var GroupAddonComponent = (components === null || components === void 0 ? void 0 : components.groupAddon) || 'span';
      var containerRef = reactExports.useRef(null);
      var onInputClick = function onInputClick(e) {
        var _containerRef$current;
        if ((_containerRef$current = containerRef.current) !== null && _containerRef$current !== void 0 && _containerRef$current.contains(e.target)) {
          triggerFocus === null || triggerFocus === void 0 || triggerFocus();
        }
      };
      var hasAffix = hasPrefixSuffix$1(props);
      var element = /*#__PURE__*/reactExports.cloneElement(inputElement, {
        value: value,
        className: classNames((_props = inputElement.props) === null || _props === void 0 ? void 0 : _props.className, !hasAffix && (classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.variant)) || null
      });

      // ======================== Ref ======================== //
      var groupRef = reactExports.useRef(null);
      React.useImperativeHandle(ref, function () {
        return {
          nativeElement: groupRef.current || containerRef.current
        };
      });

      // ================== Prefix & Suffix ================== //
      if (hasAffix) {
        // ================== Clear Icon ================== //
        var clearIcon = null;
        if (allowClear) {
          var needClear = !disabled && !readOnly && value;
          var clearIconCls = "".concat(prefixCls, "-clear-icon");
          var iconNode = _typeof(allowClear) === 'object' && allowClear !== null && allowClear !== void 0 && allowClear.clearIcon ? allowClear.clearIcon : '';
          clearIcon = /*#__PURE__*/React.createElement("button", {
            type: "button",
            onClick: function onClick(event) {
              handleReset === null || handleReset === void 0 || handleReset(event);
              onClear === null || onClear === void 0 || onClear();
            }
            // Do not trigger onBlur when clear input
            // https://github.com/ant-design/ant-design/issues/31200
            ,
            onMouseDown: function onMouseDown(e) {
              return e.preventDefault();
            },
            className: classNames(clearIconCls, _defineProperty(_defineProperty({}, "".concat(clearIconCls, "-hidden"), !needClear), "".concat(clearIconCls, "-has-suffix"), !!suffix))
          }, iconNode);
        }
        var affixWrapperPrefixCls = "".concat(prefixCls, "-affix-wrapper");
        var affixWrapperCls = classNames(affixWrapperPrefixCls, _defineProperty(_defineProperty(_defineProperty(_defineProperty(_defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-disabled"), disabled), "".concat(affixWrapperPrefixCls, "-focused"), focused), "".concat(affixWrapperPrefixCls, "-readonly"), readOnly), "".concat(affixWrapperPrefixCls, "-input-with-clear-btn"), suffix && allowClear && value), classes === null || classes === void 0 ? void 0 : classes.affixWrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.affixWrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.variant);
        var suffixNode = (suffix || allowClear) && /*#__PURE__*/React.createElement("span", {
          className: classNames("".concat(prefixCls, "-suffix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.suffix),
          style: styles === null || styles === void 0 ? void 0 : styles.suffix
        }, clearIcon, suffix);
        element = /*#__PURE__*/React.createElement(AffixWrapperComponent, _extends({
          className: affixWrapperCls,
          style: styles === null || styles === void 0 ? void 0 : styles.affixWrapper,
          onClick: onInputClick
        }, dataAttrs === null || dataAttrs === void 0 ? void 0 : dataAttrs.affixWrapper, {
          ref: containerRef
        }), prefix && /*#__PURE__*/React.createElement("span", {
          className: classNames("".concat(prefixCls, "-prefix"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.prefix),
          style: styles === null || styles === void 0 ? void 0 : styles.prefix
        }, prefix), element, suffixNode);
      }

      // ================== Addon ================== //
      if (hasAddon(props)) {
        var wrapperCls = "".concat(prefixCls, "-group");
        var addonCls = "".concat(wrapperCls, "-addon");
        var groupWrapperCls = "".concat(wrapperCls, "-wrapper");
        var mergedWrapperClassName = classNames("".concat(prefixCls, "-wrapper"), wrapperCls, classes === null || classes === void 0 ? void 0 : classes.wrapper, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.wrapper);
        var mergedGroupClassName = classNames(groupWrapperCls, _defineProperty({}, "".concat(groupWrapperCls, "-disabled"), disabled), classes === null || classes === void 0 ? void 0 : classes.group, classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.groupWrapper);

        // Need another wrapper for changing display:table to display:inline-block
        // and put style prop in wrapper
        element = /*#__PURE__*/React.createElement(GroupWrapperComponent, {
          className: mergedGroupClassName,
          ref: groupRef
        }, /*#__PURE__*/React.createElement(WrapperComponent, {
          className: mergedWrapperClassName
        }, addonBefore && /*#__PURE__*/React.createElement(GroupAddonComponent, {
          className: addonCls
        }, addonBefore), element, addonAfter && /*#__PURE__*/React.createElement(GroupAddonComponent, {
          className: addonCls
        }, addonAfter)));
      }

      // `className` and `style` are always on the root element
      return /*#__PURE__*/React.cloneElement(element, {
        className: classNames((_props2 = element.props) === null || _props2 === void 0 ? void 0 : _props2.className, className) || null,
        style: _objectSpread2(_objectSpread2({}, (_props3 = element.props) === null || _props3 === void 0 ? void 0 : _props3.style), style),
        hidden: hidden
      });
    });

    var _excluded$3 = ["show"];
    function useCount(count, showCount) {
      return reactExports.useMemo(function () {
        var mergedConfig = {};
        if (showCount) {
          mergedConfig.show = _typeof(showCount) === 'object' && showCount.formatter ? showCount.formatter : !!showCount;
        }
        mergedConfig = _objectSpread2(_objectSpread2({}, mergedConfig), count);
        var _ref = mergedConfig,
          show = _ref.show,
          rest = _objectWithoutProperties(_ref, _excluded$3);
        return _objectSpread2(_objectSpread2({}, rest), {}, {
          show: !!show,
          showFormatter: typeof show === 'function' ? show : undefined,
          strategy: rest.strategy || function (value) {
            return value.length;
          }
        });
      }, [count, showCount]);
    }

    var _excluded$2 = ["autoComplete", "onChange", "onFocus", "onBlur", "onPressEnter", "onKeyDown", "onKeyUp", "prefixCls", "disabled", "htmlSize", "className", "maxLength", "suffix", "showCount", "count", "type", "classes", "classNames", "styles", "onCompositionStart", "onCompositionEnd"];
    var Input$2 = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
      var autoComplete = props.autoComplete,
        onChange = props.onChange,
        onFocus = props.onFocus,
        onBlur = props.onBlur,
        onPressEnter = props.onPressEnter,
        onKeyDown = props.onKeyDown,
        onKeyUp = props.onKeyUp,
        _props$prefixCls = props.prefixCls,
        prefixCls = _props$prefixCls === void 0 ? 'rc-input' : _props$prefixCls,
        disabled = props.disabled,
        htmlSize = props.htmlSize,
        className = props.className,
        maxLength = props.maxLength,
        suffix = props.suffix,
        showCount = props.showCount,
        count = props.count,
        _props$type = props.type,
        type = _props$type === void 0 ? 'text' : _props$type,
        classes = props.classes,
        classNames$1 = props.classNames,
        styles = props.styles,
        _onCompositionStart = props.onCompositionStart,
        onCompositionEnd = props.onCompositionEnd,
        rest = _objectWithoutProperties(props, _excluded$2);
      var _useState = reactExports.useState(false),
        _useState2 = _slicedToArray(_useState, 2),
        focused = _useState2[0],
        setFocused = _useState2[1];
      var compositionRef = reactExports.useRef(false);
      var keyLockRef = reactExports.useRef(false);
      var inputRef = reactExports.useRef(null);
      var holderRef = reactExports.useRef(null);
      var focus = function focus(option) {
        if (inputRef.current) {
          triggerFocus(inputRef.current, option);
        }
      };

      // ====================== Value =======================
      var _useMergedState = useMergedState(props.defaultValue, {
          value: props.value
        }),
        _useMergedState2 = _slicedToArray(_useMergedState, 2),
        value = _useMergedState2[0],
        setValue = _useMergedState2[1];
      var formatValue = value === undefined || value === null ? '' : String(value);

      // =================== Select Range ===================
      var _useState3 = reactExports.useState(null),
        _useState4 = _slicedToArray(_useState3, 2),
        selection = _useState4[0],
        setSelection = _useState4[1];

      // ====================== Count =======================
      var countConfig = useCount(count, showCount);
      var mergedMax = countConfig.max || maxLength;
      var valueLength = countConfig.strategy(formatValue);
      var isOutOfRange = !!mergedMax && valueLength > mergedMax;

      // ======================= Ref ========================
      reactExports.useImperativeHandle(ref, function () {
        var _holderRef$current;
        return {
          focus: focus,
          blur: function blur() {
            var _inputRef$current;
            (_inputRef$current = inputRef.current) === null || _inputRef$current === void 0 || _inputRef$current.blur();
          },
          setSelectionRange: function setSelectionRange(start, end, direction) {
            var _inputRef$current2;
            (_inputRef$current2 = inputRef.current) === null || _inputRef$current2 === void 0 || _inputRef$current2.setSelectionRange(start, end, direction);
          },
          select: function select() {
            var _inputRef$current3;
            (_inputRef$current3 = inputRef.current) === null || _inputRef$current3 === void 0 || _inputRef$current3.select();
          },
          input: inputRef.current,
          nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || inputRef.current
        };
      });
      reactExports.useEffect(function () {
        if (keyLockRef.current) {
          keyLockRef.current = false;
        }
        setFocused(function (prev) {
          return prev && disabled ? false : prev;
        });
      }, [disabled]);
      var triggerChange = function triggerChange(e, currentValue, info) {
        var cutValue = currentValue;
        if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
          cutValue = countConfig.exceedFormatter(currentValue, {
            max: countConfig.max
          });
          if (currentValue !== cutValue) {
            var _inputRef$current4, _inputRef$current5;
            setSelection([((_inputRef$current4 = inputRef.current) === null || _inputRef$current4 === void 0 ? void 0 : _inputRef$current4.selectionStart) || 0, ((_inputRef$current5 = inputRef.current) === null || _inputRef$current5 === void 0 ? void 0 : _inputRef$current5.selectionEnd) || 0]);
          }
        } else if (info.source === 'compositionEnd') {
          // Avoid triggering twice
          // https://github.com/ant-design/ant-design/issues/46587
          return;
        }
        setValue(cutValue);
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e, onChange, cutValue);
        }
      };
      reactExports.useEffect(function () {
        if (selection) {
          var _inputRef$current6;
          (_inputRef$current6 = inputRef.current) === null || _inputRef$current6 === void 0 || _inputRef$current6.setSelectionRange.apply(_inputRef$current6, _toConsumableArray(selection));
        }
      }, [selection]);
      var onInternalChange = function onInternalChange(e) {
        triggerChange(e, e.target.value, {
          source: 'change'
        });
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd(e) {
        compositionRef.current = false;
        triggerChange(e, e.currentTarget.value, {
          source: 'compositionEnd'
        });
        onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e);
      };
      var handleKeyDown = function handleKeyDown(e) {
        if (onPressEnter && e.key === 'Enter' && !keyLockRef.current) {
          keyLockRef.current = true;
          onPressEnter(e);
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
      };
      var handleKeyUp = function handleKeyUp(e) {
        if (e.key === 'Enter') {
          keyLockRef.current = false;
        }
        onKeyUp === null || onKeyUp === void 0 || onKeyUp(e);
      };
      var handleFocus = function handleFocus(e) {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus(e);
      };
      var handleBlur = function handleBlur(e) {
        if (keyLockRef.current) {
          keyLockRef.current = false;
        }
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur(e);
      };
      var handleReset = function handleReset(e) {
        setValue('');
        focus();
        if (inputRef.current) {
          resolveOnChange(inputRef.current, e, onChange);
        }
      };

      // ====================== Input =======================
      var outOfRangeCls = isOutOfRange && "".concat(prefixCls, "-out-of-range");
      var getInputElement = function getInputElement() {
        // Fix https://fb.me/react-unknown-prop
        var otherProps = omit(props, ['prefixCls', 'onPressEnter', 'addonBefore', 'addonAfter', 'prefix', 'suffix', 'allowClear',
        // Input elements must be either controlled or uncontrolled,
        // specify either the value prop, or the defaultValue prop, but not both.
        'defaultValue', 'showCount', 'count', 'classes', 'htmlSize', 'styles', 'classNames', 'onClear']);
        return /*#__PURE__*/React.createElement("input", _extends({
          autoComplete: autoComplete
        }, otherProps, {
          onChange: onInternalChange,
          onFocus: handleFocus,
          onBlur: handleBlur,
          onKeyDown: handleKeyDown,
          onKeyUp: handleKeyUp,
          className: classNames(prefixCls, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.input),
          style: styles === null || styles === void 0 ? void 0 : styles.input,
          ref: inputRef,
          size: htmlSize,
          type: type,
          onCompositionStart: function onCompositionStart(e) {
            compositionRef.current = true;
            _onCompositionStart === null || _onCompositionStart === void 0 || _onCompositionStart(e);
          },
          onCompositionEnd: onInternalCompositionEnd
        }));
      };
      var getSuffix = function getSuffix() {
        // Max length value
        var hasMaxLength = Number(mergedMax) > 0;
        if (suffix || countConfig.show) {
          var dataCount = countConfig.showFormatter ? countConfig.showFormatter({
            value: formatValue,
            count: valueLength,
            maxLength: mergedMax
          }) : "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : '');
          return /*#__PURE__*/React.createElement(React.Fragment, null, countConfig.show && /*#__PURE__*/React.createElement("span", {
            className: classNames("".concat(prefixCls, "-show-count-suffix"), _defineProperty({}, "".concat(prefixCls, "-show-count-has-suffix"), !!suffix), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
            style: _objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.count)
          }, dataCount), suffix);
        }
        return null;
      };

      // ====================== Render ======================
      return /*#__PURE__*/React.createElement(BaseInput, _extends({}, rest, {
        prefixCls: prefixCls,
        className: classNames(className, outOfRangeCls),
        handleReset: handleReset,
        value: formatValue,
        focused: focused,
        triggerFocus: focus,
        suffix: getSuffix(),
        disabled: disabled,
        classes: classes,
        classNames: classNames$1,
        styles: styles
      }), getInputElement());
    });

    const Group = props => {
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const {
        prefixCls: customizePrefixCls,
        className
      } = props;
      const prefixCls = getPrefixCls('input-group', customizePrefixCls);
      const inputPrefixCls = getPrefixCls('input');
      const [wrapCSSVar, hashId] = useStyle$2(inputPrefixCls);
      const cls = classNames(prefixCls, {
        [`${prefixCls}-lg`]: props.size === 'large',
        [`${prefixCls}-sm`]: props.size === 'small',
        [`${prefixCls}-compact`]: props.compact,
        [`${prefixCls}-rtl`]: direction === 'rtl'
      }, hashId, className);
      const formItemContext = reactExports.useContext(FormItemInputContext);
      const groupFormItemContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formItemContext), {
        isFormItemInput: false
      }), [formItemContext]);
      return wrapCSSVar(/*#__PURE__*/reactExports.createElement("span", {
        className: cls,
        style: props.style,
        onMouseEnter: props.onMouseEnter,
        onMouseLeave: props.onMouseLeave,
        onFocus: props.onFocus,
        onBlur: props.onBlur
      }, /*#__PURE__*/reactExports.createElement(FormItemInputContext.Provider, {
        value: groupFormItemContext
      }, props.children)));
    };

    const getAllowClear = allowClear => {
      let mergedAllowClear;
      if (typeof allowClear === 'object' && (allowClear === null || allowClear === void 0 ? void 0 : allowClear.clearIcon)) {
        mergedAllowClear = allowClear;
      } else if (allowClear) {
        mergedAllowClear = {
          clearIcon: /*#__PURE__*/React.createElement(RefIcon$7, null)
        };
      }
      return mergedAllowClear;
    };

    function useRemovePasswordTimeout(inputRef, triggerOnMount) {
      const removePasswordTimeoutRef = reactExports.useRef([]);
      const removePasswordTimeout = () => {
        removePasswordTimeoutRef.current.push(setTimeout(() => {
          var _a, _b, _c, _d;
          if (((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) && ((_b = inputRef.current) === null || _b === void 0 ? void 0 : _b.input.getAttribute('type')) === 'password' && ((_c = inputRef.current) === null || _c === void 0 ? void 0 : _c.input.hasAttribute('value'))) {
            (_d = inputRef.current) === null || _d === void 0 ? void 0 : _d.input.removeAttribute('value');
          }
        }));
      };
      reactExports.useEffect(() => {
        if (triggerOnMount) {
          removePasswordTimeout();
        }
        return () => removePasswordTimeoutRef.current.forEach(timer => {
          if (timer) {
            clearTimeout(timer);
          }
        });
      }, []);
      return removePasswordTimeout;
    }

    function hasPrefixSuffix(props) {
      return !!(props.prefix || props.suffix || props.allowClear || props.showCount);
    }

    var __rest$6 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const Input$1 = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      var _a;
      const {
          prefixCls: customizePrefixCls,
          bordered = true,
          status: customStatus,
          size: customSize,
          disabled: customDisabled,
          onBlur,
          onFocus,
          suffix,
          allowClear,
          addonAfter,
          addonBefore,
          className,
          style,
          styles,
          rootClassName,
          onChange,
          classNames: classes,
          variant: customVariant
        } = props,
        rest = __rest$6(props, ["prefixCls", "bordered", "status", "size", "disabled", "onBlur", "onFocus", "suffix", "allowClear", "addonAfter", "addonBefore", "className", "style", "styles", "rootClassName", "onChange", "classNames", "variant"]);
      const {
        getPrefixCls,
        direction,
        input
      } = React.useContext(ConfigContext);
      const prefixCls = getPrefixCls('input', customizePrefixCls);
      const inputRef = reactExports.useRef(null);
      // Style
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$2(prefixCls, rootCls);
      // ===================== Compact Item =====================
      const {
        compactSize,
        compactItemClassnames
      } = useCompactItemContext(prefixCls, direction);
      // ===================== Size =====================
      const mergedSize = useSize(ctx => {
        var _a;
        return (_a = customSize !== null && customSize !== void 0 ? customSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
      });
      // ===================== Disabled =====================
      const disabled = React.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      // ===================== Status =====================
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      // ===================== Focus warning =====================
      const inputHasPrefixSuffix = hasPrefixSuffix(props) || !!hasFeedback;
      reactExports.useRef(inputHasPrefixSuffix);
      /* eslint-enable */
      // ===================== Remove Password value =====================
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef, true);
      const handleBlur = e => {
        removePasswordTimeout();
        onBlur === null || onBlur === void 0 ? void 0 : onBlur(e);
      };
      const handleFocus = e => {
        removePasswordTimeout();
        onFocus === null || onFocus === void 0 ? void 0 : onFocus(e);
      };
      const handleChange = e => {
        removePasswordTimeout();
        onChange === null || onChange === void 0 ? void 0 : onChange(e);
      };
      const suffixNode = (hasFeedback || suffix) && (/*#__PURE__*/React.createElement(React.Fragment, null, suffix, hasFeedback && feedbackIcon));
      const mergedAllowClear = getAllowClear(allowClear !== null && allowClear !== void 0 ? allowClear : input === null || input === void 0 ? void 0 : input.allowClear);
      const [variant, enableVariantCls] = useVariant('input', customVariant, bordered);
      return wrapCSSVar(/*#__PURE__*/React.createElement(Input$2, Object.assign({
        ref: composeRef(ref, inputRef),
        prefixCls: prefixCls,
        autoComplete: input === null || input === void 0 ? void 0 : input.autoComplete
      }, rest, {
        disabled: mergedDisabled,
        onBlur: handleBlur,
        onFocus: handleFocus,
        style: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.style), style),
        styles: Object.assign(Object.assign({}, input === null || input === void 0 ? void 0 : input.styles), styles),
        suffix: suffixNode,
        allowClear: mergedAllowClear,
        className: classNames(className, rootClassName, cssVarCls, rootCls, compactItemClassnames, input === null || input === void 0 ? void 0 : input.className),
        onChange: handleChange,
        addonBefore: addonBefore && (/*#__PURE__*/React.createElement(ContextIsolator, {
          form: true,
          space: true
        }, addonBefore)),
        addonAfter: addonAfter && (/*#__PURE__*/React.createElement(ContextIsolator, {
          form: true,
          space: true
        }, addonAfter)),
        classNames: Object.assign(Object.assign(Object.assign({}, classes), input === null || input === void 0 ? void 0 : input.classNames), {
          input: classNames({
            [`${prefixCls}-sm`]: mergedSize === 'small',
            [`${prefixCls}-lg`]: mergedSize === 'large',
            [`${prefixCls}-rtl`]: direction === 'rtl'
          }, classes === null || classes === void 0 ? void 0 : classes.input, (_a = input === null || input === void 0 ? void 0 : input.classNames) === null || _a === void 0 ? void 0 : _a.input, hashId),
          variant: classNames({
            [`${prefixCls}-${variant}`]: enableVariantCls
          }, getStatusClassNames(prefixCls, mergedStatus)),
          affixWrapper: classNames({
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === 'small',
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === 'large',
            [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl'
          }, hashId),
          wrapper: classNames({
            [`${prefixCls}-group-rtl`]: direction === 'rtl'
          }, hashId),
          groupWrapper: classNames({
            [`${prefixCls}-group-wrapper-sm`]: mergedSize === 'small',
            [`${prefixCls}-group-wrapper-lg`]: mergedSize === 'large',
            [`${prefixCls}-group-wrapper-rtl`]: direction === 'rtl',
            [`${prefixCls}-group-wrapper-${variant}`]: enableVariantCls
          }, getStatusClassNames(`${prefixCls}-group-wrapper`, mergedStatus, hasFeedback), hashId)
        })
      })));
    });

    // =============================== OTP ================================
    const genOTPStyle = token => {
      const {
        componentCls,
        paddingXS
      } = token;
      return {
        [componentCls]: {
          display: 'inline-flex',
          alignItems: 'center',
          flexWrap: 'nowrap',
          columnGap: paddingXS,
          '&-rtl': {
            direction: 'rtl'
          },
          [`${componentCls}-input`]: {
            textAlign: 'center',
            paddingInline: token.paddingXXS
          },
          // ================= Size =================
          [`&${componentCls}-sm ${componentCls}-input`]: {
            paddingInline: token.calc(token.paddingXXS).div(2).equal()
          },
          [`&${componentCls}-lg ${componentCls}-input`]: {
            paddingInline: token.paddingXS
          }
        }
      };
    };
    // ============================== Export ==============================
    var useStyle$1 = genStyleHooks(['Input', 'OTP'], token => {
      const inputToken = merge$1(token, initInputToken(token));
      return [genOTPStyle(inputToken)];
    }, initComponentToken);

    var __rest$5 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const OTPInput = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
          value,
          onChange,
          onActiveChange,
          index,
          mask
        } = props,
        restProps = __rest$5(props, ["value", "onChange", "onActiveChange", "index", "mask"]);
      const internalValue = value && typeof mask === 'string' ? mask : value;
      const onInternalChange = e => {
        onChange(index, e.target.value);
      };
      // ========================== Ref ===========================
      const inputRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => inputRef.current);
      // ========================= Focus ==========================
      const syncSelection = () => {
        wrapperRaf(() => {
          var _a;
          const inputEle = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input;
          if (document.activeElement === inputEle && inputEle) {
            inputEle.select();
          }
        });
      };
      // ======================== Keyboard ========================
      const onInternalKeyDown = event => {
        const {
          key,
          ctrlKey,
          metaKey
        } = event;
        if (key === 'ArrowLeft') {
          onActiveChange(index - 1);
        } else if (key === 'ArrowRight') {
          onActiveChange(index + 1);
        } else if (key === 'z' && (ctrlKey || metaKey)) {
          event.preventDefault();
        }
        syncSelection();
      };
      const onInternalKeyUp = e => {
        if (e.key === 'Backspace' && !value) {
          onActiveChange(index - 1);
        }
        syncSelection();
      };
      // ========================= Render =========================
      return /*#__PURE__*/reactExports.createElement(Input$1, Object.assign({
        type: mask === true ? 'password' : 'text'
      }, restProps, {
        ref: inputRef,
        value: internalValue,
        onInput: onInternalChange,
        onFocus: syncSelection,
        onKeyDown: onInternalKeyDown,
        onKeyUp: onInternalKeyUp,
        onMouseDown: syncSelection,
        onMouseUp: syncSelection
      }));
    });

    var __rest$4 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    function strToArr(str) {
      return (str || '').split('');
    }
    const OTP = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
          prefixCls: customizePrefixCls,
          length = 6,
          size: customSize,
          defaultValue,
          value,
          onChange,
          formatter,
          variant,
          disabled,
          status: customStatus,
          autoFocus,
          mask,
          type,
          onInput,
          inputMode
        } = props,
        restProps = __rest$4(props, ["prefixCls", "length", "size", "defaultValue", "value", "onChange", "formatter", "variant", "disabled", "status", "autoFocus", "mask", "type", "onInput", "inputMode"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const prefixCls = getPrefixCls('otp', customizePrefixCls);
      const domAttrs = pickAttrs(restProps, {
        aria: true,
        data: true,
        attr: true
      });
      // ========================= Root =========================
      // Style
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$1(prefixCls, rootCls);
      // ========================= Size =========================
      const mergedSize = useSize(ctx => customSize !== null && customSize !== void 0 ? customSize : ctx);
      // ======================== Status ========================
      const formContext = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(formContext.status, customStatus);
      const proxyFormContext = reactExports.useMemo(() => Object.assign(Object.assign({}, formContext), {
        status: mergedStatus,
        hasFeedback: false,
        feedbackIcon: null
      }), [formContext, mergedStatus]);
      // ========================= Refs =========================
      const containerRef = reactExports.useRef(null);
      const refs = reactExports.useRef({});
      reactExports.useImperativeHandle(ref, () => ({
        focus: () => {
          var _a;
          (_a = refs.current[0]) === null || _a === void 0 ? void 0 : _a.focus();
        },
        blur: () => {
          var _a;
          for (let i = 0; i < length; i += 1) {
            (_a = refs.current[i]) === null || _a === void 0 ? void 0 : _a.blur();
          }
        },
        nativeElement: containerRef.current
      }));
      // ======================= Formatter ======================
      const internalFormatter = txt => formatter ? formatter(txt) : txt;
      // ======================== Values ========================
      const [valueCells, setValueCells] = reactExports.useState(strToArr(internalFormatter(defaultValue || '')));
      reactExports.useEffect(() => {
        if (value !== undefined) {
          setValueCells(strToArr(value));
        }
      }, [value]);
      const triggerValueCellsChange = useEvent(nextValueCells => {
        setValueCells(nextValueCells);
        if (onInput) {
          onInput(nextValueCells);
        }
        // Trigger if all cells are filled
        if (onChange && nextValueCells.length === length && nextValueCells.every(c => c) && nextValueCells.some((c, index) => valueCells[index] !== c)) {
          onChange(nextValueCells.join(''));
        }
      });
      const patchValue = useEvent((index, txt) => {
        let nextCells = _toConsumableArray(valueCells);
        // Fill cells till index
        for (let i = 0; i < index; i += 1) {
          if (!nextCells[i]) {
            nextCells[i] = '';
          }
        }
        if (txt.length <= 1) {
          nextCells[index] = txt;
        } else {
          nextCells = nextCells.slice(0, index).concat(strToArr(txt));
        }
        nextCells = nextCells.slice(0, length);
        // Clean the last empty cell
        for (let i = nextCells.length - 1; i >= 0; i -= 1) {
          if (nextCells[i]) {
            break;
          }
          nextCells.pop();
        }
        // Format if needed
        const formattedValue = internalFormatter(nextCells.map(c => c || ' ').join(''));
        nextCells = strToArr(formattedValue).map((c, i) => {
          if (c === ' ' && !nextCells[i]) {
            return nextCells[i];
          }
          return c;
        });
        return nextCells;
      });
      // ======================== Change ========================
      const onInputChange = (index, txt) => {
        var _a;
        const nextCells = patchValue(index, txt);
        const nextIndex = Math.min(index + txt.length, length - 1);
        if (nextIndex !== index && nextCells[index] !== undefined) {
          (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
        }
        triggerValueCellsChange(nextCells);
      };
      const onInputActiveChange = nextIndex => {
        var _a;
        (_a = refs.current[nextIndex]) === null || _a === void 0 ? void 0 : _a.focus();
      };
      // ======================== Render ========================
      const inputSharedProps = {
        variant,
        disabled,
        status: mergedStatus,
        mask,
        type,
        inputMode
      };
      return wrapCSSVar(/*#__PURE__*/reactExports.createElement("div", Object.assign({}, domAttrs, {
        ref: containerRef,
        className: classNames(prefixCls, {
          [`${prefixCls}-sm`]: mergedSize === 'small',
          [`${prefixCls}-lg`]: mergedSize === 'large',
          [`${prefixCls}-rtl`]: direction === 'rtl'
        }, cssVarCls, hashId)
      }), /*#__PURE__*/reactExports.createElement(FormItemInputContext.Provider, {
        value: proxyFormContext
      }, Array.from({
        length
      }).map((_, index) => {
        const key = `otp-${index}`;
        const singleValue = valueCells[index] || '';
        return /*#__PURE__*/reactExports.createElement(OTPInput, Object.assign({
          ref: inputEle => {
            refs.current[index] = inputEle;
          },
          key: key,
          index: index,
          size: mergedSize,
          htmlSize: 1,
          className: `${prefixCls}-input`,
          onChange: onInputChange,
          value: singleValue,
          onActiveChange: onInputActiveChange,
          autoFocus: index === 0 && autoFocus
        }, inputSharedProps));
      }))));
    });

    // This icon file is generated automatically.
    var EyeInvisibleOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2Q889.47 375.11 816.7 305l-50.88 50.88C807.31 395.53 843.45 447.4 874.7 512 791.5 684.2 673.4 766 512 766q-72.67 0-133.87-22.38L323 798.75Q408 838 512 838q288.3 0 430.2-300.3a60.29 60.29 0 000-51.5zm-63.57-320.64L836 122.88a8 8 0 00-11.32 0L715.31 232.2Q624.86 186 512 186q-288.3 0-430.2 300.3a60.3 60.3 0 000 51.5q56.69 119.4 136.5 191.41L112.48 835a8 8 0 000 11.31L155.17 889a8 8 0 0011.31 0l712.15-712.12a8 8 0 000-11.32zM149.3 512C232.6 339.8 350.7 258 512 258c54.54 0 104.13 9.36 149.12 28.39l-70.3 70.3a176 176 0 00-238.13 238.13l-83.42 83.42C223.1 637.49 183.3 582.28 149.3 512zm246.7 0a112.11 112.11 0 01146.2-106.69L401.31 546.2A112 112 0 01396 512z" } }, { "tag": "path", "attrs": { "d": "M508 624c-3.46 0-6.87-.16-10.25-.47l-52.82 52.82a176.09 176.09 0 00227.42-227.42l-52.82 52.82c.31 3.38.47 6.79.47 10.25a111.94 111.94 0 01-112 112z" } }] }, "name": "eye-invisible", "theme": "outlined" };

    var EyeInvisibleOutlined = function EyeInvisibleOutlined(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: EyeInvisibleOutlined$1
      }));
    };

    /**![eye-invisible](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk0Mi4yIDQ4Ni4yUTg4OS40NyAzNzUuMTEgODE2LjcgMzA1bC01MC44OCA1MC44OEM4MDcuMzEgMzk1LjUzIDg0My40NSA0NDcuNCA4NzQuNyA1MTIgNzkxLjUgNjg0LjIgNjczLjQgNzY2IDUxMiA3NjZxLTcyLjY3IDAtMTMzLjg3LTIyLjM4TDMyMyA3OTguNzVRNDA4IDgzOCA1MTIgODM4cTI4OC4zIDAgNDMwLjItMzAwLjNhNjAuMjkgNjAuMjkgMCAwMDAtNTEuNXptLTYzLjU3LTMyMC42NEw4MzYgMTIyLjg4YTggOCAwIDAwLTExLjMyIDBMNzE1LjMxIDIzMi4yUTYyNC44NiAxODYgNTEyIDE4NnEtMjg4LjMgMC00MzAuMiAzMDAuM2E2MC4zIDYwLjMgMCAwMDAgNTEuNXE1Ni42OSAxMTkuNCAxMzYuNSAxOTEuNDFMMTEyLjQ4IDgzNWE4IDggMCAwMDAgMTEuMzFMMTU1LjE3IDg4OWE4IDggMCAwMDExLjMxIDBsNzEyLjE1LTcxMi4xMmE4IDggMCAwMDAtMTEuMzJ6TTE0OS4zIDUxMkMyMzIuNiAzMzkuOCAzNTAuNyAyNTggNTEyIDI1OGM1NC41NCAwIDEwNC4xMyA5LjM2IDE0OS4xMiAyOC4zOWwtNzAuMyA3MC4zYTE3NiAxNzYgMCAwMC0yMzguMTMgMjM4LjEzbC04My40MiA4My40MkMyMjMuMSA2MzcuNDkgMTgzLjMgNTgyLjI4IDE0OS4zIDUxMnptMjQ2LjcgMGExMTIuMTEgMTEyLjExIDAgMDExNDYuMi0xMDYuNjlMNDAxLjMxIDU0Ni4yQTExMiAxMTIgMCAwMTM5NiA1MTJ6IiAvPjxwYXRoIGQ9Ik01MDggNjI0Yy0zLjQ2IDAtNi44Ny0uMTYtMTAuMjUtLjQ3bC01Mi44MiA1Mi44MmExNzYuMDkgMTc2LjA5IDAgMDAyMjcuNDItMjI3LjQybC01Mi44MiA1Mi44MmMuMzEgMy4zOC40NyA2Ljc5LjQ3IDEwLjI1YTExMS45NCAxMTEuOTQgMCAwMS0xMTIgMTEyeiIgLz48L3N2Zz4=) */
    var RefIcon$1 = /*#__PURE__*/reactExports.forwardRef(EyeInvisibleOutlined);

    // This icon file is generated automatically.
    var EyeOutlined$1 = { "icon": { "tag": "svg", "attrs": { "viewBox": "64 64 896 896", "focusable": "false" }, "children": [{ "tag": "path", "attrs": { "d": "M942.2 486.2C847.4 286.5 704.1 186 512 186c-192.2 0-335.4 100.5-430.2 300.3a60.3 60.3 0 000 51.5C176.6 737.5 319.9 838 512 838c192.2 0 335.4-100.5 430.2-300.3 7.7-16.2 7.7-35 0-51.5zM512 766c-161.3 0-279.4-81.8-362.7-254C232.6 339.8 350.7 258 512 258c161.3 0 279.4 81.8 362.7 254C791.5 684.2 673.4 766 512 766zm-4-430c-97.2 0-176 78.8-176 176s78.8 176 176 176 176-78.8 176-176-78.8-176-176-176zm0 288c-61.9 0-112-50.1-112-112s50.1-112 112-112 112 50.1 112 112-50.1 112-112 112z" } }] }, "name": "eye", "theme": "outlined" };

    var EyeOutlined = function EyeOutlined(props, ref) {
      return /*#__PURE__*/reactExports.createElement(Icon, _extends({}, props, {
        ref: ref,
        icon: EyeOutlined$1
      }));
    };

    /**![eye](data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNTAiIGhlaWdodD0iNTAiIGZpbGw9IiNjYWNhY2EiIHZpZXdCb3g9IjY0IDY0IDg5NiA4OTYiIGZvY3VzYWJsZT0iZmFsc2UiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+PHBhdGggZD0iTTk0Mi4yIDQ4Ni4yQzg0Ny40IDI4Ni41IDcwNC4xIDE4NiA1MTIgMTg2Yy0xOTIuMiAwLTMzNS40IDEwMC41LTQzMC4yIDMwMC4zYTYwLjMgNjAuMyAwIDAwMCA1MS41QzE3Ni42IDczNy41IDMxOS45IDgzOCA1MTIgODM4YzE5Mi4yIDAgMzM1LjQtMTAwLjUgNDMwLjItMzAwLjMgNy43LTE2LjIgNy43LTM1IDAtNTEuNXpNNTEyIDc2NmMtMTYxLjMgMC0yNzkuNC04MS44LTM2Mi43LTI1NEMyMzIuNiAzMzkuOCAzNTAuNyAyNTggNTEyIDI1OGMxNjEuMyAwIDI3OS40IDgxLjggMzYyLjcgMjU0Qzc5MS41IDY4NC4yIDY3My40IDc2NiA1MTIgNzY2em0tNC00MzBjLTk3LjIgMC0xNzYgNzguOC0xNzYgMTc2czc4LjggMTc2IDE3NiAxNzYgMTc2LTc4LjggMTc2LTE3Ni03OC44LTE3Ni0xNzYtMTc2em0wIDI4OGMtNjEuOSAwLTExMi01MC4xLTExMi0xMTJzNTAuMS0xMTIgMTEyLTExMiAxMTIgNTAuMSAxMTIgMTEyLTUwLjEgMTEyLTExMiAxMTJ6IiAvPjwvc3ZnPg==) */
    var RefIcon = /*#__PURE__*/reactExports.forwardRef(EyeOutlined);

    var __rest$3 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const defaultIconRender = visible => visible ? /*#__PURE__*/reactExports.createElement(RefIcon, null) : /*#__PURE__*/reactExports.createElement(RefIcon$1, null);
    const actionMap = {
      click: 'onClick',
      hover: 'onMouseOver'
    };
    const Password = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
        disabled: customDisabled,
        action = 'click',
        visibilityToggle = true,
        iconRender = defaultIconRender
      } = props;
      // ===================== Disabled =====================
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      const visibilityControlled = typeof visibilityToggle === 'object' && visibilityToggle.visible !== undefined;
      const [visible, setVisible] = reactExports.useState(() => visibilityControlled ? visibilityToggle.visible : false);
      const inputRef = reactExports.useRef(null);
      reactExports.useEffect(() => {
        if (visibilityControlled) {
          setVisible(visibilityToggle.visible);
        }
      }, [visibilityControlled, visibilityToggle]);
      // Remove Password value
      const removePasswordTimeout = useRemovePasswordTimeout(inputRef);
      const onVisibleChange = () => {
        var _a;
        if (mergedDisabled) {
          return;
        }
        if (visible) {
          removePasswordTimeout();
        }
        const nextVisible = !visible;
        setVisible(nextVisible);
        if (typeof visibilityToggle === 'object') {
          (_a = visibilityToggle.onVisibleChange) === null || _a === void 0 ? void 0 : _a.call(visibilityToggle, nextVisible);
        }
      };
      const getIcon = prefixCls => {
        const iconTrigger = actionMap[action] || '';
        const icon = iconRender(visible);
        const iconProps = {
          [iconTrigger]: onVisibleChange,
          className: `${prefixCls}-icon`,
          key: 'passwordIcon',
          onMouseDown: e => {
            // Prevent focused state lost
            // https://github.com/ant-design/ant-design/issues/15173
            e.preventDefault();
          },
          onMouseUp: e => {
            // Prevent caret position change
            // https://github.com/ant-design/ant-design/issues/23524
            e.preventDefault();
          }
        };
        return /*#__PURE__*/reactExports.cloneElement(/*#__PURE__*/reactExports.isValidElement(icon) ? icon : /*#__PURE__*/reactExports.createElement("span", null, icon), iconProps);
      };
      const {
          className,
          prefixCls: customizePrefixCls,
          inputPrefixCls: customizeInputPrefixCls,
          size
        } = props,
        restProps = __rest$3(props, ["className", "prefixCls", "inputPrefixCls", "size"]);
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
      const prefixCls = getPrefixCls('input-password', customizePrefixCls);
      const suffixIcon = visibilityToggle && getIcon(prefixCls);
      const inputClassName = classNames(prefixCls, className, {
        [`${prefixCls}-${size}`]: !!size
      });
      const omittedProps = Object.assign(Object.assign({}, omit(restProps, ['suffix', 'iconRender', 'visibilityToggle'])), {
        type: visible ? 'text' : 'password',
        className: inputClassName,
        prefixCls: inputPrefixCls,
        suffix: suffixIcon
      });
      if (size) {
        omittedProps.size = size;
      }
      return /*#__PURE__*/reactExports.createElement(Input$1, Object.assign({
        ref: composeRef(ref, inputRef)
      }, omittedProps));
    });

    var __rest$2 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const Search = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      const {
          prefixCls: customizePrefixCls,
          inputPrefixCls: customizeInputPrefixCls,
          className,
          size: customizeSize,
          suffix,
          enterButton = false,
          addonAfter,
          loading,
          disabled,
          onSearch: customOnSearch,
          onChange: customOnChange,
          onCompositionStart,
          onCompositionEnd
        } = props,
        restProps = __rest$2(props, ["prefixCls", "inputPrefixCls", "className", "size", "suffix", "enterButton", "addonAfter", "loading", "disabled", "onSearch", "onChange", "onCompositionStart", "onCompositionEnd"]);
      const {
        getPrefixCls,
        direction
      } = reactExports.useContext(ConfigContext);
      const composedRef = reactExports.useRef(false);
      const prefixCls = getPrefixCls('input-search', customizePrefixCls);
      const inputPrefixCls = getPrefixCls('input', customizeInputPrefixCls);
      const {
        compactSize
      } = useCompactItemContext(prefixCls, direction);
      const size = useSize(ctx => {
        var _a;
        return (_a = customizeSize !== null && customizeSize !== void 0 ? customizeSize : compactSize) !== null && _a !== void 0 ? _a : ctx;
      });
      const inputRef = reactExports.useRef(null);
      const onChange = e => {
        if ((e === null || e === void 0 ? void 0 : e.target) && e.type === 'click' && customOnSearch) {
          customOnSearch(e.target.value, e, {
            source: 'clear'
          });
        }
        customOnChange === null || customOnChange === void 0 ? void 0 : customOnChange(e);
      };
      const onMouseDown = e => {
        var _a;
        if (document.activeElement === ((_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input)) {
          e.preventDefault();
        }
      };
      const onSearch = e => {
        var _a, _b;
        if (customOnSearch) {
          customOnSearch((_b = (_a = inputRef.current) === null || _a === void 0 ? void 0 : _a.input) === null || _b === void 0 ? void 0 : _b.value, e, {
            source: 'input'
          });
        }
      };
      const onPressEnter = e => {
        if (composedRef.current || loading) {
          return;
        }
        onSearch(e);
      };
      const searchIcon = typeof enterButton === 'boolean' ? /*#__PURE__*/reactExports.createElement(RefIcon$2, null) : null;
      const btnClassName = `${prefixCls}-button`;
      let button;
      const enterButtonAsElement = enterButton || {};
      const isAntdButton = enterButtonAsElement.type && enterButtonAsElement.type.__ANT_BUTTON === true;
      if (isAntdButton || enterButtonAsElement.type === 'button') {
        button = cloneElement(enterButtonAsElement, Object.assign({
          onMouseDown,
          onClick: e => {
            var _a, _b;
            (_b = (_a = enterButtonAsElement === null || enterButtonAsElement === void 0 ? void 0 : enterButtonAsElement.props) === null || _a === void 0 ? void 0 : _a.onClick) === null || _b === void 0 ? void 0 : _b.call(_a, e);
            onSearch(e);
          },
          key: 'enterButton'
        }, isAntdButton ? {
          className: btnClassName,
          size
        } : {}));
      } else {
        button = /*#__PURE__*/reactExports.createElement(Button, {
          className: btnClassName,
          type: enterButton ? 'primary' : undefined,
          size: size,
          disabled: disabled,
          key: "enterButton",
          onMouseDown: onMouseDown,
          onClick: onSearch,
          loading: loading,
          icon: searchIcon
        }, enterButton);
      }
      if (addonAfter) {
        button = [button, cloneElement(addonAfter, {
          key: 'addonAfter'
        })];
      }
      const cls = classNames(prefixCls, {
        [`${prefixCls}-rtl`]: direction === 'rtl',
        [`${prefixCls}-${size}`]: !!size,
        [`${prefixCls}-with-button`]: !!enterButton
      }, className);
      const newProps = Object.assign(Object.assign({}, restProps), {
        className: cls,
        prefixCls: inputPrefixCls,
        type: 'search'
      });
      const handleOnCompositionStart = e => {
        composedRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 ? void 0 : onCompositionStart(e);
      };
      const handleOnCompositionEnd = e => {
        composedRef.current = false;
        onCompositionEnd === null || onCompositionEnd === void 0 ? void 0 : onCompositionEnd(e);
      };
      return /*#__PURE__*/reactExports.createElement(Input$1, Object.assign({
        ref: composeRef(inputRef, ref),
        onPressEnter: onPressEnter
      }, newProps, {
        size: size,
        onCompositionStart: handleOnCompositionStart,
        onCompositionEnd: handleOnCompositionEnd,
        addonAfter: button,
        suffix: suffix,
        onChange: onChange,
        disabled: disabled
      }));
    });

    // Thanks to https://github.com/andreypopp/react-textarea-autosize/

    /**
     * calculateNodeHeight(uiTextNode, useCache = false)
     */

    var HIDDEN_TEXTAREA_STYLE = "\n  min-height:0 !important;\n  max-height:none !important;\n  height:0 !important;\n  visibility:hidden !important;\n  overflow:hidden !important;\n  position:absolute !important;\n  z-index:-1000 !important;\n  top:0 !important;\n  right:0 !important;\n  pointer-events: none !important;\n";
    var SIZING_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'font-variant', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing', 'word-break', 'white-space'];
    var computedStyleCache = {};
    var hiddenTextarea;
    function calculateNodeStyling(node) {
      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var nodeRef = node.getAttribute('id') || node.getAttribute('data-reactid') || node.getAttribute('name');
      if (useCache && computedStyleCache[nodeRef]) {
        return computedStyleCache[nodeRef];
      }
      var style = window.getComputedStyle(node);
      var boxSizing = style.getPropertyValue('box-sizing') || style.getPropertyValue('-moz-box-sizing') || style.getPropertyValue('-webkit-box-sizing');
      var paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
      var borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
      var sizingStyle = SIZING_STYLE.map(function (name) {
        return "".concat(name, ":").concat(style.getPropertyValue(name));
      }).join(';');
      var nodeInfo = {
        sizingStyle: sizingStyle,
        paddingSize: paddingSize,
        borderSize: borderSize,
        boxSizing: boxSizing
      };
      if (useCache && nodeRef) {
        computedStyleCache[nodeRef] = nodeInfo;
      }
      return nodeInfo;
    }
    function calculateAutoSizeStyle(uiTextNode) {
      var useCache = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var minRows = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var maxRows = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
      if (!hiddenTextarea) {
        hiddenTextarea = document.createElement('textarea');
        hiddenTextarea.setAttribute('tab-index', '-1');
        hiddenTextarea.setAttribute('aria-hidden', 'true');
        // fix: A form field element should have an id or name attribute
        // A form field element has neither an id nor a name attribute. This might prevent the browser from correctly autofilling the form.
        // https://developer.mozilla.org/en-US/docs/Web/HTML/Element/textarea
        hiddenTextarea.setAttribute('name', 'hiddenTextarea');
        document.body.appendChild(hiddenTextarea);
      }

      // Fix wrap="off" issue
      // https://github.com/ant-design/ant-design/issues/6577
      if (uiTextNode.getAttribute('wrap')) {
        hiddenTextarea.setAttribute('wrap', uiTextNode.getAttribute('wrap'));
      } else {
        hiddenTextarea.removeAttribute('wrap');
      }

      // Copy all CSS properties that have an impact on the height of the content in
      // the textbox
      var _calculateNodeStyling = calculateNodeStyling(uiTextNode, useCache),
        paddingSize = _calculateNodeStyling.paddingSize,
        borderSize = _calculateNodeStyling.borderSize,
        boxSizing = _calculateNodeStyling.boxSizing,
        sizingStyle = _calculateNodeStyling.sizingStyle;

      // Need to have the overflow attribute to hide the scrollbar otherwise
      // text-lines will not calculated properly as the shadow will technically be
      // narrower for content
      hiddenTextarea.setAttribute('style', "".concat(sizingStyle, ";").concat(HIDDEN_TEXTAREA_STYLE));
      hiddenTextarea.value = uiTextNode.value || uiTextNode.placeholder || '';
      var minHeight = undefined;
      var maxHeight = undefined;
      var overflowY;
      var height = hiddenTextarea.scrollHeight;
      if (boxSizing === 'border-box') {
        // border-box: add border, since height = content + padding + border
        height += borderSize;
      } else if (boxSizing === 'content-box') {
        // remove padding, since height = content
        height -= paddingSize;
      }
      if (minRows !== null || maxRows !== null) {
        // measure height of a textarea with a single row
        hiddenTextarea.value = ' ';
        var singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;
        if (minRows !== null) {
          minHeight = singleRowHeight * minRows;
          if (boxSizing === 'border-box') {
            minHeight = minHeight + paddingSize + borderSize;
          }
          height = Math.max(minHeight, height);
        }
        if (maxRows !== null) {
          maxHeight = singleRowHeight * maxRows;
          if (boxSizing === 'border-box') {
            maxHeight = maxHeight + paddingSize + borderSize;
          }
          overflowY = height > maxHeight ? '' : 'hidden';
          height = Math.min(maxHeight, height);
        }
      }
      var style = {
        height: height,
        overflowY: overflowY,
        resize: 'none'
      };
      if (minHeight) {
        style.minHeight = minHeight;
      }
      if (maxHeight) {
        style.maxHeight = maxHeight;
      }
      return style;
    }

    var _excluded$1 = ["prefixCls", "defaultValue", "value", "autoSize", "onResize", "className", "style", "disabled", "onChange", "onInternalAutoSize"];
    var RESIZE_START = 0;
    var RESIZE_MEASURING = 1;
    var RESIZE_STABLE = 2;
    var ResizableTextArea = /*#__PURE__*/reactExports.forwardRef(function (props, ref) {
      var _ref = props,
        prefixCls = _ref.prefixCls,
        defaultValue = _ref.defaultValue,
        value = _ref.value,
        autoSize = _ref.autoSize,
        onResize = _ref.onResize,
        className = _ref.className,
        style = _ref.style,
        disabled = _ref.disabled,
        onChange = _ref.onChange;
        _ref.onInternalAutoSize;
        var restProps = _objectWithoutProperties(_ref, _excluded$1);

      // =============================== Value ================================
      var _useMergedState = useMergedState(defaultValue, {
          value: value,
          postState: function postState(val) {
            return val !== null && val !== void 0 ? val : '';
          }
        }),
        _useMergedState2 = _slicedToArray(_useMergedState, 2),
        mergedValue = _useMergedState2[0],
        setMergedValue = _useMergedState2[1];
      var onInternalChange = function onInternalChange(event) {
        setMergedValue(event.target.value);
        onChange === null || onChange === void 0 || onChange(event);
      };

      // ================================ Ref =================================
      var textareaRef = reactExports.useRef();
      reactExports.useImperativeHandle(ref, function () {
        return {
          textArea: textareaRef.current
        };
      });

      // ============================== AutoSize ==============================
      var _React$useMemo = reactExports.useMemo(function () {
          if (autoSize && _typeof(autoSize) === 'object') {
            return [autoSize.minRows, autoSize.maxRows];
          }
          return [];
        }, [autoSize]),
        _React$useMemo2 = _slicedToArray(_React$useMemo, 2),
        minRows = _React$useMemo2[0],
        maxRows = _React$useMemo2[1];
      var needAutoSize = !!autoSize;

      // =============================== Scroll ===============================
      // https://github.com/ant-design/ant-design/issues/21870
      var fixFirefoxAutoScroll = function fixFirefoxAutoScroll() {
        try {
          // FF has bug with jump of scroll to top. We force back here.
          if (document.activeElement === textareaRef.current) {
            var _textareaRef$current = textareaRef.current,
              selectionStart = _textareaRef$current.selectionStart,
              selectionEnd = _textareaRef$current.selectionEnd,
              scrollTop = _textareaRef$current.scrollTop;

            // Fix Safari bug which not rollback when break line
            // This makes Chinese IME can't input. Do not fix this
            // const { value: tmpValue } = textareaRef.current;
            // textareaRef.current.value = '';
            // textareaRef.current.value = tmpValue;

            textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
            textareaRef.current.scrollTop = scrollTop;
          }
        } catch (e) {
          // Fix error in Chrome:
          // Failed to read the 'selectionStart' property from 'HTMLInputElement'
          // http://stackoverflow.com/q/21177489/3040605
        }
      };

      // =============================== Resize ===============================
      var _React$useState = reactExports.useState(RESIZE_STABLE),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        resizeState = _React$useState2[0],
        setResizeState = _React$useState2[1];
      var _React$useState3 = reactExports.useState(),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        autoSizeStyle = _React$useState4[0],
        setAutoSizeStyle = _React$useState4[1];
      var startResize = function startResize() {
        setResizeState(RESIZE_START);
      };

      // Change to trigger resize measure
      useLayoutEffect(function () {
        if (needAutoSize) {
          startResize();
        }
      }, [value, minRows, maxRows, needAutoSize]);
      useLayoutEffect(function () {
        if (resizeState === RESIZE_START) {
          setResizeState(RESIZE_MEASURING);
        } else if (resizeState === RESIZE_MEASURING) {
          var textareaStyles = calculateAutoSizeStyle(textareaRef.current, false, minRows, maxRows);

          // Safari has bug that text will keep break line on text cut when it's prev is break line.
          // ZombieJ: This not often happen. So we just skip it.
          // const { selectionStart, selectionEnd, scrollTop } = textareaRef.current;
          // const { value: tmpValue } = textareaRef.current;
          // textareaRef.current.value = '';
          // textareaRef.current.value = tmpValue;

          // if (document.activeElement === textareaRef.current) {
          //   textareaRef.current.scrollTop = scrollTop;
          //   textareaRef.current.setSelectionRange(selectionStart, selectionEnd);
          // }

          setResizeState(RESIZE_STABLE);
          setAutoSizeStyle(textareaStyles);
        } else {
          fixFirefoxAutoScroll();
        }
      }, [resizeState]);

      // We lock resize trigger by raf to avoid Safari warning
      var resizeRafRef = reactExports.useRef();
      var cleanRaf = function cleanRaf() {
        wrapperRaf.cancel(resizeRafRef.current);
      };
      var onInternalResize = function onInternalResize(size) {
        if (resizeState === RESIZE_STABLE) {
          onResize === null || onResize === void 0 || onResize(size);
          if (autoSize) {
            cleanRaf();
            resizeRafRef.current = wrapperRaf(function () {
              startResize();
            });
          }
        }
      };
      reactExports.useEffect(function () {
        return cleanRaf;
      }, []);

      // =============================== Render ===============================
      var mergedAutoSizeStyle = needAutoSize ? autoSizeStyle : null;
      var mergedStyle = _objectSpread2(_objectSpread2({}, style), mergedAutoSizeStyle);
      if (resizeState === RESIZE_START || resizeState === RESIZE_MEASURING) {
        mergedStyle.overflowY = 'hidden';
        mergedStyle.overflowX = 'hidden';
      }
      return /*#__PURE__*/reactExports.createElement(RefResizeObserver, {
        onResize: onInternalResize,
        disabled: !(autoSize || onResize)
      }, /*#__PURE__*/reactExports.createElement("textarea", _extends({}, restProps, {
        ref: textareaRef,
        style: mergedStyle,
        className: classNames(prefixCls, className, _defineProperty({}, "".concat(prefixCls, "-disabled"), disabled)),
        disabled: disabled,
        value: mergedValue,
        onChange: onInternalChange
      })));
    });

    var _excluded = ["defaultValue", "value", "onFocus", "onBlur", "onChange", "allowClear", "maxLength", "onCompositionStart", "onCompositionEnd", "suffix", "prefixCls", "showCount", "count", "className", "style", "disabled", "hidden", "classNames", "styles", "onResize", "onClear", "onPressEnter", "readOnly", "autoSize", "onKeyDown"];
    var TextArea$1 = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
      var _countConfig$max;
      var defaultValue = _ref.defaultValue,
        customValue = _ref.value,
        onFocus = _ref.onFocus,
        onBlur = _ref.onBlur,
        onChange = _ref.onChange,
        allowClear = _ref.allowClear,
        maxLength = _ref.maxLength,
        onCompositionStart = _ref.onCompositionStart,
        onCompositionEnd = _ref.onCompositionEnd,
        suffix = _ref.suffix,
        _ref$prefixCls = _ref.prefixCls,
        prefixCls = _ref$prefixCls === void 0 ? 'rc-textarea' : _ref$prefixCls,
        showCount = _ref.showCount,
        count = _ref.count,
        className = _ref.className,
        style = _ref.style,
        disabled = _ref.disabled,
        hidden = _ref.hidden,
        classNames$1 = _ref.classNames,
        styles = _ref.styles,
        onResize = _ref.onResize,
        onClear = _ref.onClear,
        onPressEnter = _ref.onPressEnter,
        readOnly = _ref.readOnly,
        autoSize = _ref.autoSize,
        onKeyDown = _ref.onKeyDown,
        rest = _objectWithoutProperties(_ref, _excluded);
      var _useMergedState = useMergedState(defaultValue, {
          value: customValue,
          defaultValue: defaultValue
        }),
        _useMergedState2 = _slicedToArray(_useMergedState, 2),
        value = _useMergedState2[0],
        setValue = _useMergedState2[1];
      var formatValue = value === undefined || value === null ? '' : String(value);
      var _React$useState = React.useState(false),
        _React$useState2 = _slicedToArray(_React$useState, 2),
        focused = _React$useState2[0],
        setFocused = _React$useState2[1];
      var compositionRef = React.useRef(false);
      var _React$useState3 = React.useState(null),
        _React$useState4 = _slicedToArray(_React$useState3, 2),
        textareaResized = _React$useState4[0],
        setTextareaResized = _React$useState4[1];

      // =============================== Ref ================================
      var holderRef = reactExports.useRef(null);
      var resizableTextAreaRef = reactExports.useRef(null);
      var getTextArea = function getTextArea() {
        var _resizableTextAreaRef;
        return (_resizableTextAreaRef = resizableTextAreaRef.current) === null || _resizableTextAreaRef === void 0 ? void 0 : _resizableTextAreaRef.textArea;
      };
      var focus = function focus() {
        getTextArea().focus();
      };
      reactExports.useImperativeHandle(ref, function () {
        var _holderRef$current;
        return {
          resizableTextArea: resizableTextAreaRef.current,
          focus: focus,
          blur: function blur() {
            getTextArea().blur();
          },
          nativeElement: ((_holderRef$current = holderRef.current) === null || _holderRef$current === void 0 ? void 0 : _holderRef$current.nativeElement) || getTextArea()
        };
      });
      reactExports.useEffect(function () {
        setFocused(function (prev) {
          return !disabled && prev;
        });
      }, [disabled]);

      // =========================== Select Range ===========================
      var _React$useState5 = React.useState(null),
        _React$useState6 = _slicedToArray(_React$useState5, 2),
        selection = _React$useState6[0],
        setSelection = _React$useState6[1];
      React.useEffect(function () {
        if (selection) {
          var _getTextArea;
          (_getTextArea = getTextArea()).setSelectionRange.apply(_getTextArea, _toConsumableArray(selection));
        }
      }, [selection]);

      // ============================== Count ===============================
      var countConfig = useCount(count, showCount);
      var mergedMax = (_countConfig$max = countConfig.max) !== null && _countConfig$max !== void 0 ? _countConfig$max : maxLength;

      // Max length value
      var hasMaxLength = Number(mergedMax) > 0;
      var valueLength = countConfig.strategy(formatValue);
      var isOutOfRange = !!mergedMax && valueLength > mergedMax;

      // ============================== Change ==============================
      var triggerChange = function triggerChange(e, currentValue) {
        var cutValue = currentValue;
        if (!compositionRef.current && countConfig.exceedFormatter && countConfig.max && countConfig.strategy(currentValue) > countConfig.max) {
          cutValue = countConfig.exceedFormatter(currentValue, {
            max: countConfig.max
          });
          if (currentValue !== cutValue) {
            setSelection([getTextArea().selectionStart || 0, getTextArea().selectionEnd || 0]);
          }
        }
        setValue(cutValue);
        resolveOnChange(e.currentTarget, e, onChange, cutValue);
      };

      // =========================== Value Update ===========================
      var onInternalCompositionStart = function onInternalCompositionStart(e) {
        compositionRef.current = true;
        onCompositionStart === null || onCompositionStart === void 0 || onCompositionStart(e);
      };
      var onInternalCompositionEnd = function onInternalCompositionEnd(e) {
        compositionRef.current = false;
        triggerChange(e, e.currentTarget.value);
        onCompositionEnd === null || onCompositionEnd === void 0 || onCompositionEnd(e);
      };
      var onInternalChange = function onInternalChange(e) {
        triggerChange(e, e.target.value);
      };
      var handleKeyDown = function handleKeyDown(e) {
        if (e.key === 'Enter' && onPressEnter) {
          onPressEnter(e);
        }
        onKeyDown === null || onKeyDown === void 0 || onKeyDown(e);
      };
      var handleFocus = function handleFocus(e) {
        setFocused(true);
        onFocus === null || onFocus === void 0 || onFocus(e);
      };
      var handleBlur = function handleBlur(e) {
        setFocused(false);
        onBlur === null || onBlur === void 0 || onBlur(e);
      };

      // ============================== Reset ===============================
      var handleReset = function handleReset(e) {
        setValue('');
        focus();
        resolveOnChange(getTextArea(), e, onChange);
      };
      var suffixNode = suffix;
      var dataCount;
      if (countConfig.show) {
        if (countConfig.showFormatter) {
          dataCount = countConfig.showFormatter({
            value: formatValue,
            count: valueLength,
            maxLength: mergedMax
          });
        } else {
          dataCount = "".concat(valueLength).concat(hasMaxLength ? " / ".concat(mergedMax) : '');
        }
        suffixNode = /*#__PURE__*/React.createElement(React.Fragment, null, suffixNode, /*#__PURE__*/React.createElement("span", {
          className: classNames("".concat(prefixCls, "-data-count"), classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.count),
          style: styles === null || styles === void 0 ? void 0 : styles.count
        }, dataCount));
      }
      var handleResize = function handleResize(size) {
        var _getTextArea2;
        onResize === null || onResize === void 0 || onResize(size);
        if ((_getTextArea2 = getTextArea()) !== null && _getTextArea2 !== void 0 && _getTextArea2.style.height) {
          setTextareaResized(true);
        }
      };
      var isPureTextArea = !autoSize && !showCount && !allowClear;
      return /*#__PURE__*/React.createElement(BaseInput, {
        ref: holderRef,
        value: formatValue,
        allowClear: allowClear,
        handleReset: handleReset,
        suffix: suffixNode,
        prefixCls: prefixCls,
        classNames: _objectSpread2(_objectSpread2({}, classNames$1), {}, {
          affixWrapper: classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.affixWrapper, _defineProperty(_defineProperty({}, "".concat(prefixCls, "-show-count"), showCount), "".concat(prefixCls, "-textarea-allow-clear"), allowClear))
        }),
        disabled: disabled,
        focused: focused,
        className: classNames(className, isOutOfRange && "".concat(prefixCls, "-out-of-range")),
        style: _objectSpread2(_objectSpread2({}, style), textareaResized && !isPureTextArea ? {
          height: 'auto'
        } : {}),
        dataAttrs: {
          affixWrapper: {
            'data-count': typeof dataCount === 'string' ? dataCount : undefined
          }
        },
        hidden: hidden,
        readOnly: readOnly,
        onClear: onClear
      }, /*#__PURE__*/React.createElement(ResizableTextArea, _extends({}, rest, {
        autoSize: autoSize,
        maxLength: maxLength,
        onKeyDown: handleKeyDown,
        onChange: onInternalChange,
        onFocus: handleFocus,
        onBlur: handleBlur,
        onCompositionStart: onInternalCompositionStart,
        onCompositionEnd: onInternalCompositionEnd,
        className: classNames(classNames$1 === null || classNames$1 === void 0 ? void 0 : classNames$1.textarea),
        style: _objectSpread2(_objectSpread2({}, styles === null || styles === void 0 ? void 0 : styles.textarea), {}, {
          resize: style === null || style === void 0 ? void 0 : style.resize
        }),
        disabled: disabled,
        prefixCls: prefixCls,
        onResize: handleResize,
        ref: resizableTextAreaRef,
        readOnly: readOnly
      })));
    });

    var __rest$1 = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const TextArea = /*#__PURE__*/reactExports.forwardRef((props, ref) => {
      var _a, _b;
      const {
          prefixCls: customizePrefixCls,
          bordered = true,
          size: customizeSize,
          disabled: customDisabled,
          status: customStatus,
          allowClear,
          classNames: classes,
          rootClassName,
          className,
          style,
          styles,
          variant: customVariant
        } = props,
        rest = __rest$1(props, ["prefixCls", "bordered", "size", "disabled", "status", "allowClear", "classNames", "rootClassName", "className", "style", "styles", "variant"]);
      const {
        getPrefixCls,
        direction,
        textArea
      } = reactExports.useContext(ConfigContext);
      // ===================== Size =====================
      const mergedSize = useSize(customizeSize);
      // ===================== Disabled =====================
      const disabled = reactExports.useContext(DisabledContext);
      const mergedDisabled = customDisabled !== null && customDisabled !== void 0 ? customDisabled : disabled;
      // ===================== Status =====================
      const {
        status: contextStatus,
        hasFeedback,
        feedbackIcon
      } = reactExports.useContext(FormItemInputContext);
      const mergedStatus = getMergedStatus(contextStatus, customStatus);
      // ===================== Ref =====================
      const innerRef = reactExports.useRef(null);
      reactExports.useImperativeHandle(ref, () => {
        var _a;
        return {
          resizableTextArea: (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea,
          focus: option => {
            var _a, _b;
            triggerFocus((_b = (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.resizableTextArea) === null || _b === void 0 ? void 0 : _b.textArea, option);
          },
          blur: () => {
            var _a;
            return (_a = innerRef.current) === null || _a === void 0 ? void 0 : _a.blur();
          }
        };
      });
      const prefixCls = getPrefixCls('input', customizePrefixCls);
      // ===================== Style =====================
      const rootCls = useCSSVarCls(prefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle$2(prefixCls, rootCls);
      const [variant, enableVariantCls] = useVariant('textArea', customVariant, bordered);
      const mergedAllowClear = getAllowClear(allowClear !== null && allowClear !== void 0 ? allowClear : textArea === null || textArea === void 0 ? void 0 : textArea.allowClear);
      return wrapCSSVar(/*#__PURE__*/reactExports.createElement(TextArea$1, Object.assign({
        autoComplete: textArea === null || textArea === void 0 ? void 0 : textArea.autoComplete
      }, rest, {
        style: Object.assign(Object.assign({}, textArea === null || textArea === void 0 ? void 0 : textArea.style), style),
        styles: Object.assign(Object.assign({}, textArea === null || textArea === void 0 ? void 0 : textArea.styles), styles),
        disabled: mergedDisabled,
        allowClear: mergedAllowClear,
        className: classNames(cssVarCls, rootCls, className, rootClassName, textArea === null || textArea === void 0 ? void 0 : textArea.className),
        classNames: Object.assign(Object.assign(Object.assign({}, classes), textArea === null || textArea === void 0 ? void 0 : textArea.classNames), {
          textarea: classNames({
            [`${prefixCls}-sm`]: mergedSize === 'small',
            [`${prefixCls}-lg`]: mergedSize === 'large'
          }, hashId, classes === null || classes === void 0 ? void 0 : classes.textarea, (_a = textArea === null || textArea === void 0 ? void 0 : textArea.classNames) === null || _a === void 0 ? void 0 : _a.textarea),
          variant: classNames({
            [`${prefixCls}-${variant}`]: enableVariantCls
          }, getStatusClassNames(prefixCls, mergedStatus)),
          affixWrapper: classNames(`${prefixCls}-textarea-affix-wrapper`, {
            [`${prefixCls}-affix-wrapper-rtl`]: direction === 'rtl',
            [`${prefixCls}-affix-wrapper-sm`]: mergedSize === 'small',
            [`${prefixCls}-affix-wrapper-lg`]: mergedSize === 'large',
            [`${prefixCls}-textarea-show-count`]: props.showCount || ((_b = props.count) === null || _b === void 0 ? void 0 : _b.show)
          }, hashId)
        }),
        prefixCls: prefixCls,
        suffix: hasFeedback && /*#__PURE__*/reactExports.createElement("span", {
          className: `${prefixCls}-textarea-suffix`
        }, feedbackIcon),
        ref: innerRef
      })));
    });

    const Input = Input$1;
    Input.Group = Group;
    Input.Search = Search;
    Input.TextArea = TextArea;
    Input.Password = Password;
    Input.OTP = OTP;

    function isPresetSize(size) {
      return ['small', 'middle', 'large'].includes(size);
    }

    const flexWrapValues = ['wrap', 'nowrap', 'wrap-reverse'];
    const justifyContentValues = ['flex-start', 'flex-end', 'start', 'end', 'center', 'space-between', 'space-around', 'space-evenly', 'stretch', 'normal', 'left', 'right'];
    const alignItemsValues = ['center', 'start', 'end', 'flex-start', 'flex-end', 'self-start', 'self-end', 'baseline', 'normal', 'stretch'];
    const genClsWrap = (prefixCls, props) => {
      const wrap = props.wrap === true ? 'wrap' : props.wrap;
      return {
        [`${prefixCls}-wrap-${wrap}`]: wrap && flexWrapValues.includes(wrap)
      };
    };
    const genClsAlign = (prefixCls, props) => {
      const alignCls = {};
      alignItemsValues.forEach(cssKey => {
        alignCls[`${prefixCls}-align-${cssKey}`] = props.align === cssKey;
      });
      alignCls[`${prefixCls}-align-stretch`] = !props.align && !!props.vertical;
      return alignCls;
    };
    const genClsJustify = (prefixCls, props) => {
      const justifyCls = {};
      justifyContentValues.forEach(cssKey => {
        justifyCls[`${prefixCls}-justify-${cssKey}`] = props.justify === cssKey;
      });
      return justifyCls;
    };
    function createFlexClassNames(prefixCls, props) {
      return classNames(Object.assign(Object.assign(Object.assign({}, genClsWrap(prefixCls, props)), genClsAlign(prefixCls, props)), genClsJustify(prefixCls, props)));
    }

    const genFlexStyle = token => {
      const {
        componentCls
      } = token;
      return {
        [componentCls]: {
          display: 'flex',
          margin: 0,
          padding: 0,
          '&-vertical': {
            flexDirection: 'column'
          },
          '&-rtl': {
            direction: 'rtl'
          },
          '&:empty': {
            display: 'none'
          }
        }
      };
    };
    const genFlexGapStyle = token => {
      const {
        componentCls
      } = token;
      return {
        [componentCls]: {
          '&-gap-small': {
            gap: token.flexGapSM
          },
          '&-gap-middle': {
            gap: token.flexGap
          },
          '&-gap-large': {
            gap: token.flexGapLG
          }
        }
      };
    };
    const genFlexWrapStyle = token => {
      const {
        componentCls
      } = token;
      const wrapStyle = {};
      flexWrapValues.forEach(value => {
        wrapStyle[`${componentCls}-wrap-${value}`] = {
          flexWrap: value
        };
      });
      return wrapStyle;
    };
    const genAlignItemsStyle = token => {
      const {
        componentCls
      } = token;
      const alignStyle = {};
      alignItemsValues.forEach(value => {
        alignStyle[`${componentCls}-align-${value}`] = {
          alignItems: value
        };
      });
      return alignStyle;
    };
    const genJustifyContentStyle = token => {
      const {
        componentCls
      } = token;
      const justifyStyle = {};
      justifyContentValues.forEach(value => {
        justifyStyle[`${componentCls}-justify-${value}`] = {
          justifyContent: value
        };
      });
      return justifyStyle;
    };
    const prepareComponentToken = () => ({});
    var useStyle = genStyleHooks('Flex', token => {
      const {
        paddingXS,
        padding,
        paddingLG
      } = token;
      const flexToken = merge$1(token, {
        flexGapSM: paddingXS,
        flexGap: padding,
        flexGapLG: paddingLG
      });
      return [genFlexStyle(flexToken), genFlexGapStyle(flexToken), genFlexWrapStyle(flexToken), genAlignItemsStyle(flexToken), genJustifyContentStyle(flexToken)];
    }, prepareComponentToken, {
      // Flex component don't apply extra font style
      // https://github.com/ant-design/ant-design/issues/46403
      resetStyle: false
    });

    var __rest = undefined && undefined.__rest || function (s, e) {
      var t = {};
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
      if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
      }
      return t;
    };
    const Flex = /*#__PURE__*/React.forwardRef((props, ref) => {
      const {
          prefixCls: customizePrefixCls,
          rootClassName,
          className,
          style,
          flex,
          gap,
          children,
          vertical = false,
          component: Component = 'div'
        } = props,
        othersProps = __rest(props, ["prefixCls", "rootClassName", "className", "style", "flex", "gap", "children", "vertical", "component"]);
      const {
        flex: ctxFlex,
        direction: ctxDirection,
        getPrefixCls
      } = React.useContext(ConfigContext);
      const prefixCls = getPrefixCls('flex', customizePrefixCls);
      const [wrapCSSVar, hashId, cssVarCls] = useStyle(prefixCls);
      const mergedVertical = vertical !== null && vertical !== void 0 ? vertical : ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.vertical;
      const mergedCls = classNames(className, rootClassName, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.className, prefixCls, hashId, cssVarCls, createFlexClassNames(prefixCls, props), {
        [`${prefixCls}-rtl`]: ctxDirection === 'rtl',
        [`${prefixCls}-gap-${gap}`]: isPresetSize(gap),
        [`${prefixCls}-vertical`]: mergedVertical
      });
      const mergedStyle = Object.assign(Object.assign({}, ctxFlex === null || ctxFlex === void 0 ? void 0 : ctxFlex.style), style);
      if (flex) {
        mergedStyle.flex = flex;
      }
      if (gap && !isPresetSize(gap)) {
        mergedStyle.gap = gap;
      }
      return wrapCSSVar(/*#__PURE__*/React.createElement(Component, Object.assign({
        ref: ref,
        className: mergedCls,
        style: mergedStyle
      }, omit(othersProps, ['justify', 'wrap', 'align'])), children));
    });

    let message = null;
    let act = callback => callback();
    let taskQueue = [];
    let defaultGlobalConfig = {};
    function getGlobalContext() {
      const {
        getContainer,
        duration,
        rtl,
        maxCount,
        top
      } = defaultGlobalConfig;
      const mergedContainer = (getContainer === null || getContainer === void 0 ? void 0 : getContainer()) || document.body;
      return {
        getContainer: () => mergedContainer,
        duration,
        rtl,
        maxCount,
        top
      };
    }
    const GlobalHolder = /*#__PURE__*/React.forwardRef((props, ref) => {
      const {
        messageConfig,
        sync
      } = props;
      const {
        getPrefixCls
      } = reactExports.useContext(ConfigContext);
      const prefixCls = defaultGlobalConfig.prefixCls || getPrefixCls('message');
      const appConfig = reactExports.useContext(AppConfigContext);
      const [api, holder] = useInternalMessage(Object.assign(Object.assign(Object.assign({}, messageConfig), {
        prefixCls
      }), appConfig.message));
      React.useImperativeHandle(ref, () => {
        const instance = Object.assign({}, api);
        Object.keys(instance).forEach(method => {
          instance[method] = function () {
            sync();
            return api[method].apply(api, arguments);
          };
        });
        return {
          instance,
          sync
        };
      });
      return holder;
    });
    const GlobalHolderWrapper = /*#__PURE__*/React.forwardRef((_, ref) => {
      const [messageConfig, setMessageConfig] = React.useState(getGlobalContext);
      const sync = () => {
        setMessageConfig(getGlobalContext);
      };
      React.useEffect(sync, []);
      const global = globalConfig();
      const rootPrefixCls = global.getRootPrefixCls();
      const rootIconPrefixCls = global.getIconPrefixCls();
      const theme = global.getTheme();
      const dom = /*#__PURE__*/React.createElement(GlobalHolder, {
        ref: ref,
        sync: sync,
        messageConfig: messageConfig
      });
      return /*#__PURE__*/React.createElement(ConfigProvider, {
        prefixCls: rootPrefixCls,
        iconPrefixCls: rootIconPrefixCls,
        theme: theme
      }, global.holderRender ? global.holderRender(dom) : dom);
    });
    function flushNotice() {
      if (!message) {
        const holderFragment = document.createDocumentFragment();
        const newMessage = {
          fragment: holderFragment
        };
        message = newMessage;
        // Delay render to avoid sync issue
        act(() => {
          const reactRender = getReactRender();
          reactRender(/*#__PURE__*/React.createElement(GlobalHolderWrapper, {
            ref: node => {
              const {
                instance,
                sync
              } = node || {};
              // React 18 test env will throw if call immediately in ref
              Promise.resolve().then(() => {
                if (!newMessage.instance && instance) {
                  newMessage.instance = instance;
                  newMessage.sync = sync;
                  flushNotice();
                }
              });
            }
          }), holderFragment);
        });
        return;
      }
      // Notification not ready
      if (!message.instance) {
        return;
      }
      // >>> Execute task
      taskQueue.forEach(task => {
        const {
          type,
          skipped
        } = task;
        // Only `skipped` when user call notice but cancel it immediately
        // and instance not ready
        if (!skipped) {
          switch (type) {
            case 'open':
              {
                act(() => {
                  const closeFn = message.instance.open(Object.assign(Object.assign({}, defaultGlobalConfig), task.config));
                  closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
                  task.setCloseFn(closeFn);
                });
                break;
              }
            case 'destroy':
              act(() => {
                message === null || message === void 0 ? void 0 : message.instance.destroy(task.key);
              });
              break;
            // Other type open
            default:
              {
                act(() => {
                  var _message$instance;
                  const closeFn = (_message$instance = message.instance)[type].apply(_message$instance, _toConsumableArray(task.args));
                  closeFn === null || closeFn === void 0 ? void 0 : closeFn.then(task.resolve);
                  task.setCloseFn(closeFn);
                });
              }
          }
        }
      });
      // Clean up
      taskQueue = [];
    }
    // ==============================================================================
    // ==                                  Export                                  ==
    // ==============================================================================
    function setMessageGlobalConfig(config) {
      defaultGlobalConfig = Object.assign(Object.assign({}, defaultGlobalConfig), config);
      // Trigger sync for it
      act(() => {
        var _a;
        (_a = message === null || message === void 0 ? void 0 : message.sync) === null || _a === void 0 ? void 0 : _a.call(message);
      });
    }
    function open(config) {
      const result = wrapPromiseFn(resolve => {
        let closeFn;
        const task = {
          type: 'open',
          config,
          resolve,
          setCloseFn: fn => {
            closeFn = fn;
          }
        };
        taskQueue.push(task);
        return () => {
          if (closeFn) {
            act(() => {
              closeFn();
            });
          } else {
            task.skipped = true;
          }
        };
      });
      flushNotice();
      return result;
    }
    function typeOpen(type, args) {
      const result = wrapPromiseFn(resolve => {
        let closeFn;
        const task = {
          type,
          args,
          resolve,
          setCloseFn: fn => {
            closeFn = fn;
          }
        };
        taskQueue.push(task);
        return () => {
          if (closeFn) {
            act(() => {
              closeFn();
            });
          } else {
            task.skipped = true;
          }
        };
      });
      flushNotice();
      return result;
    }
    const destroy = key => {
      taskQueue.push({
        type: 'destroy',
        key
      });
      flushNotice();
    };
    const methods = ['success', 'info', 'warning', 'error', 'loading'];
    const baseStaticMethods = {
      open,
      destroy,
      config: setMessageGlobalConfig,
      useMessage,
      _InternalPanelDoNotUseOrYouWillBeFired: PurePanel
    };
    const staticMethods = baseStaticMethods;
    methods.forEach(type => {
      staticMethods[type] = function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        return typeOpen(type, args);
      };
    });

    function styleInject(css, ref) {
      if ( ref === void 0 ) ref = {};
      var insertAt = ref.insertAt;

      if (!css || typeof document === 'undefined') { return; }

      var head = document.head || document.getElementsByTagName('head')[0];
      var style = document.createElement('style');
      style.type = 'text/css';

      if (insertAt === 'top') {
        if (head.firstChild) {
          head.insertBefore(style, head.firstChild);
        } else {
          head.appendChild(style);
        }
      } else {
        head.appendChild(style);
      }

      if (style.styleSheet) {
        style.styleSheet.cssText = css;
      } else {
        style.appendChild(document.createTextNode(css));
      }
    }

    var css_248z$1 = ".login{border:1px solid #ccc;border-radius:10px;margin:50px auto;padding:20px;width:500px}";
    styleInject(css_248z$1);

    /**
     * Create a bound version of a function with a specified `this` context
     *
     * @param {Function} fn - The function to bind
     * @param {*} thisArg - The value to be passed as the `this` parameter
     * @returns {Function} A new function that will call the original function with the specified `this` context
     */
    function bind(fn, thisArg) {
      return function wrap() {
        return fn.apply(thisArg, arguments);
      };
    }

    // utils is a library of generic helper functions non-specific to axios

    const {toString} = Object.prototype;
    const {getPrototypeOf} = Object;
    const {iterator, toStringTag} = Symbol;

    const kindOf = (cache => thing => {
        const str = toString.call(thing);
        return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
    })(Object.create(null));

    const kindOfTest = (type) => {
      type = type.toLowerCase();
      return (thing) => kindOf(thing) === type
    };

    const typeOfTest = type => thing => typeof thing === type;

    /**
     * Determine if a value is an Array
     *
     * @param {Object} val The value to test
     *
     * @returns {boolean} True if value is an Array, otherwise false
     */
    const {isArray} = Array;

    /**
     * Determine if a value is undefined
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if the value is undefined, otherwise false
     */
    const isUndefined = typeOfTest('undefined');

    /**
     * Determine if a value is a Buffer
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Buffer, otherwise false
     */
    function isBuffer(val) {
      return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)
        && isFunction$1(val.constructor.isBuffer) && val.constructor.isBuffer(val);
    }

    /**
     * Determine if a value is an ArrayBuffer
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is an ArrayBuffer, otherwise false
     */
    const isArrayBuffer = kindOfTest('ArrayBuffer');


    /**
     * Determine if a value is a view on an ArrayBuffer
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
     */
    function isArrayBufferView(val) {
      let result;
      if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {
        result = ArrayBuffer.isView(val);
      } else {
        result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));
      }
      return result;
    }

    /**
     * Determine if a value is a String
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a String, otherwise false
     */
    const isString = typeOfTest('string');

    /**
     * Determine if a value is a Function
     *
     * @param {*} val The value to test
     * @returns {boolean} True if value is a Function, otherwise false
     */
    const isFunction$1 = typeOfTest('function');

    /**
     * Determine if a value is a Number
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Number, otherwise false
     */
    const isNumber = typeOfTest('number');

    /**
     * Determine if a value is an Object
     *
     * @param {*} thing The value to test
     *
     * @returns {boolean} True if value is an Object, otherwise false
     */
    const isObject = (thing) => thing !== null && typeof thing === 'object';

    /**
     * Determine if a value is a Boolean
     *
     * @param {*} thing The value to test
     * @returns {boolean} True if value is a Boolean, otherwise false
     */
    const isBoolean = thing => thing === true || thing === false;

    /**
     * Determine if a value is a plain Object
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a plain Object, otherwise false
     */
    const isPlainObject = (val) => {
      if (kindOf(val) !== 'object') {
        return false;
      }

      const prototype = getPrototypeOf(val);
      return (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(toStringTag in val) && !(iterator in val);
    };

    /**
     * Determine if a value is an empty object (safely handles Buffers)
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is an empty object, otherwise false
     */
    const isEmptyObject = (val) => {
      // Early return for non-objects or Buffers to prevent RangeError
      if (!isObject(val) || isBuffer(val)) {
        return false;
      }

      try {
        return Object.keys(val).length === 0 && Object.getPrototypeOf(val) === Object.prototype;
      } catch (e) {
        // Fallback for any other objects that might cause RangeError with Object.keys()
        return false;
      }
    };

    /**
     * Determine if a value is a Date
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Date, otherwise false
     */
    const isDate = kindOfTest('Date');

    /**
     * Determine if a value is a File
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a File, otherwise false
     */
    const isFile = kindOfTest('File');

    /**
     * Determine if a value is a Blob
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Blob, otherwise false
     */
    const isBlob = kindOfTest('Blob');

    /**
     * Determine if a value is a FileList
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a File, otherwise false
     */
    const isFileList = kindOfTest('FileList');

    /**
     * Determine if a value is a Stream
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a Stream, otherwise false
     */
    const isStream = (val) => isObject(val) && isFunction$1(val.pipe);

    /**
     * Determine if a value is a FormData
     *
     * @param {*} thing The value to test
     *
     * @returns {boolean} True if value is an FormData, otherwise false
     */
    const isFormData = (thing) => {
      let kind;
      return thing && (
        (typeof FormData === 'function' && thing instanceof FormData) || (
          isFunction$1(thing.append) && (
            (kind = kindOf(thing)) === 'formdata' ||
            // detect form-data instance
            (kind === 'object' && isFunction$1(thing.toString) && thing.toString() === '[object FormData]')
          )
        )
      )
    };

    /**
     * Determine if a value is a URLSearchParams object
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a URLSearchParams object, otherwise false
     */
    const isURLSearchParams = kindOfTest('URLSearchParams');

    const [isReadableStream, isRequest, isResponse, isHeaders] = ['ReadableStream', 'Request', 'Response', 'Headers'].map(kindOfTest);

    /**
     * Trim excess whitespace off the beginning and end of a string
     *
     * @param {String} str The String to trim
     *
     * @returns {String} The String freed of excess whitespace
     */
    const trim = (str) => str.trim ?
      str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');

    /**
     * Iterate over an Array or an Object invoking a function for each item.
     *
     * If `obj` is an Array callback will be called passing
     * the value, index, and complete array for each item.
     *
     * If 'obj' is an Object callback will be called passing
     * the value, key, and complete object for each property.
     *
     * @param {Object|Array} obj The object to iterate
     * @param {Function} fn The callback to invoke for each item
     *
     * @param {Boolean} [allOwnKeys = false]
     * @returns {any}
     */
    function forEach(obj, fn, {allOwnKeys = false} = {}) {
      // Don't bother if no value provided
      if (obj === null || typeof obj === 'undefined') {
        return;
      }

      let i;
      let l;

      // Force an array if not already something iterable
      if (typeof obj !== 'object') {
        /*eslint no-param-reassign:0*/
        obj = [obj];
      }

      if (isArray(obj)) {
        // Iterate over array values
        for (i = 0, l = obj.length; i < l; i++) {
          fn.call(null, obj[i], i, obj);
        }
      } else {
        // Buffer check
        if (isBuffer(obj)) {
          return;
        }

        // Iterate over object keys
        const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
        const len = keys.length;
        let key;

        for (i = 0; i < len; i++) {
          key = keys[i];
          fn.call(null, obj[key], key, obj);
        }
      }
    }

    function findKey(obj, key) {
      if (isBuffer(obj)){
        return null;
      }

      key = key.toLowerCase();
      const keys = Object.keys(obj);
      let i = keys.length;
      let _key;
      while (i-- > 0) {
        _key = keys[i];
        if (key === _key.toLowerCase()) {
          return _key;
        }
      }
      return null;
    }

    const _global = (() => {
      /*eslint no-undef:0*/
      if (typeof globalThis !== "undefined") return globalThis;
      return typeof self !== "undefined" ? self : (typeof window !== 'undefined' ? window : global)
    })();

    const isContextDefined = (context) => !isUndefined(context) && context !== _global;

    /**
     * Accepts varargs expecting each argument to be an object, then
     * immutably merges the properties of each object and returns result.
     *
     * When multiple objects contain the same key the later object in
     * the arguments list will take precedence.
     *
     * Example:
     *
     * ```js
     * var result = merge({foo: 123}, {foo: 456});
     * console.log(result.foo); // outputs 456
     * ```
     *
     * @param {Object} obj1 Object to merge
     *
     * @returns {Object} Result of all merge properties
     */
    function merge(/* obj1, obj2, obj3, ... */) {
      const {caseless, skipUndefined} = isContextDefined(this) && this || {};
      const result = {};
      const assignValue = (val, key) => {
        const targetKey = caseless && findKey(result, key) || key;
        if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
          result[targetKey] = merge(result[targetKey], val);
        } else if (isPlainObject(val)) {
          result[targetKey] = merge({}, val);
        } else if (isArray(val)) {
          result[targetKey] = val.slice();
        } else if (!skipUndefined || !isUndefined(val)) {
          result[targetKey] = val;
        }
      };

      for (let i = 0, l = arguments.length; i < l; i++) {
        arguments[i] && forEach(arguments[i], assignValue);
      }
      return result;
    }

    /**
     * Extends object a by mutably adding to it the properties of object b.
     *
     * @param {Object} a The object to be extended
     * @param {Object} b The object to copy properties from
     * @param {Object} thisArg The object to bind function to
     *
     * @param {Boolean} [allOwnKeys]
     * @returns {Object} The resulting value of object a
     */
    const extend = (a, b, thisArg, {allOwnKeys}= {}) => {
      forEach(b, (val, key) => {
        if (thisArg && isFunction$1(val)) {
          a[key] = bind(val, thisArg);
        } else {
          a[key] = val;
        }
      }, {allOwnKeys});
      return a;
    };

    /**
     * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
     *
     * @param {string} content with BOM
     *
     * @returns {string} content value without BOM
     */
    const stripBOM = (content) => {
      if (content.charCodeAt(0) === 0xFEFF) {
        content = content.slice(1);
      }
      return content;
    };

    /**
     * Inherit the prototype methods from one constructor into another
     * @param {function} constructor
     * @param {function} superConstructor
     * @param {object} [props]
     * @param {object} [descriptors]
     *
     * @returns {void}
     */
    const inherits = (constructor, superConstructor, props, descriptors) => {
      constructor.prototype = Object.create(superConstructor.prototype, descriptors);
      constructor.prototype.constructor = constructor;
      Object.defineProperty(constructor, 'super', {
        value: superConstructor.prototype
      });
      props && Object.assign(constructor.prototype, props);
    };

    /**
     * Resolve object with deep prototype chain to a flat object
     * @param {Object} sourceObj source object
     * @param {Object} [destObj]
     * @param {Function|Boolean} [filter]
     * @param {Function} [propFilter]
     *
     * @returns {Object}
     */
    const toFlatObject = (sourceObj, destObj, filter, propFilter) => {
      let props;
      let i;
      let prop;
      const merged = {};

      destObj = destObj || {};
      // eslint-disable-next-line no-eq-null,eqeqeq
      if (sourceObj == null) return destObj;

      do {
        props = Object.getOwnPropertyNames(sourceObj);
        i = props.length;
        while (i-- > 0) {
          prop = props[i];
          if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
            destObj[prop] = sourceObj[prop];
            merged[prop] = true;
          }
        }
        sourceObj = filter !== false && getPrototypeOf(sourceObj);
      } while (sourceObj && (!filter || filter(sourceObj, destObj)) && sourceObj !== Object.prototype);

      return destObj;
    };

    /**
     * Determines whether a string ends with the characters of a specified string
     *
     * @param {String} str
     * @param {String} searchString
     * @param {Number} [position= 0]
     *
     * @returns {boolean}
     */
    const endsWith = (str, searchString, position) => {
      str = String(str);
      if (position === undefined || position > str.length) {
        position = str.length;
      }
      position -= searchString.length;
      const lastIndex = str.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };


    /**
     * Returns new array from array like object or null if failed
     *
     * @param {*} [thing]
     *
     * @returns {?Array}
     */
    const toArray = (thing) => {
      if (!thing) return null;
      if (isArray(thing)) return thing;
      let i = thing.length;
      if (!isNumber(i)) return null;
      const arr = new Array(i);
      while (i-- > 0) {
        arr[i] = thing[i];
      }
      return arr;
    };

    /**
     * Checking if the Uint8Array exists and if it does, it returns a function that checks if the
     * thing passed in is an instance of Uint8Array
     *
     * @param {TypedArray}
     *
     * @returns {Array}
     */
    // eslint-disable-next-line func-names
    const isTypedArray = (TypedArray => {
      // eslint-disable-next-line func-names
      return thing => {
        return TypedArray && thing instanceof TypedArray;
      };
    })(typeof Uint8Array !== 'undefined' && getPrototypeOf(Uint8Array));

    /**
     * For each entry in the object, call the function with the key and value.
     *
     * @param {Object<any, any>} obj - The object to iterate over.
     * @param {Function} fn - The function to call for each entry.
     *
     * @returns {void}
     */
    const forEachEntry = (obj, fn) => {
      const generator = obj && obj[iterator];

      const _iterator = generator.call(obj);

      let result;

      while ((result = _iterator.next()) && !result.done) {
        const pair = result.value;
        fn.call(obj, pair[0], pair[1]);
      }
    };

    /**
     * It takes a regular expression and a string, and returns an array of all the matches
     *
     * @param {string} regExp - The regular expression to match against.
     * @param {string} str - The string to search.
     *
     * @returns {Array<boolean>}
     */
    const matchAll = (regExp, str) => {
      let matches;
      const arr = [];

      while ((matches = regExp.exec(str)) !== null) {
        arr.push(matches);
      }

      return arr;
    };

    /* Checking if the kindOfTest function returns true when passed an HTMLFormElement. */
    const isHTMLForm = kindOfTest('HTMLFormElement');

    const toCamelCase = str => {
      return str.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g,
        function replacer(m, p1, p2) {
          return p1.toUpperCase() + p2;
        }
      );
    };

    /* Creating a function that will check if an object has a property. */
    const hasOwnProperty = (({hasOwnProperty}) => (obj, prop) => hasOwnProperty.call(obj, prop))(Object.prototype);

    /**
     * Determine if a value is a RegExp object
     *
     * @param {*} val The value to test
     *
     * @returns {boolean} True if value is a RegExp object, otherwise false
     */
    const isRegExp = kindOfTest('RegExp');

    const reduceDescriptors = (obj, reducer) => {
      const descriptors = Object.getOwnPropertyDescriptors(obj);
      const reducedDescriptors = {};

      forEach(descriptors, (descriptor, name) => {
        let ret;
        if ((ret = reducer(descriptor, name, obj)) !== false) {
          reducedDescriptors[name] = ret || descriptor;
        }
      });

      Object.defineProperties(obj, reducedDescriptors);
    };

    /**
     * Makes all methods read-only
     * @param {Object} obj
     */

    const freezeMethods = (obj) => {
      reduceDescriptors(obj, (descriptor, name) => {
        // skip restricted props in strict mode
        if (isFunction$1(obj) && ['arguments', 'caller', 'callee'].indexOf(name) !== -1) {
          return false;
        }

        const value = obj[name];

        if (!isFunction$1(value)) return;

        descriptor.enumerable = false;

        if ('writable' in descriptor) {
          descriptor.writable = false;
          return;
        }

        if (!descriptor.set) {
          descriptor.set = () => {
            throw Error('Can not rewrite read-only method \'' + name + '\'');
          };
        }
      });
    };

    const toObjectSet = (arrayOrString, delimiter) => {
      const obj = {};

      const define = (arr) => {
        arr.forEach(value => {
          obj[value] = true;
        });
      };

      isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));

      return obj;
    };

    const noop = () => {};

    const toFiniteNumber = (value, defaultValue) => {
      return value != null && Number.isFinite(value = +value) ? value : defaultValue;
    };



    /**
     * If the thing is a FormData object, return true, otherwise return false.
     *
     * @param {unknown} thing - The thing to check.
     *
     * @returns {boolean}
     */
    function isSpecCompliantForm(thing) {
      return !!(thing && isFunction$1(thing.append) && thing[toStringTag] === 'FormData' && thing[iterator]);
    }

    const toJSONObject = (obj) => {
      const stack = new Array(10);

      const visit = (source, i) => {

        if (isObject(source)) {
          if (stack.indexOf(source) >= 0) {
            return;
          }

          //Buffer check
          if (isBuffer(source)) {
            return source;
          }

          if(!('toJSON' in source)) {
            stack[i] = source;
            const target = isArray(source) ? [] : {};

            forEach(source, (value, key) => {
              const reducedValue = visit(value, i + 1);
              !isUndefined(reducedValue) && (target[key] = reducedValue);
            });

            stack[i] = undefined;

            return target;
          }
        }

        return source;
      };

      return visit(obj, 0);
    };

    const isAsyncFn = kindOfTest('AsyncFunction');

    const isThenable = (thing) =>
      thing && (isObject(thing) || isFunction$1(thing)) && isFunction$1(thing.then) && isFunction$1(thing.catch);

    // original code
    // https://github.com/DigitalBrainJS/AxiosPromise/blob/16deab13710ec09779922131f3fa5954320f83ab/lib/utils.js#L11-L34

    const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
      if (setImmediateSupported) {
        return setImmediate;
      }

      return postMessageSupported ? ((token, callbacks) => {
        _global.addEventListener("message", ({source, data}) => {
          if (source === _global && data === token) {
            callbacks.length && callbacks.shift()();
          }
        }, false);

        return (cb) => {
          callbacks.push(cb);
          _global.postMessage(token, "*");
        }
      })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
    })(
      typeof setImmediate === 'function',
      isFunction$1(_global.postMessage)
    );

    const asap = typeof queueMicrotask !== 'undefined' ?
      queueMicrotask.bind(_global) : ( typeof process !== 'undefined' && process.nextTick || _setImmediate);

    // *********************


    const isIterable = (thing) => thing != null && isFunction$1(thing[iterator]);


    var utils$1 = {
      isArray,
      isArrayBuffer,
      isBuffer,
      isFormData,
      isArrayBufferView,
      isString,
      isNumber,
      isBoolean,
      isObject,
      isPlainObject,
      isEmptyObject,
      isReadableStream,
      isRequest,
      isResponse,
      isHeaders,
      isUndefined,
      isDate,
      isFile,
      isBlob,
      isRegExp,
      isFunction: isFunction$1,
      isStream,
      isURLSearchParams,
      isTypedArray,
      isFileList,
      forEach,
      merge,
      extend,
      trim,
      stripBOM,
      inherits,
      toFlatObject,
      kindOf,
      kindOfTest,
      endsWith,
      toArray,
      forEachEntry,
      matchAll,
      isHTMLForm,
      hasOwnProperty,
      hasOwnProp: hasOwnProperty, // an alias to avoid ESLint no-prototype-builtins detection
      reduceDescriptors,
      freezeMethods,
      toObjectSet,
      toCamelCase,
      noop,
      toFiniteNumber,
      findKey,
      global: _global,
      isContextDefined,
      isSpecCompliantForm,
      toJSONObject,
      isAsyncFn,
      isThenable,
      setImmediate: _setImmediate,
      asap,
      isIterable
    };

    /**
     * Create an Error with the specified message, config, error code, request and response.
     *
     * @param {string} message The error message.
     * @param {string} [code] The error code (for example, 'ECONNABORTED').
     * @param {Object} [config] The config.
     * @param {Object} [request] The request.
     * @param {Object} [response] The response.
     *
     * @returns {Error} The created error.
     */
    function AxiosError$1(message, code, config, request, response) {
      Error.call(this);

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = (new Error()).stack;
      }

      this.message = message;
      this.name = 'AxiosError';
      code && (this.code = code);
      config && (this.config = config);
      request && (this.request = request);
      if (response) {
        this.response = response;
        this.status = response.status ? response.status : null;
      }
    }

    utils$1.inherits(AxiosError$1, Error, {
      toJSON: function toJSON() {
        return {
          // Standard
          message: this.message,
          name: this.name,
          // Microsoft
          description: this.description,
          number: this.number,
          // Mozilla
          fileName: this.fileName,
          lineNumber: this.lineNumber,
          columnNumber: this.columnNumber,
          stack: this.stack,
          // Axios
          config: utils$1.toJSONObject(this.config),
          code: this.code,
          status: this.status
        };
      }
    });

    const prototype$1 = AxiosError$1.prototype;
    const descriptors = {};

    [
      'ERR_BAD_OPTION_VALUE',
      'ERR_BAD_OPTION',
      'ECONNABORTED',
      'ETIMEDOUT',
      'ERR_NETWORK',
      'ERR_FR_TOO_MANY_REDIRECTS',
      'ERR_DEPRECATED',
      'ERR_BAD_RESPONSE',
      'ERR_BAD_REQUEST',
      'ERR_CANCELED',
      'ERR_NOT_SUPPORT',
      'ERR_INVALID_URL'
    // eslint-disable-next-line func-names
    ].forEach(code => {
      descriptors[code] = {value: code};
    });

    Object.defineProperties(AxiosError$1, descriptors);
    Object.defineProperty(prototype$1, 'isAxiosError', {value: true});

    // eslint-disable-next-line func-names
    AxiosError$1.from = (error, code, config, request, response, customProps) => {
      const axiosError = Object.create(prototype$1);

      utils$1.toFlatObject(error, axiosError, function filter(obj) {
        return obj !== Error.prototype;
      }, prop => {
        return prop !== 'isAxiosError';
      });

      const msg = error && error.message ? error.message : 'Error';

      // Prefer explicit code; otherwise copy the low-level error's code (e.g. ECONNREFUSED)
      const errCode = code == null && error ? error.code : code;
      AxiosError$1.call(axiosError, msg, errCode, config, request, response);

      // Chain the original error on the standard field; non-enumerable to avoid JSON noise
      if (error && axiosError.cause == null) {
        Object.defineProperty(axiosError, 'cause', { value: error, configurable: true });
      }

      axiosError.name = (error && error.name) || 'Error';

      customProps && Object.assign(axiosError, customProps);

      return axiosError;
    };

    // eslint-disable-next-line strict
    var httpAdapter = null;

    /**
     * Determines if the given thing is a array or js object.
     *
     * @param {string} thing - The object or array to be visited.
     *
     * @returns {boolean}
     */
    function isVisitable(thing) {
      return utils$1.isPlainObject(thing) || utils$1.isArray(thing);
    }

    /**
     * It removes the brackets from the end of a string
     *
     * @param {string} key - The key of the parameter.
     *
     * @returns {string} the key without the brackets.
     */
    function removeBrackets(key) {
      return utils$1.endsWith(key, '[]') ? key.slice(0, -2) : key;
    }

    /**
     * It takes a path, a key, and a boolean, and returns a string
     *
     * @param {string} path - The path to the current key.
     * @param {string} key - The key of the current object being iterated over.
     * @param {string} dots - If true, the key will be rendered with dots instead of brackets.
     *
     * @returns {string} The path to the current key.
     */
    function renderKey(path, key, dots) {
      if (!path) return key;
      return path.concat(key).map(function each(token, i) {
        // eslint-disable-next-line no-param-reassign
        token = removeBrackets(token);
        return !dots && i ? '[' + token + ']' : token;
      }).join(dots ? '.' : '');
    }

    /**
     * If the array is an array and none of its elements are visitable, then it's a flat array.
     *
     * @param {Array<any>} arr - The array to check
     *
     * @returns {boolean}
     */
    function isFlatArray(arr) {
      return utils$1.isArray(arr) && !arr.some(isVisitable);
    }

    const predicates = utils$1.toFlatObject(utils$1, {}, null, function filter(prop) {
      return /^is[A-Z]/.test(prop);
    });

    /**
     * Convert a data object to FormData
     *
     * @param {Object} obj
     * @param {?Object} [formData]
     * @param {?Object} [options]
     * @param {Function} [options.visitor]
     * @param {Boolean} [options.metaTokens = true]
     * @param {Boolean} [options.dots = false]
     * @param {?Boolean} [options.indexes = false]
     *
     * @returns {Object}
     **/

    /**
     * It converts an object into a FormData object
     *
     * @param {Object<any, any>} obj - The object to convert to form data.
     * @param {string} formData - The FormData object to append to.
     * @param {Object<string, any>} options
     *
     * @returns
     */
    function toFormData$1(obj, formData, options) {
      if (!utils$1.isObject(obj)) {
        throw new TypeError('target must be an object');
      }

      // eslint-disable-next-line no-param-reassign
      formData = formData || new (FormData)();

      // eslint-disable-next-line no-param-reassign
      options = utils$1.toFlatObject(options, {
        metaTokens: true,
        dots: false,
        indexes: false
      }, false, function defined(option, source) {
        // eslint-disable-next-line no-eq-null,eqeqeq
        return !utils$1.isUndefined(source[option]);
      });

      const metaTokens = options.metaTokens;
      // eslint-disable-next-line no-use-before-define
      const visitor = options.visitor || defaultVisitor;
      const dots = options.dots;
      const indexes = options.indexes;
      const _Blob = options.Blob || typeof Blob !== 'undefined' && Blob;
      const useBlob = _Blob && utils$1.isSpecCompliantForm(formData);

      if (!utils$1.isFunction(visitor)) {
        throw new TypeError('visitor must be a function');
      }

      function convertValue(value) {
        if (value === null) return '';

        if (utils$1.isDate(value)) {
          return value.toISOString();
        }

        if (utils$1.isBoolean(value)) {
          return value.toString();
        }

        if (!useBlob && utils$1.isBlob(value)) {
          throw new AxiosError$1('Blob is not supported. Use a Buffer instead.');
        }

        if (utils$1.isArrayBuffer(value) || utils$1.isTypedArray(value)) {
          return useBlob && typeof Blob === 'function' ? new Blob([value]) : Buffer.from(value);
        }

        return value;
      }

      /**
       * Default visitor.
       *
       * @param {*} value
       * @param {String|Number} key
       * @param {Array<String|Number>} path
       * @this {FormData}
       *
       * @returns {boolean} return true to visit the each prop of the value recursively
       */
      function defaultVisitor(value, key, path) {
        let arr = value;

        if (value && !path && typeof value === 'object') {
          if (utils$1.endsWith(key, '{}')) {
            // eslint-disable-next-line no-param-reassign
            key = metaTokens ? key : key.slice(0, -2);
            // eslint-disable-next-line no-param-reassign
            value = JSON.stringify(value);
          } else if (
            (utils$1.isArray(value) && isFlatArray(value)) ||
            ((utils$1.isFileList(value) || utils$1.endsWith(key, '[]')) && (arr = utils$1.toArray(value))
            )) {
            // eslint-disable-next-line no-param-reassign
            key = removeBrackets(key);

            arr.forEach(function each(el, index) {
              !(utils$1.isUndefined(el) || el === null) && formData.append(
                // eslint-disable-next-line no-nested-ternary
                indexes === true ? renderKey([key], index, dots) : (indexes === null ? key : key + '[]'),
                convertValue(el)
              );
            });
            return false;
          }
        }

        if (isVisitable(value)) {
          return true;
        }

        formData.append(renderKey(path, key, dots), convertValue(value));

        return false;
      }

      const stack = [];

      const exposedHelpers = Object.assign(predicates, {
        defaultVisitor,
        convertValue,
        isVisitable
      });

      function build(value, path) {
        if (utils$1.isUndefined(value)) return;

        if (stack.indexOf(value) !== -1) {
          throw Error('Circular reference detected in ' + path.join('.'));
        }

        stack.push(value);

        utils$1.forEach(value, function each(el, key) {
          const result = !(utils$1.isUndefined(el) || el === null) && visitor.call(
            formData, el, utils$1.isString(key) ? key.trim() : key, path, exposedHelpers
          );

          if (result === true) {
            build(el, path ? path.concat(key) : [key]);
          }
        });

        stack.pop();
      }

      if (!utils$1.isObject(obj)) {
        throw new TypeError('data must be an object');
      }

      build(obj);

      return formData;
    }

    /**
     * It encodes a string by replacing all characters that are not in the unreserved set with
     * their percent-encoded equivalents
     *
     * @param {string} str - The string to encode.
     *
     * @returns {string} The encoded string.
     */
    function encode$1(str) {
      const charMap = {
        '!': '%21',
        "'": '%27',
        '(': '%28',
        ')': '%29',
        '~': '%7E',
        '%20': '+',
        '%00': '\x00'
      };
      return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
        return charMap[match];
      });
    }

    /**
     * It takes a params object and converts it to a FormData object
     *
     * @param {Object<string, any>} params - The parameters to be converted to a FormData object.
     * @param {Object<string, any>} options - The options object passed to the Axios constructor.
     *
     * @returns {void}
     */
    function AxiosURLSearchParams(params, options) {
      this._pairs = [];

      params && toFormData$1(params, this, options);
    }

    const prototype = AxiosURLSearchParams.prototype;

    prototype.append = function append(name, value) {
      this._pairs.push([name, value]);
    };

    prototype.toString = function toString(encoder) {
      const _encode = encoder ? function(value) {
        return encoder.call(this, value, encode$1);
      } : encode$1;

      return this._pairs.map(function each(pair) {
        return _encode(pair[0]) + '=' + _encode(pair[1]);
      }, '').join('&');
    };

    /**
     * It replaces all instances of the characters `:`, `$`, `,`, `+`, `[`, and `]` with their
     * URI encoded counterparts
     *
     * @param {string} val The value to be encoded.
     *
     * @returns {string} The encoded value.
     */
    function encode(val) {
      return encodeURIComponent(val).
        replace(/%3A/gi, ':').
        replace(/%24/g, '$').
        replace(/%2C/gi, ',').
        replace(/%20/g, '+');
    }

    /**
     * Build a URL by appending params to the end
     *
     * @param {string} url The base of the url (e.g., http://www.google.com)
     * @param {object} [params] The params to be appended
     * @param {?(object|Function)} options
     *
     * @returns {string} The formatted url
     */
    function buildURL(url, params, options) {
      /*eslint no-param-reassign:0*/
      if (!params) {
        return url;
      }
      
      const _encode = options && options.encode || encode;

      if (utils$1.isFunction(options)) {
        options = {
          serialize: options
        };
      } 

      const serializeFn = options && options.serialize;

      let serializedParams;

      if (serializeFn) {
        serializedParams = serializeFn(params, options);
      } else {
        serializedParams = utils$1.isURLSearchParams(params) ?
          params.toString() :
          new AxiosURLSearchParams(params, options).toString(_encode);
      }

      if (serializedParams) {
        const hashmarkIndex = url.indexOf("#");

        if (hashmarkIndex !== -1) {
          url = url.slice(0, hashmarkIndex);
        }
        url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
      }

      return url;
    }

    class InterceptorManager {
      constructor() {
        this.handlers = [];
      }

      /**
       * Add a new interceptor to the stack
       *
       * @param {Function} fulfilled The function to handle `then` for a `Promise`
       * @param {Function} rejected The function to handle `reject` for a `Promise`
       *
       * @return {Number} An ID used to remove interceptor later
       */
      use(fulfilled, rejected, options) {
        this.handlers.push({
          fulfilled,
          rejected,
          synchronous: options ? options.synchronous : false,
          runWhen: options ? options.runWhen : null
        });
        return this.handlers.length - 1;
      }

      /**
       * Remove an interceptor from the stack
       *
       * @param {Number} id The ID that was returned by `use`
       *
       * @returns {void}
       */
      eject(id) {
        if (this.handlers[id]) {
          this.handlers[id] = null;
        }
      }

      /**
       * Clear all interceptors from the stack
       *
       * @returns {void}
       */
      clear() {
        if (this.handlers) {
          this.handlers = [];
        }
      }

      /**
       * Iterate over all the registered interceptors
       *
       * This method is particularly useful for skipping over any
       * interceptors that may have become `null` calling `eject`.
       *
       * @param {Function} fn The function to call for each interceptor
       *
       * @returns {void}
       */
      forEach(fn) {
        utils$1.forEach(this.handlers, function forEachHandler(h) {
          if (h !== null) {
            fn(h);
          }
        });
      }
    }

    var transitionalDefaults = {
      silentJSONParsing: true,
      forcedJSONParsing: true,
      clarifyTimeoutError: false
    };

    var URLSearchParams$1 = typeof URLSearchParams !== 'undefined' ? URLSearchParams : AxiosURLSearchParams;

    var FormData$1 = typeof FormData !== 'undefined' ? FormData : null;

    var Blob$1 = typeof Blob !== 'undefined' ? Blob : null;

    var platform$1 = {
      isBrowser: true,
      classes: {
        URLSearchParams: URLSearchParams$1,
        FormData: FormData$1,
        Blob: Blob$1
      },
      protocols: ['http', 'https', 'file', 'blob', 'url', 'data']
    };

    const hasBrowserEnv = typeof window !== 'undefined' && typeof document !== 'undefined';

    const _navigator = typeof navigator === 'object' && navigator || undefined;

    /**
     * Determine if we're running in a standard browser environment
     *
     * This allows axios to run in a web worker, and react-native.
     * Both environments support XMLHttpRequest, but not fully standard globals.
     *
     * web workers:
     *  typeof window -> undefined
     *  typeof document -> undefined
     *
     * react-native:
     *  navigator.product -> 'ReactNative'
     * nativescript
     *  navigator.product -> 'NativeScript' or 'NS'
     *
     * @returns {boolean}
     */
    const hasStandardBrowserEnv = hasBrowserEnv &&
      (!_navigator || ['ReactNative', 'NativeScript', 'NS'].indexOf(_navigator.product) < 0);

    /**
     * Determine if we're running in a standard browser webWorker environment
     *
     * Although the `isStandardBrowserEnv` method indicates that
     * `allows axios to run in a web worker`, the WebWorker will still be
     * filtered out due to its judgment standard
     * `typeof window !== 'undefined' && typeof document !== 'undefined'`.
     * This leads to a problem when axios post `FormData` in webWorker
     */
    const hasStandardBrowserWebWorkerEnv = (() => {
      return (
        typeof WorkerGlobalScope !== 'undefined' &&
        // eslint-disable-next-line no-undef
        self instanceof WorkerGlobalScope &&
        typeof self.importScripts === 'function'
      );
    })();

    const origin = hasBrowserEnv && window.location.href || 'http://localhost';

    var utils = /*#__PURE__*/Object.freeze({
        __proto__: null,
        hasBrowserEnv: hasBrowserEnv,
        hasStandardBrowserEnv: hasStandardBrowserEnv,
        hasStandardBrowserWebWorkerEnv: hasStandardBrowserWebWorkerEnv,
        navigator: _navigator,
        origin: origin
    });

    var platform = {
      ...utils,
      ...platform$1
    };

    function toURLEncodedForm(data, options) {
      return toFormData$1(data, new platform.classes.URLSearchParams(), {
        visitor: function(value, key, path, helpers) {
          if (platform.isNode && utils$1.isBuffer(value)) {
            this.append(key, value.toString('base64'));
            return false;
          }

          return helpers.defaultVisitor.apply(this, arguments);
        },
        ...options
      });
    }

    /**
     * It takes a string like `foo[x][y][z]` and returns an array like `['foo', 'x', 'y', 'z']
     *
     * @param {string} name - The name of the property to get.
     *
     * @returns An array of strings.
     */
    function parsePropPath(name) {
      // foo[x][y][z]
      // foo.x.y.z
      // foo-x-y-z
      // foo x y z
      return utils$1.matchAll(/\w+|\[(\w*)]/g, name).map(match => {
        return match[0] === '[]' ? '' : match[1] || match[0];
      });
    }

    /**
     * Convert an array to an object.
     *
     * @param {Array<any>} arr - The array to convert to an object.
     *
     * @returns An object with the same keys and values as the array.
     */
    function arrayToObject(arr) {
      const obj = {};
      const keys = Object.keys(arr);
      let i;
      const len = keys.length;
      let key;
      for (i = 0; i < len; i++) {
        key = keys[i];
        obj[key] = arr[key];
      }
      return obj;
    }

    /**
     * It takes a FormData object and returns a JavaScript object
     *
     * @param {string} formData The FormData object to convert to JSON.
     *
     * @returns {Object<string, any> | null} The converted object.
     */
    function formDataToJSON(formData) {
      function buildPath(path, value, target, index) {
        let name = path[index++];

        if (name === '__proto__') return true;

        const isNumericKey = Number.isFinite(+name);
        const isLast = index >= path.length;
        name = !name && utils$1.isArray(target) ? target.length : name;

        if (isLast) {
          if (utils$1.hasOwnProp(target, name)) {
            target[name] = [target[name], value];
          } else {
            target[name] = value;
          }

          return !isNumericKey;
        }

        if (!target[name] || !utils$1.isObject(target[name])) {
          target[name] = [];
        }

        const result = buildPath(path, value, target[name], index);

        if (result && utils$1.isArray(target[name])) {
          target[name] = arrayToObject(target[name]);
        }

        return !isNumericKey;
      }

      if (utils$1.isFormData(formData) && utils$1.isFunction(formData.entries)) {
        const obj = {};

        utils$1.forEachEntry(formData, (name, value) => {
          buildPath(parsePropPath(name), value, obj, 0);
        });

        return obj;
      }

      return null;
    }

    /**
     * It takes a string, tries to parse it, and if it fails, it returns the stringified version
     * of the input
     *
     * @param {any} rawValue - The value to be stringified.
     * @param {Function} parser - A function that parses a string into a JavaScript object.
     * @param {Function} encoder - A function that takes a value and returns a string.
     *
     * @returns {string} A stringified version of the rawValue.
     */
    function stringifySafely(rawValue, parser, encoder) {
      if (utils$1.isString(rawValue)) {
        try {
          (parser || JSON.parse)(rawValue);
          return utils$1.trim(rawValue);
        } catch (e) {
          if (e.name !== 'SyntaxError') {
            throw e;
          }
        }
      }

      return (encoder || JSON.stringify)(rawValue);
    }

    const defaults = {

      transitional: transitionalDefaults,

      adapter: ['xhr', 'http', 'fetch'],

      transformRequest: [function transformRequest(data, headers) {
        const contentType = headers.getContentType() || '';
        const hasJSONContentType = contentType.indexOf('application/json') > -1;
        const isObjectPayload = utils$1.isObject(data);

        if (isObjectPayload && utils$1.isHTMLForm(data)) {
          data = new FormData(data);
        }

        const isFormData = utils$1.isFormData(data);

        if (isFormData) {
          return hasJSONContentType ? JSON.stringify(formDataToJSON(data)) : data;
        }

        if (utils$1.isArrayBuffer(data) ||
          utils$1.isBuffer(data) ||
          utils$1.isStream(data) ||
          utils$1.isFile(data) ||
          utils$1.isBlob(data) ||
          utils$1.isReadableStream(data)
        ) {
          return data;
        }
        if (utils$1.isArrayBufferView(data)) {
          return data.buffer;
        }
        if (utils$1.isURLSearchParams(data)) {
          headers.setContentType('application/x-www-form-urlencoded;charset=utf-8', false);
          return data.toString();
        }

        let isFileList;

        if (isObjectPayload) {
          if (contentType.indexOf('application/x-www-form-urlencoded') > -1) {
            return toURLEncodedForm(data, this.formSerializer).toString();
          }

          if ((isFileList = utils$1.isFileList(data)) || contentType.indexOf('multipart/form-data') > -1) {
            const _FormData = this.env && this.env.FormData;

            return toFormData$1(
              isFileList ? {'files[]': data} : data,
              _FormData && new _FormData(),
              this.formSerializer
            );
          }
        }

        if (isObjectPayload || hasJSONContentType ) {
          headers.setContentType('application/json', false);
          return stringifySafely(data);
        }

        return data;
      }],

      transformResponse: [function transformResponse(data) {
        const transitional = this.transitional || defaults.transitional;
        const forcedJSONParsing = transitional && transitional.forcedJSONParsing;
        const JSONRequested = this.responseType === 'json';

        if (utils$1.isResponse(data) || utils$1.isReadableStream(data)) {
          return data;
        }

        if (data && utils$1.isString(data) && ((forcedJSONParsing && !this.responseType) || JSONRequested)) {
          const silentJSONParsing = transitional && transitional.silentJSONParsing;
          const strictJSONParsing = !silentJSONParsing && JSONRequested;

          try {
            return JSON.parse(data, this.parseReviver);
          } catch (e) {
            if (strictJSONParsing) {
              if (e.name === 'SyntaxError') {
                throw AxiosError$1.from(e, AxiosError$1.ERR_BAD_RESPONSE, this, null, this.response);
              }
              throw e;
            }
          }
        }

        return data;
      }],

      /**
       * A timeout in milliseconds to abort a request. If set to 0 (default) a
       * timeout is not created.
       */
      timeout: 0,

      xsrfCookieName: 'XSRF-TOKEN',
      xsrfHeaderName: 'X-XSRF-TOKEN',

      maxContentLength: -1,
      maxBodyLength: -1,

      env: {
        FormData: platform.classes.FormData,
        Blob: platform.classes.Blob
      },

      validateStatus: function validateStatus(status) {
        return status >= 200 && status < 300;
      },

      headers: {
        common: {
          'Accept': 'application/json, text/plain, */*',
          'Content-Type': undefined
        }
      }
    };

    utils$1.forEach(['delete', 'get', 'head', 'post', 'put', 'patch'], (method) => {
      defaults.headers[method] = {};
    });

    // RawAxiosHeaders whose duplicates are ignored by node
    // c.f. https://nodejs.org/api/http.html#http_message_headers
    const ignoreDuplicateOf = utils$1.toObjectSet([
      'age', 'authorization', 'content-length', 'content-type', 'etag',
      'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',
      'last-modified', 'location', 'max-forwards', 'proxy-authorization',
      'referer', 'retry-after', 'user-agent'
    ]);

    /**
     * Parse headers into an object
     *
     * ```
     * Date: Wed, 27 Aug 2014 08:58:49 GMT
     * Content-Type: application/json
     * Connection: keep-alive
     * Transfer-Encoding: chunked
     * ```
     *
     * @param {String} rawHeaders Headers needing to be parsed
     *
     * @returns {Object} Headers parsed into an object
     */
    var parseHeaders = rawHeaders => {
      const parsed = {};
      let key;
      let val;
      let i;

      rawHeaders && rawHeaders.split('\n').forEach(function parser(line) {
        i = line.indexOf(':');
        key = line.substring(0, i).trim().toLowerCase();
        val = line.substring(i + 1).trim();

        if (!key || (parsed[key] && ignoreDuplicateOf[key])) {
          return;
        }

        if (key === 'set-cookie') {
          if (parsed[key]) {
            parsed[key].push(val);
          } else {
            parsed[key] = [val];
          }
        } else {
          parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
        }
      });

      return parsed;
    };

    const $internals = Symbol('internals');

    function normalizeHeader(header) {
      return header && String(header).trim().toLowerCase();
    }

    function normalizeValue(value) {
      if (value === false || value == null) {
        return value;
      }

      return utils$1.isArray(value) ? value.map(normalizeValue) : String(value);
    }

    function parseTokens(str) {
      const tokens = Object.create(null);
      const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
      let match;

      while ((match = tokensRE.exec(str))) {
        tokens[match[1]] = match[2];
      }

      return tokens;
    }

    const isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());

    function matchHeaderValue(context, value, header, filter, isHeaderNameFilter) {
      if (utils$1.isFunction(filter)) {
        return filter.call(this, value, header);
      }

      if (isHeaderNameFilter) {
        value = header;
      }

      if (!utils$1.isString(value)) return;

      if (utils$1.isString(filter)) {
        return value.indexOf(filter) !== -1;
      }

      if (utils$1.isRegExp(filter)) {
        return filter.test(value);
      }
    }

    function formatHeader(header) {
      return header.trim()
        .toLowerCase().replace(/([a-z\d])(\w*)/g, (w, char, str) => {
          return char.toUpperCase() + str;
        });
    }

    function buildAccessors(obj, header) {
      const accessorName = utils$1.toCamelCase(' ' + header);

      ['get', 'set', 'has'].forEach(methodName => {
        Object.defineProperty(obj, methodName + accessorName, {
          value: function(arg1, arg2, arg3) {
            return this[methodName].call(this, header, arg1, arg2, arg3);
          },
          configurable: true
        });
      });
    }

    let AxiosHeaders$1 = class AxiosHeaders {
      constructor(headers) {
        headers && this.set(headers);
      }

      set(header, valueOrRewrite, rewrite) {
        const self = this;

        function setHeader(_value, _header, _rewrite) {
          const lHeader = normalizeHeader(_header);

          if (!lHeader) {
            throw new Error('header name must be a non-empty string');
          }

          const key = utils$1.findKey(self, lHeader);

          if(!key || self[key] === undefined || _rewrite === true || (_rewrite === undefined && self[key] !== false)) {
            self[key || _header] = normalizeValue(_value);
          }
        }

        const setHeaders = (headers, _rewrite) =>
          utils$1.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));

        if (utils$1.isPlainObject(header) || header instanceof this.constructor) {
          setHeaders(header, valueOrRewrite);
        } else if(utils$1.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
          setHeaders(parseHeaders(header), valueOrRewrite);
        } else if (utils$1.isObject(header) && utils$1.isIterable(header)) {
          let obj = {}, dest, key;
          for (const entry of header) {
            if (!utils$1.isArray(entry)) {
              throw TypeError('Object iterator must return a key-value pair');
            }

            obj[key = entry[0]] = (dest = obj[key]) ?
              (utils$1.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]]) : entry[1];
          }

          setHeaders(obj, valueOrRewrite);
        } else {
          header != null && setHeader(valueOrRewrite, header, rewrite);
        }

        return this;
      }

      get(header, parser) {
        header = normalizeHeader(header);

        if (header) {
          const key = utils$1.findKey(this, header);

          if (key) {
            const value = this[key];

            if (!parser) {
              return value;
            }

            if (parser === true) {
              return parseTokens(value);
            }

            if (utils$1.isFunction(parser)) {
              return parser.call(this, value, key);
            }

            if (utils$1.isRegExp(parser)) {
              return parser.exec(value);
            }

            throw new TypeError('parser must be boolean|regexp|function');
          }
        }
      }

      has(header, matcher) {
        header = normalizeHeader(header);

        if (header) {
          const key = utils$1.findKey(this, header);

          return !!(key && this[key] !== undefined && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
        }

        return false;
      }

      delete(header, matcher) {
        const self = this;
        let deleted = false;

        function deleteHeader(_header) {
          _header = normalizeHeader(_header);

          if (_header) {
            const key = utils$1.findKey(self, _header);

            if (key && (!matcher || matchHeaderValue(self, self[key], key, matcher))) {
              delete self[key];

              deleted = true;
            }
          }
        }

        if (utils$1.isArray(header)) {
          header.forEach(deleteHeader);
        } else {
          deleteHeader(header);
        }

        return deleted;
      }

      clear(matcher) {
        const keys = Object.keys(this);
        let i = keys.length;
        let deleted = false;

        while (i--) {
          const key = keys[i];
          if(!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
            delete this[key];
            deleted = true;
          }
        }

        return deleted;
      }

      normalize(format) {
        const self = this;
        const headers = {};

        utils$1.forEach(this, (value, header) => {
          const key = utils$1.findKey(headers, header);

          if (key) {
            self[key] = normalizeValue(value);
            delete self[header];
            return;
          }

          const normalized = format ? formatHeader(header) : String(header).trim();

          if (normalized !== header) {
            delete self[header];
          }

          self[normalized] = normalizeValue(value);

          headers[normalized] = true;
        });

        return this;
      }

      concat(...targets) {
        return this.constructor.concat(this, ...targets);
      }

      toJSON(asStrings) {
        const obj = Object.create(null);

        utils$1.forEach(this, (value, header) => {
          value != null && value !== false && (obj[header] = asStrings && utils$1.isArray(value) ? value.join(', ') : value);
        });

        return obj;
      }

      [Symbol.iterator]() {
        return Object.entries(this.toJSON())[Symbol.iterator]();
      }

      toString() {
        return Object.entries(this.toJSON()).map(([header, value]) => header + ': ' + value).join('\n');
      }

      getSetCookie() {
        return this.get("set-cookie") || [];
      }

      get [Symbol.toStringTag]() {
        return 'AxiosHeaders';
      }

      static from(thing) {
        return thing instanceof this ? thing : new this(thing);
      }

      static concat(first, ...targets) {
        const computed = new this(first);

        targets.forEach((target) => computed.set(target));

        return computed;
      }

      static accessor(header) {
        const internals = this[$internals] = (this[$internals] = {
          accessors: {}
        });

        const accessors = internals.accessors;
        const prototype = this.prototype;

        function defineAccessor(_header) {
          const lHeader = normalizeHeader(_header);

          if (!accessors[lHeader]) {
            buildAccessors(prototype, _header);
            accessors[lHeader] = true;
          }
        }

        utils$1.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);

        return this;
      }
    };

    AxiosHeaders$1.accessor(['Content-Type', 'Content-Length', 'Accept', 'Accept-Encoding', 'User-Agent', 'Authorization']);

    // reserved names hotfix
    utils$1.reduceDescriptors(AxiosHeaders$1.prototype, ({value}, key) => {
      let mapped = key[0].toUpperCase() + key.slice(1); // map `set` => `Set`
      return {
        get: () => value,
        set(headerValue) {
          this[mapped] = headerValue;
        }
      }
    });

    utils$1.freezeMethods(AxiosHeaders$1);

    /**
     * Transform the data for a request or a response
     *
     * @param {Array|Function} fns A single function or Array of functions
     * @param {?Object} response The response object
     *
     * @returns {*} The resulting transformed data
     */
    function transformData(fns, response) {
      const config = this || defaults;
      const context = response || config;
      const headers = AxiosHeaders$1.from(context.headers);
      let data = context.data;

      utils$1.forEach(fns, function transform(fn) {
        data = fn.call(config, data, headers.normalize(), response ? response.status : undefined);
      });

      headers.normalize();

      return data;
    }

    function isCancel$1(value) {
      return !!(value && value.__CANCEL__);
    }

    /**
     * A `CanceledError` is an object that is thrown when an operation is canceled.
     *
     * @param {string=} message The message.
     * @param {Object=} config The config.
     * @param {Object=} request The request.
     *
     * @returns {CanceledError} The created error.
     */
    function CanceledError$1(message, config, request) {
      // eslint-disable-next-line no-eq-null,eqeqeq
      AxiosError$1.call(this, message == null ? 'canceled' : message, AxiosError$1.ERR_CANCELED, config, request);
      this.name = 'CanceledError';
    }

    utils$1.inherits(CanceledError$1, AxiosError$1, {
      __CANCEL__: true
    });

    /**
     * Resolve or reject a Promise based on response status.
     *
     * @param {Function} resolve A function that resolves the promise.
     * @param {Function} reject A function that rejects the promise.
     * @param {object} response The response.
     *
     * @returns {object} The response.
     */
    function settle(resolve, reject, response) {
      const validateStatus = response.config.validateStatus;
      if (!response.status || !validateStatus || validateStatus(response.status)) {
        resolve(response);
      } else {
        reject(new AxiosError$1(
          'Request failed with status code ' + response.status,
          [AxiosError$1.ERR_BAD_REQUEST, AxiosError$1.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
          response.config,
          response.request,
          response
        ));
      }
    }

    function parseProtocol(url) {
      const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
      return match && match[1] || '';
    }

    /**
     * Calculate data maxRate
     * @param {Number} [samplesCount= 10]
     * @param {Number} [min= 1000]
     * @returns {Function}
     */
    function speedometer(samplesCount, min) {
      samplesCount = samplesCount || 10;
      const bytes = new Array(samplesCount);
      const timestamps = new Array(samplesCount);
      let head = 0;
      let tail = 0;
      let firstSampleTS;

      min = min !== undefined ? min : 1000;

      return function push(chunkLength) {
        const now = Date.now();

        const startedAt = timestamps[tail];

        if (!firstSampleTS) {
          firstSampleTS = now;
        }

        bytes[head] = chunkLength;
        timestamps[head] = now;

        let i = tail;
        let bytesCount = 0;

        while (i !== head) {
          bytesCount += bytes[i++];
          i = i % samplesCount;
        }

        head = (head + 1) % samplesCount;

        if (head === tail) {
          tail = (tail + 1) % samplesCount;
        }

        if (now - firstSampleTS < min) {
          return;
        }

        const passed = startedAt && now - startedAt;

        return passed ? Math.round(bytesCount * 1000 / passed) : undefined;
      };
    }

    /**
     * Throttle decorator
     * @param {Function} fn
     * @param {Number} freq
     * @return {Function}
     */
    function throttle(fn, freq) {
      let timestamp = 0;
      let threshold = 1000 / freq;
      let lastArgs;
      let timer;

      const invoke = (args, now = Date.now()) => {
        timestamp = now;
        lastArgs = null;
        if (timer) {
          clearTimeout(timer);
          timer = null;
        }
        fn(...args);
      };

      const throttled = (...args) => {
        const now = Date.now();
        const passed = now - timestamp;
        if ( passed >= threshold) {
          invoke(args, now);
        } else {
          lastArgs = args;
          if (!timer) {
            timer = setTimeout(() => {
              timer = null;
              invoke(lastArgs);
            }, threshold - passed);
          }
        }
      };

      const flush = () => lastArgs && invoke(lastArgs);

      return [throttled, flush];
    }

    const progressEventReducer = (listener, isDownloadStream, freq = 3) => {
      let bytesNotified = 0;
      const _speedometer = speedometer(50, 250);

      return throttle(e => {
        const loaded = e.loaded;
        const total = e.lengthComputable ? e.total : undefined;
        const progressBytes = loaded - bytesNotified;
        const rate = _speedometer(progressBytes);
        const inRange = loaded <= total;

        bytesNotified = loaded;

        const data = {
          loaded,
          total,
          progress: total ? (loaded / total) : undefined,
          bytes: progressBytes,
          rate: rate ? rate : undefined,
          estimated: rate && total && inRange ? (total - loaded) / rate : undefined,
          event: e,
          lengthComputable: total != null,
          [isDownloadStream ? 'download' : 'upload']: true
        };

        listener(data);
      }, freq);
    };

    const progressEventDecorator = (total, throttled) => {
      const lengthComputable = total != null;

      return [(loaded) => throttled[0]({
        lengthComputable,
        total,
        loaded
      }), throttled[1]];
    };

    const asyncDecorator = (fn) => (...args) => utils$1.asap(() => fn(...args));

    var isURLSameOrigin = platform.hasStandardBrowserEnv ? ((origin, isMSIE) => (url) => {
      url = new URL(url, platform.origin);

      return (
        origin.protocol === url.protocol &&
        origin.host === url.host &&
        (isMSIE || origin.port === url.port)
      );
    })(
      new URL(platform.origin),
      platform.navigator && /(msie|trident)/i.test(platform.navigator.userAgent)
    ) : () => true;

    var cookies = platform.hasStandardBrowserEnv ?

      // Standard browser envs support document.cookie
      {
        write(name, value, expires, path, domain, secure, sameSite) {
          if (typeof document === 'undefined') return;

          const cookie = [`${name}=${encodeURIComponent(value)}`];

          if (utils$1.isNumber(expires)) {
            cookie.push(`expires=${new Date(expires).toUTCString()}`);
          }
          if (utils$1.isString(path)) {
            cookie.push(`path=${path}`);
          }
          if (utils$1.isString(domain)) {
            cookie.push(`domain=${domain}`);
          }
          if (secure === true) {
            cookie.push('secure');
          }
          if (utils$1.isString(sameSite)) {
            cookie.push(`SameSite=${sameSite}`);
          }

          document.cookie = cookie.join('; ');
        },

        read(name) {
          if (typeof document === 'undefined') return null;
          const match = document.cookie.match(new RegExp('(?:^|; )' + name + '=([^;]*)'));
          return match ? decodeURIComponent(match[1]) : null;
        },

        remove(name) {
          this.write(name, '', Date.now() - 86400000, '/');
        }
      }

      :

      // Non-standard browser env (web workers, react-native) lack needed support.
      {
        write() {},
        read() {
          return null;
        },
        remove() {}
      };

    /**
     * Determines whether the specified URL is absolute
     *
     * @param {string} url The URL to test
     *
     * @returns {boolean} True if the specified URL is absolute, otherwise false
     */
    function isAbsoluteURL(url) {
      // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
      // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
      // by any combination of letters, digits, plus, period, or hyphen.
      return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
    }

    /**
     * Creates a new URL by combining the specified URLs
     *
     * @param {string} baseURL The base URL
     * @param {string} relativeURL The relative URL
     *
     * @returns {string} The combined URL
     */
    function combineURLs(baseURL, relativeURL) {
      return relativeURL
        ? baseURL.replace(/\/?\/$/, '') + '/' + relativeURL.replace(/^\/+/, '')
        : baseURL;
    }

    /**
     * Creates a new URL by combining the baseURL with the requestedURL,
     * only when the requestedURL is not already an absolute URL.
     * If the requestURL is absolute, this function returns the requestedURL untouched.
     *
     * @param {string} baseURL The base URL
     * @param {string} requestedURL Absolute or relative URL to combine
     *
     * @returns {string} The combined full path
     */
    function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
      let isRelativeUrl = !isAbsoluteURL(requestedURL);
      if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
        return combineURLs(baseURL, requestedURL);
      }
      return requestedURL;
    }

    const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;

    /**
     * Config-specific merge-function which creates a new config-object
     * by merging two configuration objects together.
     *
     * @param {Object} config1
     * @param {Object} config2
     *
     * @returns {Object} New object resulting from merging config2 to config1
     */
    function mergeConfig$1(config1, config2) {
      // eslint-disable-next-line no-param-reassign
      config2 = config2 || {};
      const config = {};

      function getMergedValue(target, source, prop, caseless) {
        if (utils$1.isPlainObject(target) && utils$1.isPlainObject(source)) {
          return utils$1.merge.call({caseless}, target, source);
        } else if (utils$1.isPlainObject(source)) {
          return utils$1.merge({}, source);
        } else if (utils$1.isArray(source)) {
          return source.slice();
        }
        return source;
      }

      // eslint-disable-next-line consistent-return
      function mergeDeepProperties(a, b, prop, caseless) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(a, b, prop, caseless);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(undefined, a, prop, caseless);
        }
      }

      // eslint-disable-next-line consistent-return
      function valueFromConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(undefined, b);
        }
      }

      // eslint-disable-next-line consistent-return
      function defaultToConfig2(a, b) {
        if (!utils$1.isUndefined(b)) {
          return getMergedValue(undefined, b);
        } else if (!utils$1.isUndefined(a)) {
          return getMergedValue(undefined, a);
        }
      }

      // eslint-disable-next-line consistent-return
      function mergeDirectKeys(a, b, prop) {
        if (prop in config2) {
          return getMergedValue(a, b);
        } else if (prop in config1) {
          return getMergedValue(undefined, a);
        }
      }

      const mergeMap = {
        url: valueFromConfig2,
        method: valueFromConfig2,
        data: valueFromConfig2,
        baseURL: defaultToConfig2,
        transformRequest: defaultToConfig2,
        transformResponse: defaultToConfig2,
        paramsSerializer: defaultToConfig2,
        timeout: defaultToConfig2,
        timeoutMessage: defaultToConfig2,
        withCredentials: defaultToConfig2,
        withXSRFToken: defaultToConfig2,
        adapter: defaultToConfig2,
        responseType: defaultToConfig2,
        xsrfCookieName: defaultToConfig2,
        xsrfHeaderName: defaultToConfig2,
        onUploadProgress: defaultToConfig2,
        onDownloadProgress: defaultToConfig2,
        decompress: defaultToConfig2,
        maxContentLength: defaultToConfig2,
        maxBodyLength: defaultToConfig2,
        beforeRedirect: defaultToConfig2,
        transport: defaultToConfig2,
        httpAgent: defaultToConfig2,
        httpsAgent: defaultToConfig2,
        cancelToken: defaultToConfig2,
        socketPath: defaultToConfig2,
        responseEncoding: defaultToConfig2,
        validateStatus: mergeDirectKeys,
        headers: (a, b, prop) => mergeDeepProperties(headersToObject(a), headersToObject(b), prop, true)
      };

      utils$1.forEach(Object.keys({...config1, ...config2}), function computeConfigValue(prop) {
        const merge = mergeMap[prop] || mergeDeepProperties;
        const configValue = merge(config1[prop], config2[prop], prop);
        (utils$1.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);
      });

      return config;
    }

    var resolveConfig = (config) => {
      const newConfig = mergeConfig$1({}, config);

      let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;

      newConfig.headers = headers = AxiosHeaders$1.from(headers);

      newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);

      // HTTP basic authentication
      if (auth) {
        headers.set('Authorization', 'Basic ' +
          btoa((auth.username || '') + ':' + (auth.password ? unescape(encodeURIComponent(auth.password)) : ''))
        );
      }

      if (utils$1.isFormData(data)) {
        if (platform.hasStandardBrowserEnv || platform.hasStandardBrowserWebWorkerEnv) {
          headers.setContentType(undefined); // browser handles it
        } else if (utils$1.isFunction(data.getHeaders)) {
          // Node.js FormData (like form-data package)
          const formHeaders = data.getHeaders();
          // Only set safe headers to avoid overwriting security headers
          const allowedHeaders = ['content-type', 'content-length'];
          Object.entries(formHeaders).forEach(([key, val]) => {
            if (allowedHeaders.includes(key.toLowerCase())) {
              headers.set(key, val);
            }
          });
        }
      }  

      // Add xsrf header
      // This is only done if running in a standard browser environment.
      // Specifically not if we're in a web worker, or react-native.

      if (platform.hasStandardBrowserEnv) {
        withXSRFToken && utils$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));

        if (withXSRFToken || (withXSRFToken !== false && isURLSameOrigin(newConfig.url))) {
          // Add xsrf header
          const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);

          if (xsrfValue) {
            headers.set(xsrfHeaderName, xsrfValue);
          }
        }
      }

      return newConfig;
    };

    const isXHRAdapterSupported = typeof XMLHttpRequest !== 'undefined';

    var xhrAdapter = isXHRAdapterSupported && function (config) {
      return new Promise(function dispatchXhrRequest(resolve, reject) {
        const _config = resolveConfig(config);
        let requestData = _config.data;
        const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
        let {responseType, onUploadProgress, onDownloadProgress} = _config;
        let onCanceled;
        let uploadThrottled, downloadThrottled;
        let flushUpload, flushDownload;

        function done() {
          flushUpload && flushUpload(); // flush events
          flushDownload && flushDownload(); // flush events

          _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);

          _config.signal && _config.signal.removeEventListener('abort', onCanceled);
        }

        let request = new XMLHttpRequest();

        request.open(_config.method.toUpperCase(), _config.url, true);

        // Set the request timeout in MS
        request.timeout = _config.timeout;

        function onloadend() {
          if (!request) {
            return;
          }
          // Prepare the response
          const responseHeaders = AxiosHeaders$1.from(
            'getAllResponseHeaders' in request && request.getAllResponseHeaders()
          );
          const responseData = !responseType || responseType === 'text' || responseType === 'json' ?
            request.responseText : request.response;
          const response = {
            data: responseData,
            status: request.status,
            statusText: request.statusText,
            headers: responseHeaders,
            config,
            request
          };

          settle(function _resolve(value) {
            resolve(value);
            done();
          }, function _reject(err) {
            reject(err);
            done();
          }, response);

          // Clean up request
          request = null;
        }

        if ('onloadend' in request) {
          // Use onloadend if available
          request.onloadend = onloadend;
        } else {
          // Listen for ready state to emulate onloadend
          request.onreadystatechange = function handleLoad() {
            if (!request || request.readyState !== 4) {
              return;
            }

            // The request errored out and we didn't get a response, this will be
            // handled by onerror instead
            // With one exception: request that using file: protocol, most browsers
            // will return status as 0 even though it's a successful request
            if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
              return;
            }
            // readystate handler is calling before onerror or ontimeout handlers,
            // so we should call onloadend on the next 'tick'
            setTimeout(onloadend);
          };
        }

        // Handle browser request cancellation (as opposed to a manual cancellation)
        request.onabort = function handleAbort() {
          if (!request) {
            return;
          }

          reject(new AxiosError$1('Request aborted', AxiosError$1.ECONNABORTED, config, request));

          // Clean up request
          request = null;
        };

        // Handle low level network errors
      request.onerror = function handleError(event) {
           // Browsers deliver a ProgressEvent in XHR onerror
           // (message may be empty; when present, surface it)
           // See https://developer.mozilla.org/docs/Web/API/XMLHttpRequest/error_event
           const msg = event && event.message ? event.message : 'Network Error';
           const err = new AxiosError$1(msg, AxiosError$1.ERR_NETWORK, config, request);
           // attach the underlying event for consumers who want details
           err.event = event || null;
           reject(err);
           request = null;
        };
        
        // Handle timeout
        request.ontimeout = function handleTimeout() {
          let timeoutErrorMessage = _config.timeout ? 'timeout of ' + _config.timeout + 'ms exceeded' : 'timeout exceeded';
          const transitional = _config.transitional || transitionalDefaults;
          if (_config.timeoutErrorMessage) {
            timeoutErrorMessage = _config.timeoutErrorMessage;
          }
          reject(new AxiosError$1(
            timeoutErrorMessage,
            transitional.clarifyTimeoutError ? AxiosError$1.ETIMEDOUT : AxiosError$1.ECONNABORTED,
            config,
            request));

          // Clean up request
          request = null;
        };

        // Remove Content-Type if data is undefined
        requestData === undefined && requestHeaders.setContentType(null);

        // Add headers to the request
        if ('setRequestHeader' in request) {
          utils$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
            request.setRequestHeader(key, val);
          });
        }

        // Add withCredentials to request if needed
        if (!utils$1.isUndefined(_config.withCredentials)) {
          request.withCredentials = !!_config.withCredentials;
        }

        // Add responseType to request if needed
        if (responseType && responseType !== 'json') {
          request.responseType = _config.responseType;
        }

        // Handle progress if needed
        if (onDownloadProgress) {
          ([downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true));
          request.addEventListener('progress', downloadThrottled);
        }

        // Not all browsers support upload events
        if (onUploadProgress && request.upload) {
          ([uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress));

          request.upload.addEventListener('progress', uploadThrottled);

          request.upload.addEventListener('loadend', flushUpload);
        }

        if (_config.cancelToken || _config.signal) {
          // Handle cancellation
          // eslint-disable-next-line func-names
          onCanceled = cancel => {
            if (!request) {
              return;
            }
            reject(!cancel || cancel.type ? new CanceledError$1(null, config, request) : cancel);
            request.abort();
            request = null;
          };

          _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
          if (_config.signal) {
            _config.signal.aborted ? onCanceled() : _config.signal.addEventListener('abort', onCanceled);
          }
        }

        const protocol = parseProtocol(_config.url);

        if (protocol && platform.protocols.indexOf(protocol) === -1) {
          reject(new AxiosError$1('Unsupported protocol ' + protocol + ':', AxiosError$1.ERR_BAD_REQUEST, config));
          return;
        }


        // Send the request
        request.send(requestData || null);
      });
    };

    const composeSignals = (signals, timeout) => {
      const {length} = (signals = signals ? signals.filter(Boolean) : []);

      if (timeout || length) {
        let controller = new AbortController();

        let aborted;

        const onabort = function (reason) {
          if (!aborted) {
            aborted = true;
            unsubscribe();
            const err = reason instanceof Error ? reason : this.reason;
            controller.abort(err instanceof AxiosError$1 ? err : new CanceledError$1(err instanceof Error ? err.message : err));
          }
        };

        let timer = timeout && setTimeout(() => {
          timer = null;
          onabort(new AxiosError$1(`timeout ${timeout} of ms exceeded`, AxiosError$1.ETIMEDOUT));
        }, timeout);

        const unsubscribe = () => {
          if (signals) {
            timer && clearTimeout(timer);
            timer = null;
            signals.forEach(signal => {
              signal.unsubscribe ? signal.unsubscribe(onabort) : signal.removeEventListener('abort', onabort);
            });
            signals = null;
          }
        };

        signals.forEach((signal) => signal.addEventListener('abort', onabort));

        const {signal} = controller;

        signal.unsubscribe = () => utils$1.asap(unsubscribe);

        return signal;
      }
    };

    const streamChunk = function* (chunk, chunkSize) {
      let len = chunk.byteLength;

      if (len < chunkSize) {
        yield chunk;
        return;
      }

      let pos = 0;
      let end;

      while (pos < len) {
        end = pos + chunkSize;
        yield chunk.slice(pos, end);
        pos = end;
      }
    };

    const readBytes = async function* (iterable, chunkSize) {
      for await (const chunk of readStream(iterable)) {
        yield* streamChunk(chunk, chunkSize);
      }
    };

    const readStream = async function* (stream) {
      if (stream[Symbol.asyncIterator]) {
        yield* stream;
        return;
      }

      const reader = stream.getReader();
      try {
        for (;;) {
          const {done, value} = await reader.read();
          if (done) {
            break;
          }
          yield value;
        }
      } finally {
        await reader.cancel();
      }
    };

    const trackStream = (stream, chunkSize, onProgress, onFinish) => {
      const iterator = readBytes(stream, chunkSize);

      let bytes = 0;
      let done;
      let _onFinish = (e) => {
        if (!done) {
          done = true;
          onFinish && onFinish(e);
        }
      };

      return new ReadableStream({
        async pull(controller) {
          try {
            const {done, value} = await iterator.next();

            if (done) {
             _onFinish();
              controller.close();
              return;
            }

            let len = value.byteLength;
            if (onProgress) {
              let loadedBytes = bytes += len;
              onProgress(loadedBytes);
            }
            controller.enqueue(new Uint8Array(value));
          } catch (err) {
            _onFinish(err);
            throw err;
          }
        },
        cancel(reason) {
          _onFinish(reason);
          return iterator.return();
        }
      }, {
        highWaterMark: 2
      })
    };

    const DEFAULT_CHUNK_SIZE = 64 * 1024;

    const {isFunction} = utils$1;

    const globalFetchAPI = (({Request, Response}) => ({
      Request, Response
    }))(utils$1.global);

    const {
      ReadableStream: ReadableStream$1, TextEncoder
    } = utils$1.global;


    const test = (fn, ...args) => {
      try {
        return !!fn(...args);
      } catch (e) {
        return false
      }
    };

    const factory = (env) => {
      env = utils$1.merge.call({
        skipUndefined: true
      }, globalFetchAPI, env);

      const {fetch: envFetch, Request, Response} = env;
      const isFetchSupported = envFetch ? isFunction(envFetch) : typeof fetch === 'function';
      const isRequestSupported = isFunction(Request);
      const isResponseSupported = isFunction(Response);

      if (!isFetchSupported) {
        return false;
      }

      const isReadableStreamSupported = isFetchSupported && isFunction(ReadableStream$1);

      const encodeText = isFetchSupported && (typeof TextEncoder === 'function' ?
          ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) :
          async (str) => new Uint8Array(await new Request(str).arrayBuffer())
      );

      const supportsRequestStream = isRequestSupported && isReadableStreamSupported && test(() => {
        let duplexAccessed = false;

        const hasContentType = new Request(platform.origin, {
          body: new ReadableStream$1(),
          method: 'POST',
          get duplex() {
            duplexAccessed = true;
            return 'half';
          },
        }).headers.has('Content-Type');

        return duplexAccessed && !hasContentType;
      });

      const supportsResponseStream = isResponseSupported && isReadableStreamSupported &&
        test(() => utils$1.isReadableStream(new Response('').body));

      const resolvers = {
        stream: supportsResponseStream && ((res) => res.body)
      };

      isFetchSupported && ((() => {
        ['text', 'arrayBuffer', 'blob', 'formData', 'stream'].forEach(type => {
          !resolvers[type] && (resolvers[type] = (res, config) => {
            let method = res && res[type];

            if (method) {
              return method.call(res);
            }

            throw new AxiosError$1(`Response type '${type}' is not supported`, AxiosError$1.ERR_NOT_SUPPORT, config);
          });
        });
      })());

      const getBodyLength = async (body) => {
        if (body == null) {
          return 0;
        }

        if (utils$1.isBlob(body)) {
          return body.size;
        }

        if (utils$1.isSpecCompliantForm(body)) {
          const _request = new Request(platform.origin, {
            method: 'POST',
            body,
          });
          return (await _request.arrayBuffer()).byteLength;
        }

        if (utils$1.isArrayBufferView(body) || utils$1.isArrayBuffer(body)) {
          return body.byteLength;
        }

        if (utils$1.isURLSearchParams(body)) {
          body = body + '';
        }

        if (utils$1.isString(body)) {
          return (await encodeText(body)).byteLength;
        }
      };

      const resolveBodyLength = async (headers, body) => {
        const length = utils$1.toFiniteNumber(headers.getContentLength());

        return length == null ? getBodyLength(body) : length;
      };

      return async (config) => {
        let {
          url,
          method,
          data,
          signal,
          cancelToken,
          timeout,
          onDownloadProgress,
          onUploadProgress,
          responseType,
          headers,
          withCredentials = 'same-origin',
          fetchOptions
        } = resolveConfig(config);

        let _fetch = envFetch || fetch;

        responseType = responseType ? (responseType + '').toLowerCase() : 'text';

        let composedSignal = composeSignals([signal, cancelToken && cancelToken.toAbortSignal()], timeout);

        let request = null;

        const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
          composedSignal.unsubscribe();
        });

        let requestContentLength;

        try {
          if (
            onUploadProgress && supportsRequestStream && method !== 'get' && method !== 'head' &&
            (requestContentLength = await resolveBodyLength(headers, data)) !== 0
          ) {
            let _request = new Request(url, {
              method: 'POST',
              body: data,
              duplex: "half"
            });

            let contentTypeHeader;

            if (utils$1.isFormData(data) && (contentTypeHeader = _request.headers.get('content-type'))) {
              headers.setContentType(contentTypeHeader);
            }

            if (_request.body) {
              const [onProgress, flush] = progressEventDecorator(
                requestContentLength,
                progressEventReducer(asyncDecorator(onUploadProgress))
              );

              data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
            }
          }

          if (!utils$1.isString(withCredentials)) {
            withCredentials = withCredentials ? 'include' : 'omit';
          }

          // Cloudflare Workers throws when credentials are defined
          // see https://github.com/cloudflare/workerd/issues/902
          const isCredentialsSupported = isRequestSupported && "credentials" in Request.prototype;

          const resolvedOptions = {
            ...fetchOptions,
            signal: composedSignal,
            method: method.toUpperCase(),
            headers: headers.normalize().toJSON(),
            body: data,
            duplex: "half",
            credentials: isCredentialsSupported ? withCredentials : undefined
          };

          request = isRequestSupported && new Request(url, resolvedOptions);

          let response = await (isRequestSupported ? _fetch(request, fetchOptions) : _fetch(url, resolvedOptions));

          const isStreamResponse = supportsResponseStream && (responseType === 'stream' || responseType === 'response');

          if (supportsResponseStream && (onDownloadProgress || (isStreamResponse && unsubscribe))) {
            const options = {};

            ['status', 'statusText', 'headers'].forEach(prop => {
              options[prop] = response[prop];
            });

            const responseContentLength = utils$1.toFiniteNumber(response.headers.get('content-length'));

            const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
              responseContentLength,
              progressEventReducer(asyncDecorator(onDownloadProgress), true)
            ) || [];

            response = new Response(
              trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
                flush && flush();
                unsubscribe && unsubscribe();
              }),
              options
            );
          }

          responseType = responseType || 'text';

          let responseData = await resolvers[utils$1.findKey(resolvers, responseType) || 'text'](response, config);

          !isStreamResponse && unsubscribe && unsubscribe();

          return await new Promise((resolve, reject) => {
            settle(resolve, reject, {
              data: responseData,
              headers: AxiosHeaders$1.from(response.headers),
              status: response.status,
              statusText: response.statusText,
              config,
              request
            });
          })
        } catch (err) {
          unsubscribe && unsubscribe();

          if (err && err.name === 'TypeError' && /Load failed|fetch/i.test(err.message)) {
            throw Object.assign(
              new AxiosError$1('Network Error', AxiosError$1.ERR_NETWORK, config, request),
              {
                cause: err.cause || err
              }
            )
          }

          throw AxiosError$1.from(err, err && err.code, config, request);
        }
      }
    };

    const seedCache = new Map();

    const getFetch = (config) => {
      let env = (config && config.env) || {};
      const {fetch, Request, Response} = env;
      const seeds = [
        Request, Response, fetch
      ];

      let len = seeds.length, i = len,
        seed, target, map = seedCache;

      while (i--) {
        seed = seeds[i];
        target = map.get(seed);

        target === undefined && map.set(seed, target = (i ? new Map() : factory(env)));

        map = target;
      }

      return target;
    };

    getFetch();

    /**
     * Known adapters mapping.
     * Provides environment-specific adapters for Axios:
     * - `http` for Node.js
     * - `xhr` for browsers
     * - `fetch` for fetch API-based requests
     * 
     * @type {Object<string, Function|Object>}
     */
    const knownAdapters = {
      http: httpAdapter,
      xhr: xhrAdapter,
      fetch: {
        get: getFetch,
      }
    };

    // Assign adapter names for easier debugging and identification
    utils$1.forEach(knownAdapters, (fn, value) => {
      if (fn) {
        try {
          Object.defineProperty(fn, 'name', { value });
        } catch (e) {
          // eslint-disable-next-line no-empty
        }
        Object.defineProperty(fn, 'adapterName', { value });
      }
    });

    /**
     * Render a rejection reason string for unknown or unsupported adapters
     * 
     * @param {string} reason
     * @returns {string}
     */
    const renderReason = (reason) => `- ${reason}`;

    /**
     * Check if the adapter is resolved (function, null, or false)
     * 
     * @param {Function|null|false} adapter
     * @returns {boolean}
     */
    const isResolvedHandle = (adapter) => utils$1.isFunction(adapter) || adapter === null || adapter === false;

    /**
     * Get the first suitable adapter from the provided list.
     * Tries each adapter in order until a supported one is found.
     * Throws an AxiosError if no adapter is suitable.
     * 
     * @param {Array<string|Function>|string|Function} adapters - Adapter(s) by name or function.
     * @param {Object} config - Axios request configuration
     * @throws {AxiosError} If no suitable adapter is available
     * @returns {Function} The resolved adapter function
     */
    function getAdapter$1(adapters, config) {
      adapters = utils$1.isArray(adapters) ? adapters : [adapters];

      const { length } = adapters;
      let nameOrAdapter;
      let adapter;

      const rejectedReasons = {};

      for (let i = 0; i < length; i++) {
        nameOrAdapter = adapters[i];
        let id;

        adapter = nameOrAdapter;

        if (!isResolvedHandle(nameOrAdapter)) {
          adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];

          if (adapter === undefined) {
            throw new AxiosError$1(`Unknown adapter '${id}'`);
          }
        }

        if (adapter && (utils$1.isFunction(adapter) || (adapter = adapter.get(config)))) {
          break;
        }

        rejectedReasons[id || '#' + i] = adapter;
      }

      if (!adapter) {
        const reasons = Object.entries(rejectedReasons)
          .map(([id, state]) => `adapter ${id} ` +
            (state === false ? 'is not supported by the environment' : 'is not available in the build')
          );

        let s = length ?
          (reasons.length > 1 ? 'since :\n' + reasons.map(renderReason).join('\n') : ' ' + renderReason(reasons[0])) :
          'as no adapter specified';

        throw new AxiosError$1(
          `There is no suitable adapter to dispatch the request ` + s,
          'ERR_NOT_SUPPORT'
        );
      }

      return adapter;
    }

    /**
     * Exports Axios adapters and utility to resolve an adapter
     */
    var adapters = {
      /**
       * Resolve an adapter from a list of adapter names or functions.
       * @type {Function}
       */
      getAdapter: getAdapter$1,

      /**
       * Exposes all known adapters
       * @type {Object<string, Function|Object>}
       */
      adapters: knownAdapters
    };

    /**
     * Throws a `CanceledError` if cancellation has been requested.
     *
     * @param {Object} config The config that is to be used for the request
     *
     * @returns {void}
     */
    function throwIfCancellationRequested(config) {
      if (config.cancelToken) {
        config.cancelToken.throwIfRequested();
      }

      if (config.signal && config.signal.aborted) {
        throw new CanceledError$1(null, config);
      }
    }

    /**
     * Dispatch a request to the server using the configured adapter.
     *
     * @param {object} config The config that is to be used for the request
     *
     * @returns {Promise} The Promise to be fulfilled
     */
    function dispatchRequest(config) {
      throwIfCancellationRequested(config);

      config.headers = AxiosHeaders$1.from(config.headers);

      // Transform request data
      config.data = transformData.call(
        config,
        config.transformRequest
      );

      if (['post', 'put', 'patch'].indexOf(config.method) !== -1) {
        config.headers.setContentType('application/x-www-form-urlencoded', false);
      }

      const adapter = adapters.getAdapter(config.adapter || defaults.adapter, config);

      return adapter(config).then(function onAdapterResolution(response) {
        throwIfCancellationRequested(config);

        // Transform response data
        response.data = transformData.call(
          config,
          config.transformResponse,
          response
        );

        response.headers = AxiosHeaders$1.from(response.headers);

        return response;
      }, function onAdapterRejection(reason) {
        if (!isCancel$1(reason)) {
          throwIfCancellationRequested(config);

          // Transform response data
          if (reason && reason.response) {
            reason.response.data = transformData.call(
              config,
              config.transformResponse,
              reason.response
            );
            reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
          }
        }

        return Promise.reject(reason);
      });
    }

    const VERSION$1 = "1.13.2";

    const validators$1 = {};

    // eslint-disable-next-line func-names
    ['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach((type, i) => {
      validators$1[type] = function validator(thing) {
        return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
      };
    });

    const deprecatedWarnings = {};

    /**
     * Transitional option validator
     *
     * @param {function|boolean?} validator - set to false if the transitional option has been removed
     * @param {string?} version - deprecated version / removed since version
     * @param {string?} message - some message with additional info
     *
     * @returns {function}
     */
    validators$1.transitional = function transitional(validator, version, message) {
      function formatMessage(opt, desc) {
        return '[Axios v' + VERSION$1 + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
      }

      // eslint-disable-next-line func-names
      return (value, opt, opts) => {
        if (validator === false) {
          throw new AxiosError$1(
            formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')),
            AxiosError$1.ERR_DEPRECATED
          );
        }

        if (version && !deprecatedWarnings[opt]) {
          deprecatedWarnings[opt] = true;
          // eslint-disable-next-line no-console
          console.warn(
            formatMessage(
              opt,
              ' has been deprecated since v' + version + ' and will be removed in the near future'
            )
          );
        }

        return validator ? validator(value, opt, opts) : true;
      };
    };

    validators$1.spelling = function spelling(correctSpelling) {
      return (value, opt) => {
        // eslint-disable-next-line no-console
        console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
        return true;
      }
    };

    /**
     * Assert object's properties type
     *
     * @param {object} options
     * @param {object} schema
     * @param {boolean?} allowUnknown
     *
     * @returns {object}
     */

    function assertOptions(options, schema, allowUnknown) {
      if (typeof options !== 'object') {
        throw new AxiosError$1('options must be an object', AxiosError$1.ERR_BAD_OPTION_VALUE);
      }
      const keys = Object.keys(options);
      let i = keys.length;
      while (i-- > 0) {
        const opt = keys[i];
        const validator = schema[opt];
        if (validator) {
          const value = options[opt];
          const result = value === undefined || validator(value, opt, options);
          if (result !== true) {
            throw new AxiosError$1('option ' + opt + ' must be ' + result, AxiosError$1.ERR_BAD_OPTION_VALUE);
          }
          continue;
        }
        if (allowUnknown !== true) {
          throw new AxiosError$1('Unknown option ' + opt, AxiosError$1.ERR_BAD_OPTION);
        }
      }
    }

    var validator = {
      assertOptions,
      validators: validators$1
    };

    const validators = validator.validators;

    /**
     * Create a new instance of Axios
     *
     * @param {Object} instanceConfig The default config for the instance
     *
     * @return {Axios} A new instance of Axios
     */
    let Axios$1 = class Axios {
      constructor(instanceConfig) {
        this.defaults = instanceConfig || {};
        this.interceptors = {
          request: new InterceptorManager(),
          response: new InterceptorManager()
        };
      }

      /**
       * Dispatch a request
       *
       * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
       * @param {?Object} config
       *
       * @returns {Promise} The Promise to be fulfilled
       */
      async request(configOrUrl, config) {
        try {
          return await this._request(configOrUrl, config);
        } catch (err) {
          if (err instanceof Error) {
            let dummy = {};

            Error.captureStackTrace ? Error.captureStackTrace(dummy) : (dummy = new Error());

            // slice off the Error: ... line
            const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, '') : '';
            try {
              if (!err.stack) {
                err.stack = stack;
                // match without the 2 top stack lines
              } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ''))) {
                err.stack += '\n' + stack;
              }
            } catch (e) {
              // ignore the case where "stack" is an un-writable property
            }
          }

          throw err;
        }
      }

      _request(configOrUrl, config) {
        /*eslint no-param-reassign:0*/
        // Allow for axios('example/url'[, config]) a la fetch API
        if (typeof configOrUrl === 'string') {
          config = config || {};
          config.url = configOrUrl;
        } else {
          config = configOrUrl || {};
        }

        config = mergeConfig$1(this.defaults, config);

        const {transitional, paramsSerializer, headers} = config;

        if (transitional !== undefined) {
          validator.assertOptions(transitional, {
            silentJSONParsing: validators.transitional(validators.boolean),
            forcedJSONParsing: validators.transitional(validators.boolean),
            clarifyTimeoutError: validators.transitional(validators.boolean)
          }, false);
        }

        if (paramsSerializer != null) {
          if (utils$1.isFunction(paramsSerializer)) {
            config.paramsSerializer = {
              serialize: paramsSerializer
            };
          } else {
            validator.assertOptions(paramsSerializer, {
              encode: validators.function,
              serialize: validators.function
            }, true);
          }
        }

        // Set config.allowAbsoluteUrls
        if (config.allowAbsoluteUrls !== undefined) ; else if (this.defaults.allowAbsoluteUrls !== undefined) {
          config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
        } else {
          config.allowAbsoluteUrls = true;
        }

        validator.assertOptions(config, {
          baseUrl: validators.spelling('baseURL'),
          withXsrfToken: validators.spelling('withXSRFToken')
        }, true);

        // Set config.method
        config.method = (config.method || this.defaults.method || 'get').toLowerCase();

        // Flatten headers
        let contextHeaders = headers && utils$1.merge(
          headers.common,
          headers[config.method]
        );

        headers && utils$1.forEach(
          ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],
          (method) => {
            delete headers[method];
          }
        );

        config.headers = AxiosHeaders$1.concat(contextHeaders, headers);

        // filter out skipped interceptors
        const requestInterceptorChain = [];
        let synchronousRequestInterceptors = true;
        this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
          if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
            return;
          }

          synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;

          requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
        });

        const responseInterceptorChain = [];
        this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
          responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
        });

        let promise;
        let i = 0;
        let len;

        if (!synchronousRequestInterceptors) {
          const chain = [dispatchRequest.bind(this), undefined];
          chain.unshift(...requestInterceptorChain);
          chain.push(...responseInterceptorChain);
          len = chain.length;

          promise = Promise.resolve(config);

          while (i < len) {
            promise = promise.then(chain[i++], chain[i++]);
          }

          return promise;
        }

        len = requestInterceptorChain.length;

        let newConfig = config;

        while (i < len) {
          const onFulfilled = requestInterceptorChain[i++];
          const onRejected = requestInterceptorChain[i++];
          try {
            newConfig = onFulfilled(newConfig);
          } catch (error) {
            onRejected.call(this, error);
            break;
          }
        }

        try {
          promise = dispatchRequest.call(this, newConfig);
        } catch (error) {
          return Promise.reject(error);
        }

        i = 0;
        len = responseInterceptorChain.length;

        while (i < len) {
          promise = promise.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
        }

        return promise;
      }

      getUri(config) {
        config = mergeConfig$1(this.defaults, config);
        const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
        return buildURL(fullPath, config.params, config.paramsSerializer);
      }
    };

    // Provide aliases for supported request methods
    utils$1.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
      /*eslint func-names:0*/
      Axios$1.prototype[method] = function(url, config) {
        return this.request(mergeConfig$1(config || {}, {
          method,
          url,
          data: (config || {}).data
        }));
      };
    });

    utils$1.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
      /*eslint func-names:0*/

      function generateHTTPMethod(isForm) {
        return function httpMethod(url, data, config) {
          return this.request(mergeConfig$1(config || {}, {
            method,
            headers: isForm ? {
              'Content-Type': 'multipart/form-data'
            } : {},
            url,
            data
          }));
        };
      }

      Axios$1.prototype[method] = generateHTTPMethod();

      Axios$1.prototype[method + 'Form'] = generateHTTPMethod(true);
    });

    /**
     * A `CancelToken` is an object that can be used to request cancellation of an operation.
     *
     * @param {Function} executor The executor function.
     *
     * @returns {CancelToken}
     */
    let CancelToken$1 = class CancelToken {
      constructor(executor) {
        if (typeof executor !== 'function') {
          throw new TypeError('executor must be a function.');
        }

        let resolvePromise;

        this.promise = new Promise(function promiseExecutor(resolve) {
          resolvePromise = resolve;
        });

        const token = this;

        // eslint-disable-next-line func-names
        this.promise.then(cancel => {
          if (!token._listeners) return;

          let i = token._listeners.length;

          while (i-- > 0) {
            token._listeners[i](cancel);
          }
          token._listeners = null;
        });

        // eslint-disable-next-line func-names
        this.promise.then = onfulfilled => {
          let _resolve;
          // eslint-disable-next-line func-names
          const promise = new Promise(resolve => {
            token.subscribe(resolve);
            _resolve = resolve;
          }).then(onfulfilled);

          promise.cancel = function reject() {
            token.unsubscribe(_resolve);
          };

          return promise;
        };

        executor(function cancel(message, config, request) {
          if (token.reason) {
            // Cancellation has already been requested
            return;
          }

          token.reason = new CanceledError$1(message, config, request);
          resolvePromise(token.reason);
        });
      }

      /**
       * Throws a `CanceledError` if cancellation has been requested.
       */
      throwIfRequested() {
        if (this.reason) {
          throw this.reason;
        }
      }

      /**
       * Subscribe to the cancel signal
       */

      subscribe(listener) {
        if (this.reason) {
          listener(this.reason);
          return;
        }

        if (this._listeners) {
          this._listeners.push(listener);
        } else {
          this._listeners = [listener];
        }
      }

      /**
       * Unsubscribe from the cancel signal
       */

      unsubscribe(listener) {
        if (!this._listeners) {
          return;
        }
        const index = this._listeners.indexOf(listener);
        if (index !== -1) {
          this._listeners.splice(index, 1);
        }
      }

      toAbortSignal() {
        const controller = new AbortController();

        const abort = (err) => {
          controller.abort(err);
        };

        this.subscribe(abort);

        controller.signal.unsubscribe = () => this.unsubscribe(abort);

        return controller.signal;
      }

      /**
       * Returns an object that contains a new `CancelToken` and a function that, when called,
       * cancels the `CancelToken`.
       */
      static source() {
        let cancel;
        const token = new CancelToken(function executor(c) {
          cancel = c;
        });
        return {
          token,
          cancel
        };
      }
    };

    /**
     * Syntactic sugar for invoking a function and expanding an array for arguments.
     *
     * Common use case would be to use `Function.prototype.apply`.
     *
     *  ```js
     *  function f(x, y, z) {}
     *  var args = [1, 2, 3];
     *  f.apply(null, args);
     *  ```
     *
     * With `spread` this example can be re-written.
     *
     *  ```js
     *  spread(function(x, y, z) {})([1, 2, 3]);
     *  ```
     *
     * @param {Function} callback
     *
     * @returns {Function}
     */
    function spread$1(callback) {
      return function wrap(arr) {
        return callback.apply(null, arr);
      };
    }

    /**
     * Determines whether the payload is an error thrown by Axios
     *
     * @param {*} payload The value to test
     *
     * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
     */
    function isAxiosError$1(payload) {
      return utils$1.isObject(payload) && (payload.isAxiosError === true);
    }

    const HttpStatusCode$1 = {
      Continue: 100,
      SwitchingProtocols: 101,
      Processing: 102,
      EarlyHints: 103,
      Ok: 200,
      Created: 201,
      Accepted: 202,
      NonAuthoritativeInformation: 203,
      NoContent: 204,
      ResetContent: 205,
      PartialContent: 206,
      MultiStatus: 207,
      AlreadyReported: 208,
      ImUsed: 226,
      MultipleChoices: 300,
      MovedPermanently: 301,
      Found: 302,
      SeeOther: 303,
      NotModified: 304,
      UseProxy: 305,
      Unused: 306,
      TemporaryRedirect: 307,
      PermanentRedirect: 308,
      BadRequest: 400,
      Unauthorized: 401,
      PaymentRequired: 402,
      Forbidden: 403,
      NotFound: 404,
      MethodNotAllowed: 405,
      NotAcceptable: 406,
      ProxyAuthenticationRequired: 407,
      RequestTimeout: 408,
      Conflict: 409,
      Gone: 410,
      LengthRequired: 411,
      PreconditionFailed: 412,
      PayloadTooLarge: 413,
      UriTooLong: 414,
      UnsupportedMediaType: 415,
      RangeNotSatisfiable: 416,
      ExpectationFailed: 417,
      ImATeapot: 418,
      MisdirectedRequest: 421,
      UnprocessableEntity: 422,
      Locked: 423,
      FailedDependency: 424,
      TooEarly: 425,
      UpgradeRequired: 426,
      PreconditionRequired: 428,
      TooManyRequests: 429,
      RequestHeaderFieldsTooLarge: 431,
      UnavailableForLegalReasons: 451,
      InternalServerError: 500,
      NotImplemented: 501,
      BadGateway: 502,
      ServiceUnavailable: 503,
      GatewayTimeout: 504,
      HttpVersionNotSupported: 505,
      VariantAlsoNegotiates: 506,
      InsufficientStorage: 507,
      LoopDetected: 508,
      NotExtended: 510,
      NetworkAuthenticationRequired: 511,
      WebServerIsDown: 521,
      ConnectionTimedOut: 522,
      OriginIsUnreachable: 523,
      TimeoutOccurred: 524,
      SslHandshakeFailed: 525,
      InvalidSslCertificate: 526,
    };

    Object.entries(HttpStatusCode$1).forEach(([key, value]) => {
      HttpStatusCode$1[value] = key;
    });

    /**
     * Create an instance of Axios
     *
     * @param {Object} defaultConfig The default config for the instance
     *
     * @returns {Axios} A new instance of Axios
     */
    function createInstance(defaultConfig) {
      const context = new Axios$1(defaultConfig);
      const instance = bind(Axios$1.prototype.request, context);

      // Copy axios.prototype to instance
      utils$1.extend(instance, Axios$1.prototype, context, {allOwnKeys: true});

      // Copy context to instance
      utils$1.extend(instance, context, null, {allOwnKeys: true});

      // Factory for creating new instances
      instance.create = function create(instanceConfig) {
        return createInstance(mergeConfig$1(defaultConfig, instanceConfig));
      };

      return instance;
    }

    // Create the default instance to be exported
    const axios = createInstance(defaults);

    // Expose Axios class to allow class inheritance
    axios.Axios = Axios$1;

    // Expose Cancel & CancelToken
    axios.CanceledError = CanceledError$1;
    axios.CancelToken = CancelToken$1;
    axios.isCancel = isCancel$1;
    axios.VERSION = VERSION$1;
    axios.toFormData = toFormData$1;

    // Expose AxiosError class
    axios.AxiosError = AxiosError$1;

    // alias for CanceledError for backward compatibility
    axios.Cancel = axios.CanceledError;

    // Expose all/spread
    axios.all = function all(promises) {
      return Promise.all(promises);
    };

    axios.spread = spread$1;

    // Expose isAxiosError
    axios.isAxiosError = isAxiosError$1;

    // Expose mergeConfig
    axios.mergeConfig = mergeConfig$1;

    axios.AxiosHeaders = AxiosHeaders$1;

    axios.formToJSON = thing => formDataToJSON(utils$1.isHTMLForm(thing) ? new FormData(thing) : thing);

    axios.getAdapter = adapters.getAdapter;

    axios.HttpStatusCode = HttpStatusCode$1;

    axios.default = axios;

    // This module is intended to unwrap Axios default export as named.
    // Keep top-level export same with static properties
    // so that it can keep same with es module or cjs
    const {
      Axios,
      AxiosError,
      CanceledError,
      isCancel,
      CancelToken,
      VERSION,
      all,
      Cancel,
      isAxiosError,
      spread,
      toFormData,
      AxiosHeaders,
      HttpStatusCode,
      formToJSON,
      getAdapter,
      mergeConfig
    } = axios;

    var service = axios.create({
        // baseURL: baseURL(), // 
        baseURL: process.env.REACT_APP_DEVLOPMENT_BASE_UL, // 
        timeout: 30000,
        // headers: { 'Content-Type': 'application/json' ,'x-access-token':localStorage.getItem('token')},
        headers: {
            Accept: "application/json",
            "X-Requested-with": "XMLHTTPRequest",
            "Content-Type": "application/json",
        },
        withCredentials: true,
    });
    // 
    service.interceptors.request.use(function (config) {
        var token = localStorage.getItem("token");
        if (token) {
            config.headers["x-access-token"] = token;
        }
        return config;
    }, function (error) {
        staticMethods.open({
            type: "error",
            content: error.message,
        });
        return Promise.reject(error);
    });
    // 
    service.interceptors.response.use(function (response) {
        var _a = response.data, code = _a.code, msg = _a.msg;
        if (code !== 0 && msg && msg.length) {
            staticMethods.open({
                type: "error",
                content: msg,
            });
        }
        return response;
    }, function (error) {
        var _a;
        // http
        var message = "";
        var status = (_a = error.response) === null || _a === void 0 ? void 0 : _a.status;
        switch (status) {
            case 401:
                message = "token ";
                // localStorage.removeItem("token");
                localStorage.clear();
                window.location.href = "/login";
                //  action
                break;
            case 403:
                message = "";
                break;
            case 404:
                message = "";
                break;
            case 500:
                message = "";
                break;
            case 600:
                message = "token ";
                localStorage.clear();
                window.location.href = "/login";
                break;
            case 601:
                message = "";
                // localStorage.removeItem("token");
                // window.location.href = "/login";
                break;
            default:
                message = "";
        }
        if (status !== 404 && message.length) {
            staticMethods.open({
                type: "error",
                content: message,
            });
        }
        return error.response;
        // return error;
        // return Promise.reject(error);
    });
    var request = {
        get: function (url, params, config) {
            return service.get(url, __assign({ params: __assign({}, params) }, config));
        },
        post: function (url, data, config) {
            return service.post(url, data, __assign({}, config));
        },
        put: function (url, data, config) {
            return service.put(url, data, config);
        },
        patch: function (url, data, config) {
            return service.patch(url, data, config);
        },
        delete: function (url, config) {
            return service.delete(url, __assign({}, config));
        },
    };

    // 
    var Login$1 = function (data) {
        return request.post("/login", data);
    };
    // 
    var GetCaptcha = function () {
        return request.get("/captcha");
    };
    // 
    var GetUserList = function (data) {
        return request.get("/users", data);
    };

    var user = /*#__PURE__*/Object.freeze({
        __proto__: null,
        GetCaptcha: GetCaptcha,
        GetUserList: GetUserList,
        Login: Login$1
    });

    var api = { user: user };

    // 
    var ToLogin = function (data, changeLoading, toHome) {
        changeLoading(true);
        api.user.Login(data).then(function (res) {
            var _a, _b;
            console.log("", res);
            changeLoading(false);
            if (((_a = res === null || res === void 0 ? void 0 : res.data) === null || _a === void 0 ? void 0 : _a.code) === 0) {
                var loginInfo = ((_b = res === null || res === void 0 ? void 0 : res.data) === null || _b === void 0 ? void 0 : _b.data) || null;
                if (loginInfo) {
                    localStorage.setItem("userInfo", JSON.stringify(loginInfo));
                    localStorage.setItem("token", loginInfo === null || loginInfo === void 0 ? void 0 : loginInfo.crm_token);
                }
            }
        });
    };

    var css_248z = ".accessibility-page{background-color:#f5f5f5;display:flex;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,sans-serif;height:100vh}.nav-sidebar{background:#fff;border-right:1px solid #e0e0e0;box-shadow:2px 0 10px #0000000d;display:flex;flex-direction:column;padding:20px 0;width:80px;z-index:10}.nav-header{border-bottom:1px solid #e0e0e0;margin-bottom:20px;padding:0 10px 20px;text-align:center}.nav-header h2{color:#666;font-size:14px;font-weight:500;line-height:1.4;margin:0;word-break:break-word}.nav-icons{flex:1;flex-direction:column;gap:15px}.nav-icon,.nav-icons{align-items:center;display:flex}.nav-icon{background:#fff;border:2px solid;border-radius:12px;cursor:pointer;flex-direction:column;height:60px;justify-content:center;padding:5px;transition:all .3s ease;width:60px}.nav-icon:hover{box-shadow:0 4px 12px #00000026;transform:translateY(-2px)}.nav-icon.active{box-shadow:0 6px 20px #0003;transform:scale(1.05)}.icon{font-size:20px;margin-bottom:4px}.icon-title{color:#333;font-size:10px;font-weight:500;line-height:1.2;text-align:center}.main-content{display:flex;flex:1;flex-direction:column;overflow:hidden}.fixed-title-bar{background:#fff;border-bottom:1px solid #e0e0e0;opacity:0;padding:16px 24px;position:sticky;top:0;transform:translateY(-100%);transition:all .3s ease;z-index:5}.fixed-title-bar.visible{box-shadow:0 2px 10px #0000001a;opacity:1;transform:translateY(0)}.fixed-title-content{align-items:center;display:flex;gap:12px}.fixed-icon{font-size:20px}.fixed-text{color:#333;font-size:18px;font-weight:600}.content-container{background:linear-gradient(180deg,#f8f9fa,#f5f5f5);flex:1;overflow-y:auto;padding:24px}.module-section{background:#fff;border:1px solid #e0e0e0;border-radius:12px;box-shadow:0 2px 8px #00000014;margin-bottom:24px;overflow:hidden}.module-header{background:linear-gradient(135deg,#f8f9fa,#fff);border-bottom:2px solid #4caf50;padding:20px 24px}.module-header h2{align-items:center;color:#333;display:flex;font-size:20px;font-weight:600;gap:10px;margin:0}.module-header h2:before{content:attr(data-icon);font-size:18px}.module-content{padding:24px}.section-divider{background:linear-gradient(90deg,#0000,#e0e0e0,#0000);height:1px;margin:32px 0}.content-spacer{height:100px}.info-row{align-items:center;border-bottom:1px solid #f0f0f0;display:flex;padding:12px 0}.info-row:last-child{border-bottom:none}.label{color:#666;font-weight:500;width:180px}.label,.value{font-size:14px}.value{color:#333;flex:1;font-weight:400}.checkbox-row{align-items:center;border-bottom:1px solid #f0f0f0;display:flex;padding:12px 0}.checkbox-label{font-size:16px;width:40px}.checkbox-text{color:#999;flex:1;font-size:14px;font-style:italic}.status-close{background:#ffebee;border-radius:4px;color:#f44336;font-weight:500;padding:2px 8px}.journey-note{border-bottom:1px dashed #e0e0e0;color:#666;font-style:italic;margin-bottom:16px;padding-bottom:12px}.journey-table{background:#fff;border:1px solid #e0e0e0;border-radius:8px;overflow:hidden}.journey-table table{border-collapse:collapse;width:100%}.journey-table th{background:#f8f9fa;border-bottom:2px solid #e0e0e0;color:#333;font-size:14px;font-weight:600;padding:12px 16px;text-align:left}.journey-table td{border-bottom:1px solid #f0f0f0;color:#555;font-size:14px;padding:10px 16px}.journey-table tr:last-child td{border-bottom:none}.journey-table tr:hover{background:#fafafa}.content-container::-webkit-scrollbar{width:8px}.content-container::-webkit-scrollbar-track{background:#f1f1f1;border-radius:4px}.content-container::-webkit-scrollbar-thumb{background:#c1c1c1;border-radius:4px}.content-container::-webkit-scrollbar-thumb:hover{background:#a8a8a8}";
    styleInject(css_248z);

    var AccessibilityPage = function () {
        var _a;
        // refs
        var userInfoRef = reactExports.useRef(null);
        var ticketInfoRef = reactExports.useRef(null);
        var userJourneyRef = reactExports.useRef(null);
        var containerRef = reactExports.useRef(null);
        var _b = reactExports.useState(''), fixedTitle = _b[0], setFixedTitle = _b[1];
        var _c = reactExports.useState('user-info'), currentModule = _c[0], setCurrentModule = _c[1];
        var _d = reactExports.useState(false), isScrolling = _d[0], setIsScrolling = _d[1];
        // 
        var modules = [
            {
                id: 'user-info',
                icon: '',
                title: 'User Info',
                color: '#4CAF50',
                content: (React.createElement("div", { className: "user-info-content" },
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Username:"),
                        React.createElement("span", { className: "value" }, "Erin")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "User Source:"),
                        React.createElement("span", { className: "value" }, "\uD83D\uDCBA")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Phone:"),
                        React.createElement("span", { className: "value" }, "6281519140316")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "User Tags:"),
                        React.createElement("span", { className: "value" }, "\uD83D\uDCBB")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "User Group:"),
                        React.createElement("span", { className: "value" }, "\uD83D\uDCBB")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Customer language:"),
                        React.createElement("span", { className: "value" }, "English \uD83D\uDCBB")))),
            },
            {
                id: 'ticket-info',
                icon: '',
                title: 'Ticket Information',
                color: '#2196F3',
                content: (React.createElement("div", { className: "ticket-info-content" },
                    React.createElement("div", { className: "checkbox-row" },
                        React.createElement("span", { className: "checkbox-label" }, "\uD83D\uDD0D \uD83D\uDD0D"),
                        React.createElement("span", { className: "checkbox-text" }, "\u8BF7\u586B\u5199")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Ticket Number:"),
                        React.createElement("span", { className: "value" }, "2025120415805524")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Ticket Type:"),
                        React.createElement("span", { className: "value" }, "\u552E\u524D\u54A8\u8BE2")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Sub-type:"),
                        React.createElement("span", { className: "value" }, "\uD83D\uDCBB")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Ticket Status:"),
                        React.createElement("span", { className: "value status-close" }, "CLOSE")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "SLA:"),
                        React.createElement("span", { className: "value" }, "-")),
                    React.createElement("div", { className: "info-row" },
                        React.createElement("span", { className: "label" }, "Details:"),
                        React.createElement("span", { className: "value" }, "\uD83D\uDCBB")))),
            },
            {
                id: 'user-journey',
                icon: '',
                title: 'User journey',
                color: '#9C27B0',
                content: (React.createElement("div", { className: "user-journey-content" },
                    React.createElement("div", { className: "journey-header" },
                        React.createElement("div", { className: "journey-note" }, "Please fill in the log"),
                        React.createElement("div", { className: "journey-table" },
                            React.createElement("table", null,
                                React.createElement("thead", null,
                                    React.createElement("tr", null,
                                        React.createElement("th", { style: { width: '60%' } }),
                                        React.createElement("th", { style: { width: '40%' } }, "Submit"))),
                                React.createElement("tbody", null, [
                                    { date: '2025-10-16 19:21:12', submit: 'incs_3' },
                                    { date: 'Voice chat with customer00:12 ~', submit: 'incs_3' },
                                    { date: '2025-10-16 18:52:58', submit: 'incs_3' },
                                    { date: 'Voice chat with customer00:16 ~', submit: 'incs_3' },
                                    { date: '2025-10-16 18:52:55', submit: 'incs_3' },
                                    { date: 'Voice chat with customer00:16 ~', submit: 'incs_3' },
                                    { date: '2025-10-16 18:48:33', submit: 'incs_3' },
                                ].map(function (row, index) { return (React.createElement("tr", { key: index },
                                    React.createElement("td", null, row.date),
                                    React.createElement("td", null, row.submit))); }))))))),
            },
        ];
        // 
        var handleNavClick = function (moduleId) {
            var _a;
            var moduleRefs = {
                'user-info': userInfoRef,
                'ticket-info': ticketInfoRef,
                'user-journey': userJourneyRef,
            };
            var ref = moduleRefs[moduleId];
            if ((ref === null || ref === void 0 ? void 0 : ref.current) && containerRef.current) {
                setIsScrolling(true);
                setCurrentModule(moduleId);
                setFixedTitle(((_a = modules.find(function (m) { return m.id === moduleId; })) === null || _a === void 0 ? void 0 : _a.title) || '');
                // 
                var container = containerRef.current;
                var moduleTop = ref.current.offsetTop;
                container.scrollTo({
                    top: moduleTop,
                    behavior: 'smooth',
                });
                // 
                setTimeout(function () { return setIsScrolling(false); }, 500);
            }
        };
        // 
        reactExports.useEffect(function () {
            var container = containerRef.current;
            if (!container)
                return;
            var handleScroll = function () {
                var _a, _b, _c, _d;
                if (isScrolling)
                    return; // 
                var scrollTop = container.scrollTop;
                container.clientHeight;
                // 
                var modulePositions = [
                    { id: 'user-info', top: ((_a = userInfoRef.current) === null || _a === void 0 ? void 0 : _a.offsetTop) || 0 },
                    { id: 'ticket-info', top: ((_b = ticketInfoRef.current) === null || _b === void 0 ? void 0 : _b.offsetTop) || 0 },
                    { id: 'user-journey', top: ((_c = userJourneyRef.current) === null || _c === void 0 ? void 0 : _c.offsetTop) || 0 },
                ];
                // 
                var currentVisibleModule = modulePositions[0].id;
                for (var i = modulePositions.length - 1; i >= 0; i--) {
                    if (scrollTop + 100 >= modulePositions[i].top) {
                        currentVisibleModule = modulePositions[i].id;
                        break;
                    }
                }
                // 
                if (currentVisibleModule !== currentModule) {
                    setCurrentModule(currentVisibleModule);
                }
                // 
                var currentModuleData = modules.find(function (m) { return m.id === currentVisibleModule; });
                if (currentModuleData) {
                    var currentModuleTop = ((_d = modulePositions.find(function (m) { return m.id === currentVisibleModule; })) === null || _d === void 0 ? void 0 : _d.top) || 0;
                    if (scrollTop > currentModuleTop + 20) {
                        setFixedTitle(currentModuleData.title);
                    }
                    else {
                        setFixedTitle('');
                    }
                }
            };
            container.addEventListener('scroll', handleScroll);
            return function () { return container.removeEventListener('scroll', handleScroll); };
        }, [currentModule, isScrolling, modules]);
        return (React.createElement("div", { className: "accessibility-page" },
            React.createElement("div", { className: "nav-sidebar" },
                React.createElement("div", { className: "nav-header" },
                    React.createElement("h2", null, "Accessibility")),
                React.createElement("div", { className: "nav-icons" }, modules.map(function (module) { return (React.createElement("button", { key: module.id, className: "nav-icon ".concat(currentModule === module.id ? 'active' : ''), onClick: function () { return handleNavClick(module.id); }, style: { borderColor: module.color }, title: module.title },
                    React.createElement("span", { className: "icon" }, module.icon),
                    React.createElement("span", { className: "icon-title" }, module.title))); }))),
            React.createElement("div", { className: "main-content" },
                React.createElement("div", { className: "fixed-title-bar ".concat(fixedTitle ? 'visible' : '') },
                    React.createElement("div", { className: "fixed-title-content" },
                        React.createElement("span", { className: "fixed-icon" }, (_a = modules.find(function (m) { return m.id === currentModule; })) === null || _a === void 0 ? void 0 : _a.icon),
                        React.createElement("span", { className: "fixed-text" }, fixedTitle))),
                React.createElement("div", { className: "content-container", ref: containerRef },
                    React.createElement("div", { className: "module-section", ref: userInfoRef, "data-module": "user-info" },
                        fixedTitle !== 'User Info' && (React.createElement("div", { className: "module-header" },
                            React.createElement("h2", null, "User Info"))),
                        React.createElement("div", { className: "module-content" }, modules[0].content)),
                    React.createElement("div", { className: "section-divider" }),
                    React.createElement("div", { className: "module-section", ref: ticketInfoRef, "data-module": "ticket-info" },
                        fixedTitle !== 'Ticket Information' && (React.createElement("div", { className: "module-header" },
                            React.createElement("h2", null, "Ticket Information"))),
                        React.createElement("div", { className: "module-content" }, modules[1].content)),
                    React.createElement("div", { className: "section-divider" }),
                    React.createElement("div", { className: "module-section", ref: userJourneyRef, "data-module": "user-journey" },
                        fixedTitle !== 'User journey' && (React.createElement("div", { className: "module-header" },
                            React.createElement("h2", null, "User journey"))),
                        React.createElement("div", { className: "module-content" }, modules[2].content)),
                    React.createElement("div", { className: "content-spacer" })))));
    };

    var Login = function () {
        var _a = reactExports.useState(false), loading = _a[0], setLoading = _a[1];
        var _b = reactExports.useState(""), username = _b[0], setUsername = _b[1];
        var _c = reactExports.useState(""), password = _c[0], setPassword = _c[1];
        var _d = reactExports.useState(""), captcha = _d[0], setCaptcha = _d[1];
        // 
        var randomRef = reactExports.useRef(null);
        var baseUrl = process.env.REACT_APP_DEVLOPMENT_BASE_UL;
        var getCaptcha = function () {
            if (randomRef && randomRef.current) {
                randomRef.current.setAttribute("src", "".concat(baseUrl, "/captcha?v=").concat(Math.random()));
            }
        };
        var loginApi = function () {
            ToLogin({ username: username, password: password, captcha: captcha }, setLoading);
        };
        return (React.createElement("div", { className: "login" },
            React.createElement(Flex, { align: "center", gap: 10, className: "mb1" },
                React.createElement("div", { className: "login-tag" }, "Username:"),
                React.createElement(Input, { placeholder: "Username", className: "flex", value: username, onChange: function (e) { return setUsername(e.target.value); } })),
            React.createElement(Flex, { align: "center", gap: 10, className: "mb1" },
                React.createElement("div", { className: "login-tag" }, "Password:"),
                React.createElement(Input, { placeholder: "Username", className: "flex", value: password, onChange: function (e) { return setPassword(e.target.value); } })),
            React.createElement(Flex, { align: "center", gap: 10, className: "mb1" },
                React.createElement("div", { className: "login-tag" }, "Captcha:"),
                React.createElement(Input, { placeholder: "Username", className: "flex", value: captcha, onChange: function (e) { return setCaptcha(e.target.value); } }),
                React.createElement("img", { src: baseUrl + "/captcha", alt: "captcha", ref: randomRef, onClick: getCaptcha })),
            React.createElement(Flex, { align: "center", justify: "center", className: "mb1" },
                React.createElement(Button, { loading: loading, onClick: loginApi }, "Login")),
            React.createElement(AccessibilityPage, null)));
    };

    // src/pages/MyFeaturePage.tsx
    var MyFeaturePage = function (_a) {
        //   useNavigate(), useLocation()
        //   Redux/Zustand
        //   props  React  hooks
        var apiEndpoint = _a.apiEndpoint, userId = _a.userId; _a.onEvent;
        return (React.createElement("div", { className: "my-feature-sdk" },
            React.createElement("h2", null, "Hello from SDK!"),
            React.createElement("p", null,
                "User: ",
                userId),
            React.createElement("p", null,
                "apiEndpoint: ",
                apiEndpoint),
            React.createElement("div", { style: { marginTop: "20px" } },
                React.createElement(Login, null))));
    };

    var instances = new Map();
    function getElementKey(el) {
        if (typeof el === "string")
            return el;
        if (el.id)
            return "#" + el.id;
        var existingKey = el.getAttribute("data-sdk-key");
        if (existingKey)
            return existingKey;
        var uniqueKey = "sdk-".concat(Date.now(), "-").concat(Math.random()
            .toString(36)
            .slice(2, 9));
        el.setAttribute("data-sdk-key", uniqueKey);
        return uniqueKey;
    }
    function render(options) {
        var target = options.target, props = options.props;
        var container = typeof target === "string"
            ? document.querySelector(target)
            : target;
        if (!container) {
            console.error("[MySDK] Target element not found:", target);
            return;
        }
        var root = clientExports.createRoot(container);
        root.render(React.createElement(MyFeaturePage, __assign({}, props)));
        var key = getElementKey(target);
        instances.set(key, { root: root, container: container });
    }
    function unmount(target) {
        var key = getElementKey(target);
        var instance = instances.get(key);
        if (instance) {
            instance.root.unmount();
            instances.delete(key);
        }
    }
    //   SDK  default 
    var MySDK = { render: render, unmount: unmount };

    return MySDK;

}));
